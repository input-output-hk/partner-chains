#![allow(clippy::redundant_closure_call)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::clone_on_copy)]

#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a TryFrom or FromStr implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "Acquire a point on chain from which to run ledger-state queries."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AcquireLedgerState\","]
#[doc = "  \"description\": \"Acquire a point on chain from which to run ledger-state queries.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"acquireLedgerState\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"point\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"point\": {"]
#[doc = "          \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireLedgerState {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: AcquireLedgerStateJsonrpc,
    pub method: AcquireLedgerStateMethod,
    pub params: AcquireLedgerStateParams,
}
impl ::std::convert::From<&AcquireLedgerState> for AcquireLedgerState {
    fn from(value: &AcquireLedgerState) -> Self {
        value.clone()
    }
}
#[doc = "AcquireLedgerStateFailure"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AcquireLedgerStateFailure\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"Unable to acquire the ledger state at the request point.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            2000"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"A reason for the failure.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"acquireLedgerState\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireLedgerStateFailure {
    pub error: AcquireLedgerStateFailureError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: AcquireLedgerStateFailureJsonrpc,
    pub method: AcquireLedgerStateFailureMethod,
}
impl ::std::convert::From<&AcquireLedgerStateFailure> for AcquireLedgerStateFailure {
    fn from(value: &AcquireLedgerStateFailure) -> Self {
        value.clone()
    }
}
#[doc = "Unable to acquire the ledger state at the request point."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Unable to acquire the ledger state at the request point.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        2000"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"A reason for the failure.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireLedgerStateFailureError {
    pub code: AcquireLedgerStateFailureErrorCode,
    #[doc = "A reason for the failure."]
    pub data: ::std::string::String,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&AcquireLedgerStateFailureError> for AcquireLedgerStateFailureError {
    fn from(value: &AcquireLedgerStateFailureError) -> Self {
        value.clone()
    }
}
#[doc = "AcquireLedgerStateFailureErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    2000"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct AcquireLedgerStateFailureErrorCode(i64);
impl ::std::ops::Deref for AcquireLedgerStateFailureErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<AcquireLedgerStateFailureErrorCode> for i64 {
    fn from(value: AcquireLedgerStateFailureErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AcquireLedgerStateFailureErrorCode>
    for AcquireLedgerStateFailureErrorCode
{
    fn from(value: &AcquireLedgerStateFailureErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for AcquireLedgerStateFailureErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2000_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for AcquireLedgerStateFailureErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "AcquireLedgerStateFailureJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateFailureJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateFailureJsonrpc {
    fn from(value: &AcquireLedgerStateFailureJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateFailureJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateFailureJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateFailureJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateFailureJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateFailureJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateFailureMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"acquireLedgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateFailureMethod {
    #[serde(rename = "acquireLedgerState")]
    AcquireLedgerState,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateFailureMethod {
    fn from(value: &AcquireLedgerStateFailureMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateFailureMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AcquireLedgerState => write!(f, "acquireLedgerState"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateFailureMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "acquireLedgerState" => Ok(Self::AcquireLedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateFailureMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateFailureMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateFailureMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateJsonrpc {
    fn from(value: &AcquireLedgerStateJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"acquireLedgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateMethod {
    #[serde(rename = "acquireLedgerState")]
    AcquireLedgerState,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateMethod {
    fn from(value: &AcquireLedgerStateMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AcquireLedgerState => write!(f, "acquireLedgerState"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "acquireLedgerState" => Ok(Self::AcquireLedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"point\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"point\": {"]
#[doc = "      \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireLedgerStateParams {
    pub point: PointOrOrigin,
}
impl ::std::convert::From<&AcquireLedgerStateParams> for AcquireLedgerStateParams {
    fn from(value: &AcquireLedgerStateParams) -> Self {
        value.clone()
    }
}
#[doc = "AcquireLedgerStateSuccessJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateSuccessJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateSuccessJsonrpc {
    fn from(value: &AcquireLedgerStateSuccessJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateSuccessJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateSuccessJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateSuccessMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"acquireLedgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateSuccessMethod {
    #[serde(rename = "acquireLedgerState")]
    AcquireLedgerState,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateSuccessMethod {
    fn from(value: &AcquireLedgerStateSuccessMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateSuccessMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AcquireLedgerState => write!(f, "acquireLedgerState"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateSuccessMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "acquireLedgerState" => Ok(Self::AcquireLedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireLedgerStateSuccessResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"acquired\","]
#[doc = "    \"point\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"acquired\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"ledgerState\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"point\": {"]
#[doc = "      \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireLedgerStateSuccessResult {
    pub acquired: AcquireLedgerStateSuccessResultAcquired,
    pub point: PointOrOrigin,
}
impl ::std::convert::From<&AcquireLedgerStateSuccessResult> for AcquireLedgerStateSuccessResult {
    fn from(value: &AcquireLedgerStateSuccessResult) -> Self {
        value.clone()
    }
}
#[doc = "AcquireLedgerStateSuccessResultAcquired"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"ledgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireLedgerStateSuccessResultAcquired {
    #[serde(rename = "ledgerState")]
    LedgerState,
}
impl ::std::convert::From<&Self> for AcquireLedgerStateSuccessResultAcquired {
    fn from(value: &AcquireLedgerStateSuccessResultAcquired) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireLedgerStateSuccessResultAcquired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::LedgerState => write!(f, "ledgerState"),
        }
    }
}
impl ::std::str::FromStr for AcquireLedgerStateSuccessResultAcquired {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ledgerState" => Ok(Self::LedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireLedgerStateSuccessResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireLedgerStateSuccessResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireLedgerStateSuccessResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AcquireMempool\","]
#[doc = "  \"description\": \"Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"acquireMempool\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireMempool {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: AcquireMempoolJsonrpc,
    pub method: AcquireMempoolMethod,
}
impl ::std::convert::From<&AcquireMempool> for AcquireMempool {
    fn from(value: &AcquireMempool) -> Self {
        value.clone()
    }
}
#[doc = "AcquireMempoolJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireMempoolJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for AcquireMempoolJsonrpc {
    fn from(value: &AcquireMempoolJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireMempoolJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for AcquireMempoolJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireMempoolMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"acquireMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireMempoolMethod {
    #[serde(rename = "acquireMempool")]
    AcquireMempool,
}
impl ::std::convert::From<&Self> for AcquireMempoolMethod {
    fn from(value: &AcquireMempoolMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireMempoolMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AcquireMempool => write!(f, "acquireMempool"),
        }
    }
}
impl ::std::str::FromStr for AcquireMempoolMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "acquireMempool" => Ok(Self::AcquireMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Response to a 'acquireMempool' request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AcquireMempoolResponse\","]
#[doc = "  \"description\": \"Response to a 'acquireMempool' request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"acquireMempool\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"acquired\","]
#[doc = "        \"slot\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"acquired\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"mempool\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"slot\": {"]
#[doc = "          \"$ref\": \"#/definitions/Slot\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireMempoolResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: AcquireMempoolResponseJsonrpc,
    pub method: AcquireMempoolResponseMethod,
    pub result: AcquireMempoolResponseResult,
}
impl ::std::convert::From<&AcquireMempoolResponse> for AcquireMempoolResponse {
    fn from(value: &AcquireMempoolResponse) -> Self {
        value.clone()
    }
}
#[doc = "AcquireMempoolResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireMempoolResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for AcquireMempoolResponseJsonrpc {
    fn from(value: &AcquireMempoolResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireMempoolResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for AcquireMempoolResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireMempoolResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"acquireMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireMempoolResponseMethod {
    #[serde(rename = "acquireMempool")]
    AcquireMempool,
}
impl ::std::convert::From<&Self> for AcquireMempoolResponseMethod {
    fn from(value: &AcquireMempoolResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireMempoolResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AcquireMempool => write!(f, "acquireMempool"),
        }
    }
}
impl ::std::str::FromStr for AcquireMempoolResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "acquireMempool" => Ok(Self::AcquireMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AcquireMempoolResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"acquired\","]
#[doc = "    \"slot\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"acquired\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"mempool\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"slot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AcquireMempoolResponseResult {
    pub acquired: AcquireMempoolResponseResultAcquired,
    pub slot: Slot,
}
impl ::std::convert::From<&AcquireMempoolResponseResult> for AcquireMempoolResponseResult {
    fn from(value: &AcquireMempoolResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "AcquireMempoolResponseResultAcquired"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"mempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AcquireMempoolResponseResultAcquired {
    #[serde(rename = "mempool")]
    Mempool,
}
impl ::std::convert::From<&Self> for AcquireMempoolResponseResultAcquired {
    fn from(value: &AcquireMempoolResponseResultAcquired) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AcquireMempoolResponseResultAcquired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Mempool => write!(f, "mempool"),
        }
    }
}
impl ::std::str::FromStr for AcquireMempoolResponseResultAcquired {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "mempool" => Ok(Self::Mempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AcquireMempoolResponseResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AcquireMempoolResponseResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AcquireMempoolResponseResultAcquired {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Cardano address (either legacy format or new format)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Address\","]
#[doc = "  \"description\": \"A Cardano address (either legacy format or new format).\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"addr1q9d34spgg2kdy47n82e7x9pdd6vql6d2engxmpj20jmhuc2047yqd4xnh7u6u5jp4t0q3fkxzckph4tgnzvamlu7k5psuahzcp\","]
#[doc = "    \"DdzFFzCqrht8mbSTZHqpM2u4HeND2mdspsaBhdQ1BowPJBMzbDeBMeKgqdoKqo1D4sdPusEdZJVrFJRBBxX1jUEofNDYCJSZLg8MkyCE\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"[1-9A-HJ-NP-Za-km-z]*\","]
#[doc = "  \"contentEncoding\": \"bech32|base58\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct Address(::std::string::String);
impl ::std::ops::Deref for Address {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Address> for ::std::string::String {
    fn from(value: Address) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Address> for Address {
    fn from(value: &Address) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for Address {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("[1-9A-HJ-NP-Za-km-z]*")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"[1-9A-HJ-NP-Za-km-z]*\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for Address {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Address {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Address {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for Address {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Extra attributes carried by Byron addresses (network magic and/or HD payload)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AddressAttributes\","]
#[doc = "  \"description\": \"Extra attributes carried by Byron addresses (network magic and/or HD payload).\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct AddressAttributes(pub ::std::string::String);
impl ::std::ops::Deref for AddressAttributes {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<AddressAttributes> for ::std::string::String {
    fn from(value: AddressAttributes) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AddressAttributes> for AddressAttributes {
    fn from(value: &AddressAttributes) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for AddressAttributes {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for AddressAttributes {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for AddressAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Anchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Anchor\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\","]
#[doc = "    \"url\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Any>\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Anchor {
    pub hash: DigestAny,
    pub url: ::std::string::String,
}
impl ::std::convert::From<&Anchor> for Anchor {
    fn from(value: &Anchor) -> Self {
        value.clone()
    }
}
#[doc = "AnyDelegateRepresentativeCredential"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AnyDelegateRepresentativeCredential\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/_encodingBase16\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Bech32<drep_vkh, drep_script>\","]
#[doc = "      \"description\": \"A Blake2b 28-byte hash digest of a drep verification key or script.\","]
#[doc = "      \"examples\": ["]
#[doc = "        \"drep_vkh12rtxfdsnnftykmpq2sw0uezgmh66zpr8t2mgr0rhmtm06ygr39j\","]
#[doc = "        \"drep_script1mh66zpr8t2mgr0rhmtm065xkvjmp8xjkfdkzq4qulejyst8h2gg\""]
#[doc = "      ],"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(drep_vkh|drep_script)1[0-9a-z]*$\","]
#[doc = "      \"contentEncoding\": \"bech32\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyDelegateRepresentativeCredential {
    EncodingBase16(EncodingBase16),
    Bech32DrepVkhDrepScript(Bech32DrepVkhDrepScript),
}
impl ::std::convert::From<&Self> for AnyDelegateRepresentativeCredential {
    fn from(value: &AnyDelegateRepresentativeCredential) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnyDelegateRepresentativeCredential {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::EncodingBase16(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Bech32DrepVkhDrepScript(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnyDelegateRepresentativeCredential {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnyDelegateRepresentativeCredential {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnyDelegateRepresentativeCredential {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnyDelegateRepresentativeCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::EncodingBase16(x) => x.fmt(f),
            Self::Bech32DrepVkhDrepScript(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<EncodingBase16> for AnyDelegateRepresentativeCredential {
    fn from(value: EncodingBase16) -> Self {
        Self::EncodingBase16(value)
    }
}
impl ::std::convert::From<Bech32DrepVkhDrepScript> for AnyDelegateRepresentativeCredential {
    fn from(value: Bech32DrepVkhDrepScript) -> Self {
        Self::Bech32DrepVkhDrepScript(value)
    }
}
#[doc = "AnyStakeCredential"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AnyStakeCredential\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/_encodingBase16\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Bech32<stake_vkh, script>\","]
#[doc = "      \"description\": \"A Blake2b 28-byte hash digest of a verification key or script.\","]
#[doc = "      \"examples\": ["]
#[doc = "        \"script1dss9g887v3rdmadpq3n44d5ph3ma4aha2rtxfdsnnftykaau8x7\","]
#[doc = "        \"stake_vkh1dss9g887v3rdmadpq3n44d5ph3ma4aha2rtxfdsnnftyklueu8u\""]
#[doc = "      ],"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(stake_vkh|script)1[0-9a-z]*$\","]
#[doc = "      \"contentEncoding\": \"bech32\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Stake Address\","]
#[doc = "      \"$ref\": \"#/definitions/StakeAddress\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyStakeCredential {
    EncodingBase16(EncodingBase16),
    Bech32StakeVkhScript(Bech32StakeVkhScript),
    StakeAddress(StakeAddress),
}
impl ::std::convert::From<&Self> for AnyStakeCredential {
    fn from(value: &AnyStakeCredential) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnyStakeCredential {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::EncodingBase16(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Bech32StakeVkhScript(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::StakeAddress(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnyStakeCredential {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnyStakeCredential {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnyStakeCredential {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnyStakeCredential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::EncodingBase16(x) => x.fmt(f),
            Self::Bech32StakeVkhScript(x) => x.fmt(f),
            Self::StakeAddress(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<EncodingBase16> for AnyStakeCredential {
    fn from(value: EncodingBase16) -> Self {
        Self::EncodingBase16(value)
    }
}
impl ::std::convert::From<Bech32StakeVkhScript> for AnyStakeCredential {
    fn from(value: Bech32StakeVkhScript) -> Self {
        Self::Bech32StakeVkhScript(value)
    }
}
impl ::std::convert::From<StakeAddress> for AnyStakeCredential {
    fn from(value: StakeAddress) -> Self {
        Self::StakeAddress(value)
    }
}
#[doc = "A number of asset, can be negative went burning assets."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AssetQuantity\","]
#[doc = "  \"description\": \"A number of asset, can be negative went burning assets.\","]
#[doc = "  \"type\": \"integer\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct AssetQuantity(pub i64);
impl ::std::ops::Deref for AssetQuantity {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<AssetQuantity> for i64 {
    fn from(value: AssetQuantity) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AssetQuantity> for AssetQuantity {
    fn from(value: &AssetQuantity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for AssetQuantity {
    fn from(value: i64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for AssetQuantity {
    type Err = <i64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for AssetQuantity {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for AssetQuantity {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for AssetQuantity {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for AssetQuantity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Assets"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Assets\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"additionalProperties\": {"]
#[doc = "      \"$ref\": \"#/definitions/AssetQuantity\""]
#[doc = "    },"]
#[doc = "    \"propertyNames\": {"]
#[doc = "      \"pattern\": \"^[0-9a-f]{0,64}$\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"pattern\": \"^[0-9a-f]{56}$\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Assets(
    pub  ::std::collections::HashMap<
        AssetsKey,
        ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
    >,
);
impl ::std::ops::Deref for Assets {
    type Target = ::std::collections::HashMap<
        AssetsKey,
        ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
    >;
    fn deref(
        &self,
    ) -> &::std::collections::HashMap<
        AssetsKey,
        ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
    > {
        &self.0
    }
}
impl ::std::convert::From<Assets>
    for ::std::collections::HashMap<
        AssetsKey,
        ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
    >
{
    fn from(value: Assets) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Assets> for Assets {
    fn from(value: &Assets) -> Self {
        value.clone()
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            AssetsKey,
            ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
        >,
    > for Assets
{
    fn from(
        value: ::std::collections::HashMap<
            AssetsKey,
            ::std::collections::HashMap<AssetsValueKey, AssetQuantity>,
        >,
    ) -> Self {
        Self(value)
    }
}
#[doc = "AssetsKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]{56}$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct AssetsKey(::std::string::String);
impl ::std::ops::Deref for AssetsKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<AssetsKey> for ::std::string::String {
    fn from(value: AssetsKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AssetsKey> for AssetsKey {
    fn from(value: &AssetsKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AssetsKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]{56}$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]{56}$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for AssetsKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AssetsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AssetsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for AssetsKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "AssetsValueKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]{0,64}$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct AssetsValueKey(::std::string::String);
impl ::std::ops::Deref for AssetsValueKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<AssetsValueKey> for ::std::string::String {
    fn from(value: AssetsValueKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AssetsValueKey> for AssetsValueKey {
    fn from(value: &AssetsValueKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AssetsValueKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]{0,64}$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]{0,64}$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for AssetsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AssetsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AssetsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for AssetsValueKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A Blake2b 28-byte hash digest of a drep verification key or script."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Bech32<drep_vkh, drep_script>\","]
#[doc = "  \"description\": \"A Blake2b 28-byte hash digest of a drep verification key or script.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"drep_vkh12rtxfdsnnftykmpq2sw0uezgmh66zpr8t2mgr0rhmtm06ygr39j\","]
#[doc = "    \"drep_script1mh66zpr8t2mgr0rhmtm065xkvjmp8xjkfdkzq4qulejyst8h2gg\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(drep_vkh|drep_script)1[0-9a-z]*$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct Bech32DrepVkhDrepScript(::std::string::String);
impl ::std::ops::Deref for Bech32DrepVkhDrepScript {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Bech32DrepVkhDrepScript> for ::std::string::String {
    fn from(value: Bech32DrepVkhDrepScript) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Bech32DrepVkhDrepScript> for Bech32DrepVkhDrepScript {
    fn from(value: &Bech32DrepVkhDrepScript) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for Bech32DrepVkhDrepScript {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(drep_vkh|drep_script)1[0-9a-z]*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(drep_vkh|drep_script)1[0-9a-z]*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for Bech32DrepVkhDrepScript {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Bech32DrepVkhDrepScript {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Bech32DrepVkhDrepScript {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for Bech32DrepVkhDrepScript {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A Blake2b 28-byte hash digest of a verification key or script."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Bech32<stake_vkh, script>\","]
#[doc = "  \"description\": \"A Blake2b 28-byte hash digest of a verification key or script.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"script1dss9g887v3rdmadpq3n44d5ph3ma4aha2rtxfdsnnftykaau8x7\","]
#[doc = "    \"stake_vkh1dss9g887v3rdmadpq3n44d5ph3ma4aha2rtxfdsnnftyklueu8u\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(stake_vkh|script)1[0-9a-z]*$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct Bech32StakeVkhScript(::std::string::String);
impl ::std::ops::Deref for Bech32StakeVkhScript {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Bech32StakeVkhScript> for ::std::string::String {
    fn from(value: Bech32StakeVkhScript) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Bech32StakeVkhScript> for Bech32StakeVkhScript {
    fn from(value: &Bech32StakeVkhScript) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for Bech32StakeVkhScript {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(stake_vkh|script)1[0-9a-z]*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(stake_vkh|script)1[0-9a-z]*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for Bech32StakeVkhScript {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Bech32StakeVkhScript {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Bech32StakeVkhScript {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for Bech32StakeVkhScript {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Block"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Block\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Block<EBB>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Block<BFT>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Block<Praos>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Block {
    Ebb(BlockEbb),
    Bft(BlockBft),
    Praos(BlockPraos),
}
impl ::std::convert::From<&Self> for Block {
    fn from(value: &Block) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlockEbb> for Block {
    fn from(value: BlockEbb) -> Self {
        Self::Ebb(value)
    }
}
impl ::std::convert::From<BlockBft> for Block {
    fn from(value: BlockBft) -> Self {
        Self::Bft(value)
    }
}
impl ::std::convert::From<BlockPraos> for Block {
    fn from(value: BlockPraos) -> Self {
        Self::Praos(value)
    }
}
#[doc = "BlockBft"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Block<BFT>\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ancestor\","]
#[doc = "    \"delegate\","]
#[doc = "    \"era\","]
#[doc = "    \"height\","]
#[doc = "    \"id\","]
#[doc = "    \"issuer\","]
#[doc = "    \"protocol\","]
#[doc = "    \"size\","]
#[doc = "    \"slot\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ancestor\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"delegate\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExtendedVerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"byron\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"issuer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExtendedVerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"operationalCertificates\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/BootstrapOperationalCertificate\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"protocol\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"software\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/BootstrapProtocolId\""]
#[doc = "        },"]
#[doc = "        \"software\": {"]
#[doc = "          \"$ref\": \"#/definitions/SoftwareVersion\""]
#[doc = "        },"]
#[doc = "        \"update\": {"]
#[doc = "          \"$ref\": \"#/definitions/BootstrapProtocolUpdate\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"slot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    },"]
#[doc = "    \"transactions\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Transaction\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"bft\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockBft {
    pub ancestor: DigestBlake2b256,
    pub delegate: BlockBftDelegate,
    pub era: BlockBftEra,
    pub height: BlockHeight,
    pub id: DigestBlake2b256,
    pub issuer: BlockBftIssuer,
    #[serde(
        rename = "operationalCertificates",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub operational_certificates: ::std::vec::Vec<BootstrapOperationalCertificate>,
    pub protocol: BlockBftProtocol,
    pub size: NumberOfBytes,
    pub slot: Slot,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub transactions: ::std::vec::Vec<Transaction>,
    #[serde(rename = "type")]
    pub type_: BlockBftType,
}
impl ::std::convert::From<&BlockBft> for BlockBft {
    fn from(value: &BlockBft) -> Self {
        value.clone()
    }
}
#[doc = "BlockBftDelegate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExtendedVerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockBftDelegate {
    #[serde(rename = "verificationKey")]
    pub verification_key: ExtendedVerificationKey,
}
impl ::std::convert::From<&BlockBftDelegate> for BlockBftDelegate {
    fn from(value: &BlockBftDelegate) -> Self {
        value.clone()
    }
}
#[doc = "BlockBftEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"byron\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockBftEra {
    #[serde(rename = "byron")]
    Byron,
}
impl ::std::convert::From<&Self> for BlockBftEra {
    fn from(value: &BlockBftEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockBftEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Byron => write!(f, "byron"),
        }
    }
}
impl ::std::str::FromStr for BlockBftEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "byron" => Ok(Self::Byron),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockBftEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockBftEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockBftEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlockBftIssuer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExtendedVerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockBftIssuer {
    #[serde(rename = "verificationKey")]
    pub verification_key: ExtendedVerificationKey,
}
impl ::std::convert::From<&BlockBftIssuer> for BlockBftIssuer {
    fn from(value: &BlockBftIssuer) -> Self {
        value.clone()
    }
}
#[doc = "BlockBftProtocol"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"software\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/BootstrapProtocolId\""]
#[doc = "    },"]
#[doc = "    \"software\": {"]
#[doc = "      \"$ref\": \"#/definitions/SoftwareVersion\""]
#[doc = "    },"]
#[doc = "    \"update\": {"]
#[doc = "      \"$ref\": \"#/definitions/BootstrapProtocolUpdate\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockBftProtocol {
    pub id: BootstrapProtocolId,
    pub software: SoftwareVersion,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub update: ::std::option::Option<BootstrapProtocolUpdate>,
    pub version: ProtocolVersion,
}
impl ::std::convert::From<&BlockBftProtocol> for BlockBftProtocol {
    fn from(value: &BlockBftProtocol) -> Self {
        value.clone()
    }
}
#[doc = "BlockBftType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"bft\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockBftType {
    #[serde(rename = "bft")]
    Bft,
}
impl ::std::convert::From<&Self> for BlockBftType {
    fn from(value: &BlockBftType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockBftType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bft => write!(f, "bft"),
        }
    }
}
impl ::std::str::FromStr for BlockBftType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "bft" => Ok(Self::Bft),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockBftType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockBftType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockBftType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlockEbb"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Block<EBB>\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ancestor\","]
#[doc = "    \"era\","]
#[doc = "    \"height\","]
#[doc = "    \"id\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ancestor\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"byron\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"ebb\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockEbb {
    pub ancestor: DigestBlake2b256,
    pub era: BlockEbbEra,
    pub height: BlockHeight,
    pub id: DigestBlake2b256,
    #[serde(rename = "type")]
    pub type_: BlockEbbType,
}
impl ::std::convert::From<&BlockEbb> for BlockEbb {
    fn from(value: &BlockEbb) -> Self {
        value.clone()
    }
}
#[doc = "BlockEbbEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"byron\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockEbbEra {
    #[serde(rename = "byron")]
    Byron,
}
impl ::std::convert::From<&Self> for BlockEbbEra {
    fn from(value: &BlockEbbEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockEbbEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Byron => write!(f, "byron"),
        }
    }
}
impl ::std::str::FromStr for BlockEbbEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "byron" => Ok(Self::Byron),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockEbbEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockEbbEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockEbbEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlockEbbType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"ebb\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockEbbType {
    #[serde(rename = "ebb")]
    Ebb,
}
impl ::std::convert::From<&Self> for BlockEbbType {
    fn from(value: &BlockEbbType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockEbbType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Ebb => write!(f, "ebb"),
        }
    }
}
impl ::std::str::FromStr for BlockEbbType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ebb" => Ok(Self::Ebb),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockEbbType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockEbbType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockEbbType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A block number, the i-th block to be minted is number i."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BlockHeight\","]
#[doc = "  \"description\": \"A block number, the i-th block to be minted is number i.\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 1.8446744073709552e19,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct BlockHeight(pub u64);
impl ::std::ops::Deref for BlockHeight {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<BlockHeight> for u64 {
    fn from(value: BlockHeight) -> Self {
        value.0
    }
}
impl ::std::convert::From<&BlockHeight> for BlockHeight {
    fn from(value: &BlockHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for BlockHeight {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for BlockHeight {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for BlockHeight {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for BlockHeight {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for BlockHeight {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for BlockHeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "BlockPraos"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Block<Praos>\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ancestor\","]
#[doc = "    \"era\","]
#[doc = "    \"height\","]
#[doc = "    \"id\","]
#[doc = "    \"issuer\","]
#[doc = "    \"protocol\","]
#[doc = "    \"size\","]
#[doc = "    \"slot\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ancestor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"GenesisHash\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"genesis\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"shelley\","]
#[doc = "        \"allegra\","]
#[doc = "        \"mary\","]
#[doc = "        \"alonzo\","]
#[doc = "        \"babbage\","]
#[doc = "        \"conway\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"issuer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"leaderValue\","]
#[doc = "        \"operationalCertificate\","]
#[doc = "        \"verificationKey\","]
#[doc = "        \"vrfVerificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"leaderValue\": {"]
#[doc = "          \"$ref\": \"#/definitions/CertifiedVrf\""]
#[doc = "        },"]
#[doc = "        \"operationalCertificate\": {"]
#[doc = "          \"$ref\": \"#/definitions/OperationalCertificate\""]
#[doc = "        },"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "        },"]
#[doc = "        \"vrfVerificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"$ref\": \"#/definitions/CertifiedVrf\""]
#[doc = "    },"]
#[doc = "    \"protocol\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"version\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"slot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    },"]
#[doc = "    \"transactions\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Transaction\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"praos\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockPraos {
    pub ancestor: BlockPraosAncestor,
    pub era: BlockPraosEra,
    pub height: BlockHeight,
    pub id: DigestBlake2b256,
    pub issuer: BlockPraosIssuer,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub nonce: ::std::option::Option<CertifiedVrf>,
    pub protocol: BlockPraosProtocol,
    pub size: NumberOfBytes,
    pub slot: Slot,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub transactions: ::std::vec::Vec<Transaction>,
    #[serde(rename = "type")]
    pub type_: BlockPraosType,
}
impl ::std::convert::From<&BlockPraos> for BlockPraos {
    fn from(value: &BlockPraos) -> Self {
        value.clone()
    }
}
#[doc = "BlockPraosAncestor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GenesisHash\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"genesis\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlockPraosAncestor {
    DigestBlake2b256(DigestBlake2b256),
    GenesisHash(GenesisHash),
}
impl ::std::convert::From<&Self> for BlockPraosAncestor {
    fn from(value: &BlockPraosAncestor) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BlockPraosAncestor {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::DigestBlake2b256(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::GenesisHash(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockPraosAncestor {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockPraosAncestor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockPraosAncestor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BlockPraosAncestor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::DigestBlake2b256(x) => x.fmt(f),
            Self::GenesisHash(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DigestBlake2b256> for BlockPraosAncestor {
    fn from(value: DigestBlake2b256) -> Self {
        Self::DigestBlake2b256(value)
    }
}
impl ::std::convert::From<GenesisHash> for BlockPraosAncestor {
    fn from(value: GenesisHash) -> Self {
        Self::GenesisHash(value)
    }
}
#[doc = "BlockPraosEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"shelley\","]
#[doc = "    \"allegra\","]
#[doc = "    \"mary\","]
#[doc = "    \"alonzo\","]
#[doc = "    \"babbage\","]
#[doc = "    \"conway\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockPraosEra {
    #[serde(rename = "shelley")]
    Shelley,
    #[serde(rename = "allegra")]
    Allegra,
    #[serde(rename = "mary")]
    Mary,
    #[serde(rename = "alonzo")]
    Alonzo,
    #[serde(rename = "babbage")]
    Babbage,
    #[serde(rename = "conway")]
    Conway,
}
impl ::std::convert::From<&Self> for BlockPraosEra {
    fn from(value: &BlockPraosEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockPraosEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Shelley => write!(f, "shelley"),
            Self::Allegra => write!(f, "allegra"),
            Self::Mary => write!(f, "mary"),
            Self::Alonzo => write!(f, "alonzo"),
            Self::Babbage => write!(f, "babbage"),
            Self::Conway => write!(f, "conway"),
        }
    }
}
impl ::std::str::FromStr for BlockPraosEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "shelley" => Ok(Self::Shelley),
            "allegra" => Ok(Self::Allegra),
            "mary" => Ok(Self::Mary),
            "alonzo" => Ok(Self::Alonzo),
            "babbage" => Ok(Self::Babbage),
            "conway" => Ok(Self::Conway),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockPraosEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockPraosEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockPraosEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlockPraosIssuer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"leaderValue\","]
#[doc = "    \"operationalCertificate\","]
#[doc = "    \"verificationKey\","]
#[doc = "    \"vrfVerificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"leaderValue\": {"]
#[doc = "      \"$ref\": \"#/definitions/CertifiedVrf\""]
#[doc = "    },"]
#[doc = "    \"operationalCertificate\": {"]
#[doc = "      \"$ref\": \"#/definitions/OperationalCertificate\""]
#[doc = "    },"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    },"]
#[doc = "    \"vrfVerificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockPraosIssuer {
    #[serde(rename = "leaderValue")]
    pub leader_value: CertifiedVrf,
    #[serde(rename = "operationalCertificate")]
    pub operational_certificate: OperationalCertificate,
    #[serde(rename = "verificationKey")]
    pub verification_key: VerificationKey,
    #[serde(rename = "vrfVerificationKey")]
    pub vrf_verification_key: VerificationKey,
}
impl ::std::convert::From<&BlockPraosIssuer> for BlockPraosIssuer {
    fn from(value: &BlockPraosIssuer) -> Self {
        value.clone()
    }
}
#[doc = "BlockPraosProtocol"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"version\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BlockPraosProtocol {
    pub version: ProtocolVersion,
}
impl ::std::convert::From<&BlockPraosProtocol> for BlockPraosProtocol {
    fn from(value: &BlockPraosProtocol) -> Self {
        value.clone()
    }
}
#[doc = "BlockPraosType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"praos\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlockPraosType {
    #[serde(rename = "praos")]
    Praos,
}
impl ::std::convert::From<&Self> for BlockPraosType {
    fn from(value: &BlockPraosType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlockPraosType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Praos => write!(f, "praos"),
        }
    }
}
impl ::std::str::FromStr for BlockPraosType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "praos" => Ok(Self::Praos),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockPraosType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockPraosType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockPraosType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A (Byron) delegation certificate."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BootstrapOperationalCertificate\","]
#[doc = "  \"description\": \"A (Byron) delegation certificate.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegate\","]
#[doc = "    \"issuer\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegate\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"issuer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapOperationalCertificate {
    pub delegate: BootstrapOperationalCertificateDelegate,
    pub issuer: BootstrapOperationalCertificateIssuer,
}
impl ::std::convert::From<&BootstrapOperationalCertificate> for BootstrapOperationalCertificate {
    fn from(value: &BootstrapOperationalCertificate) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapOperationalCertificateDelegate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapOperationalCertificateDelegate {
    #[serde(rename = "verificationKey")]
    pub verification_key: VerificationKey,
}
impl ::std::convert::From<&BootstrapOperationalCertificateDelegate>
    for BootstrapOperationalCertificateDelegate
{
    fn from(value: &BootstrapOperationalCertificateDelegate) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapOperationalCertificateIssuer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapOperationalCertificateIssuer {
    #[serde(rename = "verificationKey")]
    pub verification_key: VerificationKey,
}
impl ::std::convert::From<&BootstrapOperationalCertificateIssuer>
    for BootstrapOperationalCertificateIssuer
{
    fn from(value: &BootstrapOperationalCertificateIssuer) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapProtocolId"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BootstrapProtocolId\","]
#[doc = "  \"examples\": ["]
#[doc = "    764824073"]
#[doc = "  ],"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 4294967295.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct BootstrapProtocolId(pub u32);
impl ::std::ops::Deref for BootstrapProtocolId {
    type Target = u32;
    fn deref(&self) -> &u32 {
        &self.0
    }
}
impl ::std::convert::From<BootstrapProtocolId> for u32 {
    fn from(value: BootstrapProtocolId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&BootstrapProtocolId> for BootstrapProtocolId {
    fn from(value: &BootstrapProtocolId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u32> for BootstrapProtocolId {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for BootstrapProtocolId {
    type Err = <u32 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for BootstrapProtocolId {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for BootstrapProtocolId {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for BootstrapProtocolId {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for BootstrapProtocolId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "BootstrapProtocolParameters"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BootstrapProtocolParameters\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"heavyDelegationThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"maxBlockBodySize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxBlockHeaderSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxTransactionSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxUpdateProposalSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"minFeeCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"minFeeConstant\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"multiPartyComputationThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"scriptVersion\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"slotDuration\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"softForkDecrementThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"softForkInitThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"softForkMinThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"unlockStakeEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"updateProposalThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"updateProposalTimeToLive\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"updateVoteThreshold\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapProtocolParameters {
    #[serde(
        rename = "heavyDelegationThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub heavy_delegation_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "maxBlockBodySize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_block_body_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxBlockHeaderSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_block_header_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxTransactionSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_transaction_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxUpdateProposalSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_update_proposal_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "minFeeCoefficient",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_coefficient: ::std::option::Option<UInt64>,
    #[serde(
        rename = "minFeeConstant",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_constant: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "multiPartyComputationThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub multi_party_computation_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "scriptVersion",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub script_version: ::std::option::Option<UInt64>,
    #[serde(
        rename = "slotDuration",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub slot_duration: ::std::option::Option<UInt64>,
    #[serde(
        rename = "softForkDecrementThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub soft_fork_decrement_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "softForkInitThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub soft_fork_init_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "softForkMinThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub soft_fork_min_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "unlockStakeEpoch",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub unlock_stake_epoch: ::std::option::Option<UInt64>,
    #[serde(
        rename = "updateProposalThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub update_proposal_threshold: ::std::option::Option<Ratio>,
    #[serde(
        rename = "updateProposalTimeToLive",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub update_proposal_time_to_live: ::std::option::Option<UInt64>,
    #[serde(
        rename = "updateVoteThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub update_vote_threshold: ::std::option::Option<Ratio>,
}
impl ::std::convert::From<&BootstrapProtocolParameters> for BootstrapProtocolParameters {
    fn from(value: &BootstrapProtocolParameters) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BootstrapProtocolParameters {
    fn default() -> Self {
        Self {
            heavy_delegation_threshold: Default::default(),
            max_block_body_size: Default::default(),
            max_block_header_size: Default::default(),
            max_transaction_size: Default::default(),
            max_update_proposal_size: Default::default(),
            min_fee_coefficient: Default::default(),
            min_fee_constant: Default::default(),
            multi_party_computation_threshold: Default::default(),
            script_version: Default::default(),
            slot_duration: Default::default(),
            soft_fork_decrement_threshold: Default::default(),
            soft_fork_init_threshold: Default::default(),
            soft_fork_min_threshold: Default::default(),
            unlock_stake_epoch: Default::default(),
            update_proposal_threshold: Default::default(),
            update_proposal_time_to_live: Default::default(),
            update_vote_threshold: Default::default(),
        }
    }
}
#[doc = "BootstrapProtocolUpdate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BootstrapProtocolUpdate\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"votes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"metadata\","]
#[doc = "        \"parameters\","]
#[doc = "        \"software\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"parameters\": {"]
#[doc = "          \"$ref\": \"#/definitions/BootstrapProtocolParameters\""]
#[doc = "        },"]
#[doc = "        \"software\": {"]
#[doc = "          \"$ref\": \"#/definitions/SoftwareVersion\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"votes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/BootstrapVote\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapProtocolUpdate {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub proposal: ::std::option::Option<BootstrapProtocolUpdateProposal>,
    pub votes: ::std::vec::Vec<BootstrapVote>,
}
impl ::std::convert::From<&BootstrapProtocolUpdate> for BootstrapProtocolUpdate {
    fn from(value: &BootstrapProtocolUpdate) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapProtocolUpdateProposal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"metadata\","]
#[doc = "    \"parameters\","]
#[doc = "    \"software\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parameters\": {"]
#[doc = "      \"$ref\": \"#/definitions/BootstrapProtocolParameters\""]
#[doc = "    },"]
#[doc = "    \"software\": {"]
#[doc = "      \"$ref\": \"#/definitions/SoftwareVersion\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapProtocolUpdateProposal {
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub parameters: BootstrapProtocolParameters,
    pub software: SoftwareVersion,
    pub version: ProtocolVersion,
}
impl ::std::convert::From<&BootstrapProtocolUpdateProposal> for BootstrapProtocolUpdateProposal {
    fn from(value: &BootstrapProtocolUpdateProposal) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapVote"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BootstrapVote\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"proposal\","]
#[doc = "    \"voter\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"voter\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapVote {
    pub proposal: BootstrapVoteProposal,
    pub voter: BootstrapVoteVoter,
}
impl ::std::convert::From<&BootstrapVote> for BootstrapVote {
    fn from(value: &BootstrapVote) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapVoteProposal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapVoteProposal {
    pub id: DigestBlake2b256,
}
impl ::std::convert::From<&BootstrapVoteProposal> for BootstrapVoteProposal {
    fn from(value: &BootstrapVoteProposal) -> Self {
        value.clone()
    }
}
#[doc = "BootstrapVoteVoter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BootstrapVoteVoter {
    #[serde(rename = "verificationKey")]
    pub verification_key: VerificationKey,
}
impl ::std::convert::From<&BootstrapVoteVoter> for BootstrapVoteVoter {
    fn from(value: &BootstrapVoteVoter) -> Self {
        value.clone()
    }
}
#[doc = "An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Bound\","]
#[doc = "  \"description\": \"An era bound which captures the time, slot and epoch at which the era start. The time is relative to the start time of the network.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epoch\","]
#[doc = "    \"slot\","]
#[doc = "    \"time\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"epoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"slot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    },"]
#[doc = "    \"time\": {"]
#[doc = "      \"$ref\": \"#/definitions/RelativeTime\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Bound {
    pub epoch: Epoch,
    pub slot: Slot,
    pub time: RelativeTime,
}
impl ::std::convert::From<&Bound> for Bound {
    fn from(value: &Bound) -> Self {
        value.clone()
    }
}
#[doc = "Certificate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Certificate\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"StakeDelegation\","]
#[doc = "      \"description\": \"A stake delegation certificate, from a delegator to a stake pool and/or a delegate representative.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"credential\","]
#[doc = "        \"from\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"credential\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"delegateRepresentative\": {"]
#[doc = "          \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"stakePool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakeDelegation\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"StakeCredentialRegistration\","]
#[doc = "      \"description\": \"A stake credential (key or script) registration certificate. The field 'deposit' is only *optionally* present in Conway onwards.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"credential\","]
#[doc = "        \"from\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"credential\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"deposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakeCredentialRegistration\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"StakeCredentialDeregistration\","]
#[doc = "      \"description\": \"A stake key de-registration certificate. The field 'deposit' is only *optionally* present in Conway onwards.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"credential\","]
#[doc = "        \"from\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"credential\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"deposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakeCredentialDeregistration\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"StakePoolRegistration\","]
#[doc = "      \"description\": \"A stake pool registration certificate.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"stakePool\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"stakePool\": {"]
#[doc = "          \"$ref\": \"#/definitions/StakePool\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakePoolRegistration\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"StakePoolRetirement\","]
#[doc = "      \"description\": \"A stake pool retirement certificate.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"stakePool\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"stakePool\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\","]
#[doc = "            \"retirementEpoch\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "            },"]
#[doc = "            \"retirementEpoch\": {"]
#[doc = "              \"$ref\": \"#/definitions/Epoch\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakePoolRetirement\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GenesisDelegation\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegate\","]
#[doc = "        \"issuer\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegate\": {"]
#[doc = "          \"$ref\": \"#/definitions/GenesisDelegate\""]
#[doc = "        },"]
#[doc = "        \"issuer\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"genesisDelegation\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ConstitutionalCommitteeDelegation\","]
#[doc = "      \"description\": \"A constitutional committee member delegates a hot credential for voting on-chain. Constitutional committee members do not vote with their cold key directly. New registrations supersedes any preceding ones.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegate\","]
#[doc = "        \"member\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegate\": {"]
#[doc = "          \"$ref\": \"#/definitions/ConstitutionalCommitteeDelegate\""]
#[doc = "        },"]
#[doc = "        \"member\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\","]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"constitutionalCommitteeDelegation\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ConstitutionalCommitteeRetirement\","]
#[doc = "      \"description\": \"A constitutional committee member resigns from the committee.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"member\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"member\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\","]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"$ref\": \"#/definitions/Anchor\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"constitutionalCommitteeRetirement\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentativeRegistration\","]
#[doc = "      \"description\": \"A delegate representative registration. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegateRepresentative\","]
#[doc = "        \"deposit\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegateRepresentative\": {"]
#[doc = "          \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "        },"]
#[doc = "        \"deposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"$ref\": \"#/definitions/Anchor\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"delegateRepresentativeRegistration\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentativeUpdate\","]
#[doc = "      \"description\": \"\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegateRepresentative\","]
#[doc = "        \"metadata\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegateRepresentative\": {"]
#[doc = "          \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"None\","]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Anchor\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"delegateRepresentativeUpdate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentativeRetirement\","]
#[doc = "      \"description\": \"A delegate representative retirement. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegateRepresentative\","]
#[doc = "        \"deposit\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegateRepresentative\": {"]
#[doc = "          \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "        },"]
#[doc = "        \"deposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"delegateRepresentativeRetirement\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", deny_unknown_fields)]
pub enum Certificate {
    #[doc = "StakeDelegation\n\nA stake delegation certificate, from a delegator to a stake pool and/or a delegate representative."]
    #[serde(rename = "stakeDelegation")]
    StakeDelegation {
        credential: DigestBlake2b224,
        #[serde(
            rename = "delegateRepresentative",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        delegate_representative: ::std::option::Option<DelegateRepresentative>,
        from: CredentialOrigin,
        #[serde(
            rename = "stakePool",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stake_pool: ::std::option::Option<CertificateStakePool>,
    },
    #[doc = "StakeCredentialRegistration\n\nA stake credential (key or script) registration certificate. The field 'deposit' is only *optionally* present in Conway onwards."]
    #[serde(rename = "stakeCredentialRegistration")]
    StakeCredentialRegistration {
        credential: DigestBlake2b224,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        deposit: ::std::option::Option<ValueAdaOnly>,
        from: CredentialOrigin,
    },
    #[doc = "StakeCredentialDeregistration\n\nA stake key de-registration certificate. The field 'deposit' is only *optionally* present in Conway onwards."]
    #[serde(rename = "stakeCredentialDeregistration")]
    StakeCredentialDeregistration {
        credential: DigestBlake2b224,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        deposit: ::std::option::Option<ValueAdaOnly>,
        from: CredentialOrigin,
    },
    #[doc = "StakePoolRegistration\n\nA stake pool registration certificate."]
    #[serde(rename = "stakePoolRegistration")]
    StakePoolRegistration {
        #[serde(rename = "stakePool")]
        stake_pool: StakePool,
    },
    #[doc = "StakePoolRetirement\n\nA stake pool retirement certificate."]
    #[serde(rename = "stakePoolRetirement")]
    StakePoolRetirement {
        #[serde(rename = "stakePool")]
        stake_pool: CertificateStakePool,
    },
    #[doc = "GenesisDelegation"]
    #[serde(rename = "genesisDelegation")]
    GenesisDelegation {
        delegate: GenesisDelegate,
        issuer: CertificateIssuer,
    },
    #[doc = "ConstitutionalCommitteeDelegation\n\nA constitutional committee member delegates a hot credential for voting on-chain. Constitutional committee members do not vote with their cold key directly. New registrations supersedes any preceding ones."]
    #[serde(rename = "constitutionalCommitteeDelegation")]
    ConstitutionalCommitteeDelegation {
        delegate: ConstitutionalCommitteeDelegate,
        member: CertificateMember,
    },
    #[doc = "ConstitutionalCommitteeRetirement\n\nA constitutional committee member resigns from the committee."]
    #[serde(rename = "constitutionalCommitteeRetirement")]
    ConstitutionalCommitteeRetirement {
        member: CertificateMember,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        metadata: ::std::option::Option<Anchor>,
    },
    #[doc = "DelegateRepresentativeRegistration\n\nA delegate representative registration. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)"]
    #[serde(rename = "delegateRepresentativeRegistration")]
    DelegateRepresentativeRegistration {
        #[serde(rename = "delegateRepresentative")]
        delegate_representative: DelegateRepresentative,
        deposit: ValueAdaOnly,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        metadata: ::std::option::Option<Anchor>,
    },
    #[doc = "DelegateRepresentativeUpdate\n\n"]
    #[serde(rename = "delegateRepresentativeUpdate")]
    DelegateRepresentativeUpdate {
        #[serde(rename = "delegateRepresentative")]
        delegate_representative: DelegateRepresentative,
        metadata: ::std::option::Option<Anchor>,
    },
    #[doc = "DelegateRepresentativeRetirement\n\nA delegate representative retirement. Note that this is only possible for 'registered' representatives and not for well-known ones (abstain & noConfidence)"]
    #[serde(rename = "delegateRepresentativeRetirement")]
    DelegateRepresentativeRetirement {
        #[serde(rename = "delegateRepresentative")]
        delegate_representative: DelegateRepresentative,
        deposit: ValueAdaOnly,
    },
}
impl ::std::convert::From<&Self> for Certificate {
    fn from(value: &Certificate) -> Self {
        value.clone()
    }
}
#[doc = "CertificateIssuer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CertificateIssuer {
    pub id: DigestBlake2b224,
}
impl ::std::convert::From<&CertificateIssuer> for CertificateIssuer {
    fn from(value: &CertificateIssuer) -> Self {
        value.clone()
    }
}
#[doc = "CertificateMember"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CertificateMember {
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
}
impl ::std::convert::From<&CertificateMember> for CertificateMember {
    fn from(value: &CertificateMember) -> Self {
        value.clone()
    }
}
#[doc = "CertificateStakePool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CertificateStakePool {
    pub id: StakePoolId,
}
impl ::std::convert::From<&CertificateStakePool> for CertificateStakePool {
    fn from(value: &CertificateStakePool) -> Self {
        value.clone()
    }
}
#[doc = "CertifiedVrf"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"CertifiedVrf\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"output\": {"]
#[doc = "      \"$ref\": \"#/definitions/VrfOutput\""]
#[doc = "    },"]
#[doc = "    \"proof\": {"]
#[doc = "      \"$ref\": \"#/definitions/VrfProof\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CertifiedVrf {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<VrfOutput>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub proof: ::std::option::Option<VrfProof>,
}
impl ::std::convert::From<&CertifiedVrf> for CertifiedVrf {
    fn from(value: &CertifiedVrf) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CertifiedVrf {
    fn default() -> Self {
        Self {
            output: Default::default(),
            proof: Default::default(),
        }
    }
}
#[doc = "An Ed25519-BIP32 chain-code for key deriviation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ChainCode\","]
#[doc = "  \"description\": \"An Ed25519-BIP32 chain-code for key deriviation.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct ChainCode(pub ::std::string::String);
impl ::std::ops::Deref for ChainCode {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ChainCode> for ::std::string::String {
    fn from(value: ChainCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ChainCode> for ChainCode {
    fn from(value: &ChainCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for ChainCode {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for ChainCode {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for ChainCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Constitution"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Constitution\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"guardrails\","]
#[doc = "    \"metadata\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"guardrails\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"hash\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"hash\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Constitution {
    pub guardrails: ConstitutionGuardrails,
    pub metadata: Anchor,
}
impl ::std::convert::From<&Constitution> for Constitution {
    fn from(value: &Constitution) -> Self {
        value.clone()
    }
}
#[doc = "ConstitutionGuardrails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ConstitutionGuardrails {
    Variant0(Null),
    Variant1 { hash: DigestBlake2b224 },
}
impl ::std::convert::From<&Self> for ConstitutionGuardrails {
    fn from(value: &ConstitutionGuardrails) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Null> for ConstitutionGuardrails {
    fn from(value: Null) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ConstitutionalCommitteeDelegate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ConstitutionalCommitteeDelegate\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"status\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"authorized\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"status\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"$ref\": \"#/definitions/Anchor\""]
#[doc = "        },"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"resigned\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"status\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"status\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "status", deny_unknown_fields)]
pub enum ConstitutionalCommitteeDelegate {
    #[serde(rename = "authorized")]
    Authorized {
        from: CredentialOrigin,
        id: DigestBlake2b224,
    },
    #[serde(rename = "resigned")]
    Resigned {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        metadata: ::std::option::Option<Anchor>,
    },
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for ConstitutionalCommitteeDelegate {
    fn from(value: &ConstitutionalCommitteeDelegate) -> Self {
        value.clone()
    }
}
#[doc = "A constitutional committee member as seen in the context of a specific epoch. Statuses and next states are to be seen from this specific epoch. The field 'next', when present, refers to any change happening to this member in the following epoch."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ConstitutionalCommitteeMember\","]
#[doc = "  \"description\": \"A constitutional committee member as seen in the context of a specific epoch. Statuses and next states are to be seen from this specific epoch. The field 'next', when present, refers to any change happening to this member in the following epoch.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegate\","]
#[doc = "    \"from\","]
#[doc = "    \"id\","]
#[doc = "    \"status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegate\": {"]
#[doc = "      \"$ref\": \"#/definitions/ConstitutionalCommitteeDelegate\""]
#[doc = "    },"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    },"]
#[doc = "    \"mandate\": {"]
#[doc = "      \"$ref\": \"#/definitions/Mandate\""]
#[doc = "    },"]
#[doc = "    \"next\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"change\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"change\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"toBeEnacted\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"change\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"change\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"toBeRemoved\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"change\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"change\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"expiring\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"change\","]
#[doc = "            \"mandate\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"change\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"adjustingMandate\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"mandate\": {"]
#[doc = "              \"$ref\": \"#/definitions/Mandate\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"A member status. 'active' indicates that this member vote will count during the ratification of the ongoing epoch. 'unrecognized' means that some hot credential currently points to a non-existing (or no longer existing) member.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"active\","]
#[doc = "        \"expired\","]
#[doc = "        \"unrecognized\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ConstitutionalCommitteeMember {
    pub delegate: ConstitutionalCommitteeDelegate,
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mandate: ::std::option::Option<Mandate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub next: ::std::option::Option<ConstitutionalCommitteeMemberNext>,
    #[doc = "A member status. 'active' indicates that this member vote will count during the ratification of the ongoing epoch. 'unrecognized' means that some hot credential currently points to a non-existing (or no longer existing) member."]
    pub status: ConstitutionalCommitteeMemberStatus,
}
impl ::std::convert::From<&ConstitutionalCommitteeMember> for ConstitutionalCommitteeMember {
    fn from(value: &ConstitutionalCommitteeMember) -> Self {
        value.clone()
    }
}
#[doc = "ConstitutionalCommitteeMemberNext"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"toBeEnacted\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"toBeRemoved\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"expiring\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"mandate\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"adjustingMandate\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mandate\": {"]
#[doc = "          \"$ref\": \"#/definitions/Mandate\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "change", content = "mandate")]
pub enum ConstitutionalCommitteeMemberNext {
    #[serde(rename = "toBeEnacted")]
    ToBeEnacted,
    #[serde(rename = "toBeRemoved")]
    ToBeRemoved,
    #[serde(rename = "expiring")]
    Expiring,
    #[serde(rename = "adjustingMandate")]
    AdjustingMandate(Mandate),
}
impl ::std::convert::From<&Self> for ConstitutionalCommitteeMemberNext {
    fn from(value: &ConstitutionalCommitteeMemberNext) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Mandate> for ConstitutionalCommitteeMemberNext {
    fn from(value: Mandate) -> Self {
        Self::AdjustingMandate(value)
    }
}
#[doc = "A member status. 'active' indicates that this member vote will count during the ratification of the ongoing epoch. 'unrecognized' means that some hot credential currently points to a non-existing (or no longer existing) member."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A member status. 'active' indicates that this member vote will count during the ratification of the ongoing epoch. 'unrecognized' means that some hot credential currently points to a non-existing (or no longer existing) member.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"active\","]
#[doc = "    \"expired\","]
#[doc = "    \"unrecognized\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ConstitutionalCommitteeMemberStatus {
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "expired")]
    Expired,
    #[serde(rename = "unrecognized")]
    Unrecognized,
}
impl ::std::convert::From<&Self> for ConstitutionalCommitteeMemberStatus {
    fn from(value: &ConstitutionalCommitteeMemberStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ConstitutionalCommitteeMemberStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Active => write!(f, "active"),
            Self::Expired => write!(f, "expired"),
            Self::Unrecognized => write!(f, "unrecognized"),
        }
    }
}
impl ::std::str::FromStr for ConstitutionalCommitteeMemberStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "active" => Ok(Self::Active),
            "expired" => Ok(Self::Expired),
            "unrecognized" => Ok(Self::Unrecognized),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ConstitutionalCommitteeMemberStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ConstitutionalCommitteeMemberStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ConstitutionalCommitteeMemberStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ConstitutionalCommitteeMemberSummary"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ConstitutionalCommitteeMemberSummary\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    },"]
#[doc = "    \"mandate\": {"]
#[doc = "      \"$ref\": \"#/definitions/Mandate\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ConstitutionalCommitteeMemberSummary {
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mandate: ::std::option::Option<Mandate>,
}
impl ::std::convert::From<&ConstitutionalCommitteeMemberSummary>
    for ConstitutionalCommitteeMemberSummary
{
    fn from(value: &ConstitutionalCommitteeMemberSummary) -> Self {
        value.clone()
    }
}
#[doc = "CostModel"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"CostModel\","]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"$ref\": \"#/definitions/Int64\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct CostModel(pub ::std::vec::Vec<Int64>);
impl ::std::ops::Deref for CostModel {
    type Target = ::std::vec::Vec<Int64>;
    fn deref(&self) -> &::std::vec::Vec<Int64> {
        &self.0
    }
}
impl ::std::convert::From<CostModel> for ::std::vec::Vec<Int64> {
    fn from(value: CostModel) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CostModel> for CostModel {
    fn from(value: &CostModel) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<Int64>> for CostModel {
    fn from(value: ::std::vec::Vec<Int64>) -> Self {
        Self(value)
    }
}
#[doc = "CostModels"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"CostModels\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"plutus:v1\": ["]
#[doc = "        14,"]
#[doc = "        123"]
#[doc = "      ],"]
#[doc = "      \"plutus:v2\": ["]
#[doc = "        14,"]
#[doc = "        42,"]
#[doc = "        131"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"$ref\": \"#/definitions/CostModel\""]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"$ref\": \"#/definitions/Language\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct CostModels(pub ::std::collections::HashMap<Language, CostModel>);
impl ::std::ops::Deref for CostModels {
    type Target = ::std::collections::HashMap<Language, CostModel>;
    fn deref(&self) -> &::std::collections::HashMap<Language, CostModel> {
        &self.0
    }
}
impl ::std::convert::From<CostModels> for ::std::collections::HashMap<Language, CostModel> {
    fn from(value: CostModels) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CostModels> for CostModels {
    fn from(value: &CostModels) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::collections::HashMap<Language, CostModel>> for CostModels {
    fn from(value: ::std::collections::HashMap<Language, CostModel>) -> Self {
        Self(value)
    }
}
#[doc = "CredentialOrigin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"CredentialOrigin\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"verificationKey\","]
#[doc = "    \"script\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CredentialOrigin {
    #[serde(rename = "verificationKey")]
    VerificationKey,
    #[serde(rename = "script")]
    Script,
}
impl ::std::convert::From<&Self> for CredentialOrigin {
    fn from(value: &CredentialOrigin) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CredentialOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::VerificationKey => write!(f, "verificationKey"),
            Self::Script => write!(f, "script"),
        }
    }
}
impl ::std::str::FromStr for CredentialOrigin {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "verificationKey" => Ok(Self::VerificationKey),
            "script" => Ok(Self::Script),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CredentialOrigin {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CredentialOrigin {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CredentialOrigin {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Datum"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Datum\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Datum(pub ::std::string::String);
impl ::std::ops::Deref for Datum {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Datum> for ::std::string::String {
    fn from(value: Datum) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Datum> for Datum {
    fn from(value: &Datum) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Datum {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Datum {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Datum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "DelegateRepresentative"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DelegateRepresentative\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentative<Registered>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"registered\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentative<NoConfidence>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"description\": \"A special delegate representative which always vote no, except on votes of no-confidence.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"noConfidence\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentative<Abstain>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"description\": \"A special delegate representative which always abstain.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"abstain\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", deny_unknown_fields)]
pub enum DelegateRepresentative {
    #[doc = "DelegateRepresentative<Registered>"]
    #[serde(rename = "registered")]
    Registered {
        from: CredentialOrigin,
        id: DigestBlake2b224,
    },
    #[serde(rename = "noConfidence")]
    NoConfidence,
    #[serde(rename = "abstain")]
    Abstain,
}
impl ::std::convert::From<&Self> for DelegateRepresentative {
    fn from(value: &DelegateRepresentative) -> Self {
        value.clone()
    }
}
#[doc = "DelegateRepresentativeSummary"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DelegateRepresentativeSummary\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentativeSummary<Registered>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"delegators\","]
#[doc = "        \"deposit\","]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"mandate\","]
#[doc = "        \"stake\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"delegators\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"credential\","]
#[doc = "              \"from\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"credential\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              },"]
#[doc = "              \"from\": {"]
#[doc = "                \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"deposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"mandate\": {"]
#[doc = "          \"$ref\": \"#/definitions/Mandate\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"$ref\": \"#/definitions/Anchor\""]
#[doc = "        },"]
#[doc = "        \"stake\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"registered\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentativeSummary<NoConfidence>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"stake\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"stake\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"description\": \"A special delegate representative which always vote no, except on votes of no-confidence.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"noConfidence\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DelegateRepresentative<Abstain>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"stake\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"stake\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"description\": \"A special delegate representative which always abstain.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"abstain\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", deny_unknown_fields)]
pub enum DelegateRepresentativeSummary {
    #[doc = "DelegateRepresentativeSummary<Registered>"]
    #[serde(rename = "registered")]
    Registered {
        delegators: ::std::vec::Vec<DelegateRepresentativeSummaryDelegatorsItem>,
        deposit: ValueAdaOnly,
        from: CredentialOrigin,
        id: DigestBlake2b224,
        mandate: Mandate,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        metadata: ::std::option::Option<Anchor>,
        stake: ValueAdaOnly,
    },
    #[doc = "DelegateRepresentativeSummary<NoConfidence>"]
    #[serde(rename = "noConfidence")]
    NoConfidence { stake: ValueAdaOnly },
    #[doc = "DelegateRepresentative<Abstain>"]
    #[serde(rename = "abstain")]
    Abstain { stake: ValueAdaOnly },
}
impl ::std::convert::From<&Self> for DelegateRepresentativeSummary {
    fn from(value: &DelegateRepresentativeSummary) -> Self {
        value.clone()
    }
}
#[doc = "DelegateRepresentativeSummaryDelegatorsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"credential\","]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"credential\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    },"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DelegateRepresentativeSummaryDelegatorsItem {
    pub credential: DigestBlake2b224,
    pub from: CredentialOrigin,
}
impl ::std::convert::From<&DelegateRepresentativeSummaryDelegatorsItem>
    for DelegateRepresentativeSummaryDelegatorsItem
{
    fn from(value: &DelegateRepresentativeSummaryDelegatorsItem) -> Self {
        value.clone()
    }
}
#[doc = "DelegateRepresentativeVotingThresholds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DelegateRepresentativeVotingThresholds\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"constitution\","]
#[doc = "    \"constitutionalCommittee\","]
#[doc = "    \"hardForkInitiation\","]
#[doc = "    \"noConfidence\","]
#[doc = "    \"protocolParametersUpdate\","]
#[doc = "    \"treasuryWithdrawals\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"constitution\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommittee\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"default\","]
#[doc = "        \"stateOfNoConfidence\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"default\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"stateOfNoConfidence\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"hardForkInitiation\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"noConfidence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"protocolParametersUpdate\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"economic\","]
#[doc = "        \"governance\","]
#[doc = "        \"network\","]
#[doc = "        \"technical\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"economic\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"governance\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"network\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"technical\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"treasuryWithdrawals\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DelegateRepresentativeVotingThresholds {
    pub constitution: Ratio,
    #[serde(rename = "constitutionalCommittee")]
    pub constitutional_committee: DelegateRepresentativeVotingThresholdsConstitutionalCommittee,
    #[serde(rename = "hardForkInitiation")]
    pub hard_fork_initiation: Ratio,
    #[serde(rename = "noConfidence")]
    pub no_confidence: Ratio,
    #[serde(rename = "protocolParametersUpdate")]
    pub protocol_parameters_update: DelegateRepresentativeVotingThresholdsProtocolParametersUpdate,
    #[serde(rename = "treasuryWithdrawals")]
    pub treasury_withdrawals: Ratio,
}
impl ::std::convert::From<&DelegateRepresentativeVotingThresholds>
    for DelegateRepresentativeVotingThresholds
{
    fn from(value: &DelegateRepresentativeVotingThresholds) -> Self {
        value.clone()
    }
}
#[doc = "DelegateRepresentativeVotingThresholdsConstitutionalCommittee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"default\","]
#[doc = "    \"stateOfNoConfidence\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"stateOfNoConfidence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DelegateRepresentativeVotingThresholdsConstitutionalCommittee {
    pub default: Ratio,
    #[serde(rename = "stateOfNoConfidence")]
    pub state_of_no_confidence: Ratio,
}
impl ::std::convert::From<&DelegateRepresentativeVotingThresholdsConstitutionalCommittee>
    for DelegateRepresentativeVotingThresholdsConstitutionalCommittee
{
    fn from(value: &DelegateRepresentativeVotingThresholdsConstitutionalCommittee) -> Self {
        value.clone()
    }
}
#[doc = "DelegateRepresentativeVotingThresholdsProtocolParametersUpdate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"economic\","]
#[doc = "    \"governance\","]
#[doc = "    \"network\","]
#[doc = "    \"technical\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"economic\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"governance\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"network\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"technical\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DelegateRepresentativeVotingThresholdsProtocolParametersUpdate {
    pub economic: Ratio,
    pub governance: Ratio,
    pub network: Ratio,
    pub technical: Ratio,
}
impl ::std::convert::From<&DelegateRepresentativeVotingThresholdsProtocolParametersUpdate>
    for DelegateRepresentativeVotingThresholdsProtocolParametersUpdate
{
    fn from(value: &DelegateRepresentativeVotingThresholdsProtocolParametersUpdate) -> Self {
        value.clone()
    }
}
#[doc = "The input failed to deserialize in any of the known era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DeserialisationFailure\","]
#[doc = "  \"description\": \"The input failed to deserialize in any of the known era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        -32602"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"allegra\","]
#[doc = "        \"alonzo\","]
#[doc = "        \"babbage\","]
#[doc = "        \"conway\","]
#[doc = "        \"mary\","]
#[doc = "        \"shelley\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"allegra\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"alonzo\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"babbage\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"conway\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"mary\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"shelley\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeserialisationFailure {
    pub code: DeserialisationFailureCode,
    pub data: DeserialisationFailureData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&DeserialisationFailure> for DeserialisationFailure {
    fn from(value: &DeserialisationFailure) -> Self {
        value.clone()
    }
}
#[doc = "DeserialisationFailureCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    -32602"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct DeserialisationFailureCode(i64);
impl ::std::ops::Deref for DeserialisationFailureCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<DeserialisationFailureCode> for i64 {
    fn from(value: DeserialisationFailureCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DeserialisationFailureCode> for DeserialisationFailureCode {
    fn from(value: &DeserialisationFailureCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for DeserialisationFailureCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![-32602_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for DeserialisationFailureCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "DeserialisationFailureData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"allegra\","]
#[doc = "    \"alonzo\","]
#[doc = "    \"babbage\","]
#[doc = "    \"conway\","]
#[doc = "    \"mary\","]
#[doc = "    \"shelley\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allegra\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"alonzo\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"babbage\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"conway\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"mary\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"shelley\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DeserialisationFailureData {
    pub allegra: ::std::string::String,
    pub alonzo: ::std::string::String,
    pub babbage: ::std::string::String,
    pub conway: ::std::string::String,
    pub mary: ::std::string::String,
    pub shelley: ::std::string::String,
}
impl ::std::convert::From<&DeserialisationFailureData> for DeserialisationFailureData {
    fn from(value: &DeserialisationFailureData) -> Self {
        value.clone()
    }
}
#[doc = "A hash digest from an unspecified algorithm and length."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Digest<Any>\","]
#[doc = "  \"description\": \"A hash digest from an unspecified algorithm and length.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"90181c517a5beadc9c3fe64bf8\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct DigestAny(pub ::std::string::String);
impl ::std::ops::Deref for DigestAny {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DigestAny> for ::std::string::String {
    fn from(value: DigestAny) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DigestAny> for DigestAny {
    fn from(value: &DigestAny) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for DigestAny {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for DigestAny {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for DigestAny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "A Blake2b 28-byte hash digest, encoded in base16."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Digest<Blake2b, 224>\","]
#[doc = "  \"description\": \"A Blake2b 28-byte hash digest, encoded in base16.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"90181c517a5beadc9c3fe64bf821d3e889a963fc717003ec248757d3\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 56,"]
#[doc = "  \"minLength\": 56,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DigestBlake2b224(::std::string::String);
impl ::std::ops::Deref for DigestBlake2b224 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DigestBlake2b224> for ::std::string::String {
    fn from(value: DigestBlake2b224) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DigestBlake2b224> for DigestBlake2b224 {
    fn from(value: &DigestBlake2b224) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DigestBlake2b224 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 56usize {
            return Err("longer than 56 characters".into());
        }
        if value.len() < 56usize {
            return Err("shorter than 56 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for DigestBlake2b224 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DigestBlake2b224 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DigestBlake2b224 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for DigestBlake2b224 {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A Blake2b 32-byte hash digest, encoded in base16."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Digest<Blake2b, 256>\","]
#[doc = "  \"description\": \"A Blake2b 32-byte hash digest, encoded in base16.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"c248757d390181c517a5beadc9c3fe64bf821d3e889a963fc717003ec248757d\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 64,"]
#[doc = "  \"minLength\": 64,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DigestBlake2b256(::std::string::String);
impl ::std::ops::Deref for DigestBlake2b256 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DigestBlake2b256> for ::std::string::String {
    fn from(value: DigestBlake2b256) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DigestBlake2b256> for DigestBlake2b256 {
    fn from(value: &DigestBlake2b256) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DigestBlake2b256 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 64usize {
            return Err("longer than 64 characters".into());
        }
        if value.len() < 64usize {
            return Err("shorter than 64 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for DigestBlake2b256 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DigestBlake2b256 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DigestBlake2b256 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for DigestBlake2b256 {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A key or script hash in base16."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Base16\","]
#[doc = "  \"description\": \"A key or script hash in base16.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 56,"]
#[doc = "  \"minLength\": 56,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct EncodingBase16(::std::string::String);
impl ::std::ops::Deref for EncodingBase16 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<EncodingBase16> for ::std::string::String {
    fn from(value: EncodingBase16) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EncodingBase16> for EncodingBase16 {
    fn from(value: &EncodingBase16) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for EncodingBase16 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 56usize {
            return Err("longer than 56 characters".into());
        }
        if value.len() < 56usize {
            return Err("shorter than 56 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for EncodingBase16 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EncodingBase16 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EncodingBase16 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for EncodingBase16 {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "An epoch number or length."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Epoch\","]
#[doc = "  \"description\": \"An epoch number or length.\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 1.8446744073709552e19,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Epoch(pub u64);
impl ::std::ops::Deref for Epoch {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<Epoch> for u64 {
    fn from(value: Epoch) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Epoch> for Epoch {
    fn from(value: &Epoch) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for Epoch {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Epoch {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for Epoch {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for Epoch {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for Epoch {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for Epoch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Era"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Era\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"byron\","]
#[doc = "    \"shelley\","]
#[doc = "    \"allegra\","]
#[doc = "    \"mary\","]
#[doc = "    \"alonzo\","]
#[doc = "    \"babbage\","]
#[doc = "    \"conway\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Era {
    #[serde(rename = "byron")]
    Byron,
    #[serde(rename = "shelley")]
    Shelley,
    #[serde(rename = "allegra")]
    Allegra,
    #[serde(rename = "mary")]
    Mary,
    #[serde(rename = "alonzo")]
    Alonzo,
    #[serde(rename = "babbage")]
    Babbage,
    #[serde(rename = "conway")]
    Conway,
}
impl ::std::convert::From<&Self> for Era {
    fn from(value: &Era) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Era {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Byron => write!(f, "byron"),
            Self::Shelley => write!(f, "shelley"),
            Self::Allegra => write!(f, "allegra"),
            Self::Mary => write!(f, "mary"),
            Self::Alonzo => write!(f, "alonzo"),
            Self::Babbage => write!(f, "babbage"),
            Self::Conway => write!(f, "conway"),
        }
    }
}
impl ::std::str::FromStr for Era {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "byron" => Ok(Self::Byron),
            "shelley" => Ok(Self::Shelley),
            "allegra" => Ok(Self::Allegra),
            "mary" => Ok(Self::Mary),
            "alonzo" => Ok(Self::Alonzo),
            "babbage" => Ok(Self::Babbage),
            "conway" => Ok(Self::Conway),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Era {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Era {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Era {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EraMismatch"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EraMismatch\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ledgerEra\","]
#[doc = "    \"queryEra\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ledgerEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    },"]
#[doc = "    \"queryEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EraMismatch {
    #[serde(rename = "ledgerEra")]
    pub ledger_era: Era,
    #[serde(rename = "queryEra")]
    pub query_era: Era,
}
impl ::std::convert::From<&EraMismatch> for EraMismatch {
    fn from(value: &EraMismatch) -> Self {
        value.clone()
    }
}
#[doc = "Parameters that can vary across hard forks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EraParameters\","]
#[doc = "  \"description\": \"Parameters that can vary across hard forks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epochLength\","]
#[doc = "    \"safeZone\","]
#[doc = "    \"slotLength\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"epochLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"safeZone\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/SafeZone\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"slotLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/SlotLength\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EraParameters {
    #[serde(rename = "epochLength")]
    pub epoch_length: Epoch,
    #[serde(rename = "safeZone")]
    pub safe_zone: ::std::option::Option<SafeZone>,
    #[serde(rename = "slotLength")]
    pub slot_length: SlotLength,
}
impl ::std::convert::From<&EraParameters> for EraParameters {
    fn from(value: &EraParameters) -> Self {
        value.clone()
    }
}
#[doc = "Summary of the confirmed parts of the ledger."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EraSummary\","]
#[doc = "  \"description\": \"Summary of the confirmed parts of the ledger.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"parameters\","]
#[doc = "    \"start\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"end\": {"]
#[doc = "      \"$ref\": \"#/definitions/Bound\""]
#[doc = "    },"]
#[doc = "    \"parameters\": {"]
#[doc = "      \"$ref\": \"#/definitions/EraParameters\""]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"$ref\": \"#/definitions/Bound\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EraSummary {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub end: ::std::option::Option<Bound>,
    pub parameters: EraParameters,
    pub start: Bound,
}
impl ::std::convert::From<&EraSummary> for EraSummary {
    fn from(value: &EraSummary) -> Self {
        value.clone()
    }
}
#[doc = "EraWithGenesis"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EraWithGenesis\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"byron\","]
#[doc = "    \"shelley\","]
#[doc = "    \"alonzo\","]
#[doc = "    \"conway\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EraWithGenesis {
    #[serde(rename = "byron")]
    Byron,
    #[serde(rename = "shelley")]
    Shelley,
    #[serde(rename = "alonzo")]
    Alonzo,
    #[serde(rename = "conway")]
    Conway,
}
impl ::std::convert::From<&Self> for EraWithGenesis {
    fn from(value: &EraWithGenesis) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EraWithGenesis {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Byron => write!(f, "byron"),
            Self::Shelley => write!(f, "shelley"),
            Self::Alonzo => write!(f, "alonzo"),
            Self::Conway => write!(f, "conway"),
        }
    }
}
impl ::std::str::FromStr for EraWithGenesis {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "byron" => Ok(Self::Byron),
            "shelley" => Ok(Self::Shelley),
            "alonzo" => Ok(Self::Alonzo),
            "conway" => Ok(Self::Conway),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EraWithGenesis {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EraWithGenesis {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EraWithGenesis {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Evaluate execution units for which redeemers's budget hasn't yet been set."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EvaluateTransaction\","]
#[doc = "  \"description\": \"Evaluate execution units for which redeemers's budget hasn't yet been set.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"evaluateTransaction\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"transaction\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"additionalUtxo\": {"]
#[doc = "          \"$ref\": \"#/definitions/Utxo\""]
#[doc = "        },"]
#[doc = "        \"transaction\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"cbor\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"cbor\": {"]
#[doc = "              \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "              \"contentEncoding\": \"base16\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransaction {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: EvaluateTransactionJsonrpc,
    pub method: EvaluateTransactionMethod,
    pub params: EvaluateTransactionParams,
}
impl ::std::convert::From<&EvaluateTransaction> for EvaluateTransaction {
    fn from(value: &EvaluateTransaction) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionDeserialisationErrorJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionDeserialisationErrorJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for EvaluateTransactionDeserialisationErrorJsonrpc {
    fn from(value: &EvaluateTransactionDeserialisationErrorJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionDeserialisationErrorJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionDeserialisationErrorJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionDeserialisationErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for EvaluateTransactionDeserialisationErrorJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for EvaluateTransactionDeserialisationErrorJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionDeserialisationErrorMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"evaluateTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionDeserialisationErrorMethod {
    #[serde(rename = "evaluateTransaction")]
    EvaluateTransaction,
}
impl ::std::convert::From<&Self> for EvaluateTransactionDeserialisationErrorMethod {
    fn from(value: &EvaluateTransactionDeserialisationErrorMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionDeserialisationErrorMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::EvaluateTransaction => write!(f, "evaluateTransaction"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionDeserialisationErrorMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "evaluateTransaction" => Ok(Self::EvaluateTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionDeserialisationErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for EvaluateTransactionDeserialisationErrorMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for EvaluateTransactionDeserialisationErrorMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionErrorJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionErrorJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for EvaluateTransactionErrorJsonrpc {
    fn from(value: &EvaluateTransactionErrorJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionErrorJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionErrorJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionErrorMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"evaluateTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionErrorMethod {
    #[serde(rename = "evaluateTransaction")]
    EvaluateTransaction,
}
impl ::std::convert::From<&Self> for EvaluateTransactionErrorMethod {
    fn from(value: &EvaluateTransactionErrorMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionErrorMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::EvaluateTransaction => write!(f, "evaluateTransaction"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionErrorMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "evaluateTransaction" => Ok(Self::EvaluateTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionFailure"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<IncompatibleEra>\","]
#[doc = "      \"description\": \"Returned when trying to evaluate execution units of a pre-Alonzo transaction. Note that this isn't possible with Ogmios because transactions are always de-serialized as Alonzo transactions.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3000"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"The era in which the transaction has been identified.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"incompatibleEra\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"incompatibleEra\": {"]
#[doc = "              \"$ref\": \"#/definitions/Era\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<UnsupportedEra>\","]
#[doc = "      \"description\": \"Returned when trying to evaluate execution units of an era that is now considered too old and is no longer supported. This can solved by using a more recent transaction format.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3001"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"The era in which the transaction has been identified.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unsupportedEra\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unsupportedEra\": {"]
#[doc = "              \"$ref\": \"#/definitions/Era\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<OverlappingAdditionalUtxo>\","]
#[doc = "      \"description\": \"Happens when providing an additional UTXO set which overlaps with the UTXO on-chain.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3002"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"overlappingOutputReferences\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"overlappingOutputReferences\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<NodeTipTooOld>\","]
#[doc = "      \"description\": \"Happens when attempting to evaluate execution units on a node that isn't enough synchronized.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3003"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"currentNodeEra\","]
#[doc = "            \"minimumRequiredEra\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"currentNodeEra\": {"]
#[doc = "              \"$ref\": \"#/definitions/Era\""]
#[doc = "            },"]
#[doc = "            \"minimumRequiredEra\": {"]
#[doc = "              \"$ref\": \"#/definitions/Era\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<CannotCreateEvaluationContext>\","]
#[doc = "      \"description\": \"The transaction is malformed or missing information; making evaluation impossible.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3004"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"reason\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"reason\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionFailure<ScriptExecutionFailure>\","]
#[doc = "      \"description\": \"One or more script execution terminated with an error.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3010"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"error\","]
#[doc = "              \"validator\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"error\": {"]
#[doc = "                \"$ref\": \"#/definitions/ScriptExecutionFailure\""]
#[doc = "              },"]
#[doc = "              \"validator\": {"]
#[doc = "                \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum EvaluateTransactionFailure {
    IncompatibleEra {
        code: EvaluateTransactionFailureIncompatibleEraCode,
        data: EvaluateTransactionFailureIncompatibleEraData,
        message: ::std::string::String,
    },
    UnsupportedEra {
        code: EvaluateTransactionFailureUnsupportedEraCode,
        data: EvaluateTransactionFailureUnsupportedEraData,
        message: ::std::string::String,
    },
    OverlappingAdditionalUtxo {
        code: EvaluateTransactionFailureOverlappingAdditionalUtxoCode,
        data: EvaluateTransactionFailureOverlappingAdditionalUtxoData,
        message: ::std::string::String,
    },
    NodeTipTooOld {
        code: EvaluateTransactionFailureNodeTipTooOldCode,
        data: EvaluateTransactionFailureNodeTipTooOldData,
        message: ::std::string::String,
    },
    CannotCreateEvaluationContext {
        code: EvaluateTransactionFailureCannotCreateEvaluationContextCode,
        data: EvaluateTransactionFailureCannotCreateEvaluationContextData,
        message: ::std::string::String,
    },
    ScriptExecutionFailure {
        code: EvaluateTransactionFailureScriptExecutionFailureCode,
        data: ::std::vec::Vec<EvaluateTransactionFailureScriptExecutionFailureDataItem>,
        message: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for EvaluateTransactionFailure {
    fn from(value: &EvaluateTransactionFailure) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureCannotCreateEvaluationContextCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3004"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureCannotCreateEvaluationContextCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureCannotCreateEvaluationContextCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureCannotCreateEvaluationContextCode> for i64 {
    fn from(value: EvaluateTransactionFailureCannotCreateEvaluationContextCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureCannotCreateEvaluationContextCode>
    for EvaluateTransactionFailureCannotCreateEvaluationContextCode
{
    fn from(value: &EvaluateTransactionFailureCannotCreateEvaluationContextCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureCannotCreateEvaluationContextCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3004_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for EvaluateTransactionFailureCannotCreateEvaluationContextCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "EvaluateTransactionFailureCannotCreateEvaluationContextData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"reason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"reason\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureCannotCreateEvaluationContextData {
    pub reason: ::std::string::String,
}
impl ::std::convert::From<&EvaluateTransactionFailureCannotCreateEvaluationContextData>
    for EvaluateTransactionFailureCannotCreateEvaluationContextData
{
    fn from(value: &EvaluateTransactionFailureCannotCreateEvaluationContextData) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureIncompatibleEraCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3000"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureIncompatibleEraCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureIncompatibleEraCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureIncompatibleEraCode> for i64 {
    fn from(value: EvaluateTransactionFailureIncompatibleEraCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureIncompatibleEraCode>
    for EvaluateTransactionFailureIncompatibleEraCode
{
    fn from(value: &EvaluateTransactionFailureIncompatibleEraCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureIncompatibleEraCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3000_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionFailureIncompatibleEraCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "The era in which the transaction has been identified."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The era in which the transaction has been identified.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"incompatibleEra\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"incompatibleEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureIncompatibleEraData {
    #[serde(rename = "incompatibleEra")]
    pub incompatible_era: Era,
}
impl ::std::convert::From<&EvaluateTransactionFailureIncompatibleEraData>
    for EvaluateTransactionFailureIncompatibleEraData
{
    fn from(value: &EvaluateTransactionFailureIncompatibleEraData) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureNodeTipTooOldCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3003"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureNodeTipTooOldCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureNodeTipTooOldCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureNodeTipTooOldCode> for i64 {
    fn from(value: EvaluateTransactionFailureNodeTipTooOldCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureNodeTipTooOldCode>
    for EvaluateTransactionFailureNodeTipTooOldCode
{
    fn from(value: &EvaluateTransactionFailureNodeTipTooOldCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureNodeTipTooOldCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3003_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionFailureNodeTipTooOldCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "EvaluateTransactionFailureNodeTipTooOldData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"currentNodeEra\","]
#[doc = "    \"minimumRequiredEra\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"currentNodeEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    },"]
#[doc = "    \"minimumRequiredEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureNodeTipTooOldData {
    #[serde(rename = "currentNodeEra")]
    pub current_node_era: Era,
    #[serde(rename = "minimumRequiredEra")]
    pub minimum_required_era: Era,
}
impl ::std::convert::From<&EvaluateTransactionFailureNodeTipTooOldData>
    for EvaluateTransactionFailureNodeTipTooOldData
{
    fn from(value: &EvaluateTransactionFailureNodeTipTooOldData) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureOverlappingAdditionalUtxoCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3002"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureOverlappingAdditionalUtxoCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureOverlappingAdditionalUtxoCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureOverlappingAdditionalUtxoCode> for i64 {
    fn from(value: EvaluateTransactionFailureOverlappingAdditionalUtxoCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureOverlappingAdditionalUtxoCode>
    for EvaluateTransactionFailureOverlappingAdditionalUtxoCode
{
    fn from(value: &EvaluateTransactionFailureOverlappingAdditionalUtxoCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureOverlappingAdditionalUtxoCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3002_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionFailureOverlappingAdditionalUtxoCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "EvaluateTransactionFailureOverlappingAdditionalUtxoData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"overlappingOutputReferences\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"overlappingOutputReferences\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureOverlappingAdditionalUtxoData {
    #[serde(rename = "overlappingOutputReferences")]
    pub overlapping_output_references: ::std::vec::Vec<TransactionOutputReference>,
}
impl ::std::convert::From<&EvaluateTransactionFailureOverlappingAdditionalUtxoData>
    for EvaluateTransactionFailureOverlappingAdditionalUtxoData
{
    fn from(value: &EvaluateTransactionFailureOverlappingAdditionalUtxoData) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureScriptExecutionFailureCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3010"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureScriptExecutionFailureCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureScriptExecutionFailureCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureScriptExecutionFailureCode> for i64 {
    fn from(value: EvaluateTransactionFailureScriptExecutionFailureCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureScriptExecutionFailureCode>
    for EvaluateTransactionFailureScriptExecutionFailureCode
{
    fn from(value: &EvaluateTransactionFailureScriptExecutionFailureCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureScriptExecutionFailureCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3010_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionFailureScriptExecutionFailureCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "EvaluateTransactionFailureScriptExecutionFailureDataItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"validator\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"$ref\": \"#/definitions/ScriptExecutionFailure\""]
#[doc = "    },"]
#[doc = "    \"validator\": {"]
#[doc = "      \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureScriptExecutionFailureDataItem {
    pub error: ScriptExecutionFailure,
    pub validator: RedeemerPointer,
}
impl ::std::convert::From<&EvaluateTransactionFailureScriptExecutionFailureDataItem>
    for EvaluateTransactionFailureScriptExecutionFailureDataItem
{
    fn from(value: &EvaluateTransactionFailureScriptExecutionFailureDataItem) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionFailureUnsupportedEraCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3001"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EvaluateTransactionFailureUnsupportedEraCode(i64);
impl ::std::ops::Deref for EvaluateTransactionFailureUnsupportedEraCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionFailureUnsupportedEraCode> for i64 {
    fn from(value: EvaluateTransactionFailureUnsupportedEraCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionFailureUnsupportedEraCode>
    for EvaluateTransactionFailureUnsupportedEraCode
{
    fn from(value: &EvaluateTransactionFailureUnsupportedEraCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for EvaluateTransactionFailureUnsupportedEraCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3001_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionFailureUnsupportedEraCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "The era in which the transaction has been identified."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The era in which the transaction has been identified.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unsupportedEra\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unsupportedEra\": {"]
#[doc = "      \"$ref\": \"#/definitions/Era\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionFailureUnsupportedEraData {
    #[serde(rename = "unsupportedEra")]
    pub unsupported_era: Era,
}
impl ::std::convert::From<&EvaluateTransactionFailureUnsupportedEraData>
    for EvaluateTransactionFailureUnsupportedEraData
{
    fn from(value: &EvaluateTransactionFailureUnsupportedEraData) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for EvaluateTransactionJsonrpc {
    fn from(value: &EvaluateTransactionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"evaluateTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionMethod {
    #[serde(rename = "evaluateTransaction")]
    EvaluateTransaction,
}
impl ::std::convert::From<&Self> for EvaluateTransactionMethod {
    fn from(value: &EvaluateTransactionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::EvaluateTransaction => write!(f, "evaluateTransaction"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "evaluateTransaction" => Ok(Self::EvaluateTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"additionalUtxo\": {"]
#[doc = "      \"$ref\": \"#/definitions/Utxo\""]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cbor\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cbor\": {"]
#[doc = "          \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "          \"contentEncoding\": \"base16\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionParams {
    #[serde(
        rename = "additionalUtxo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub additional_utxo: ::std::option::Option<Utxo>,
    pub transaction: EvaluateTransactionParamsTransaction,
}
impl ::std::convert::From<&EvaluateTransactionParams> for EvaluateTransactionParams {
    fn from(value: &EvaluateTransactionParams) -> Self {
        value.clone()
    }
}
#[doc = "EvaluateTransactionParamsTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cbor\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cbor\": {"]
#[doc = "      \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "      \"contentEncoding\": \"base16\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionParamsTransaction {
    #[doc = "CBOR-serialized signed transaction (base16)"]
    pub cbor: EvaluateTransactionParamsTransactionCbor,
}
impl ::std::convert::From<&EvaluateTransactionParamsTransaction>
    for EvaluateTransactionParamsTransaction
{
    fn from(value: &EvaluateTransactionParamsTransaction) -> Self {
        value.clone()
    }
}
#[doc = "CBOR-serialized signed transaction (base16)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct EvaluateTransactionParamsTransactionCbor(::std::string::String);
impl ::std::ops::Deref for EvaluateTransactionParamsTransactionCbor {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<EvaluateTransactionParamsTransactionCbor> for ::std::string::String {
    fn from(value: EvaluateTransactionParamsTransactionCbor) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EvaluateTransactionParamsTransactionCbor>
    for EvaluateTransactionParamsTransactionCbor
{
    fn from(value: &EvaluateTransactionParamsTransactionCbor) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for EvaluateTransactionParamsTransactionCbor {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for EvaluateTransactionParamsTransactionCbor {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "EvaluateTransactionSuccessJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionSuccessJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for EvaluateTransactionSuccessJsonrpc {
    fn from(value: &EvaluateTransactionSuccessJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionSuccessJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionSuccessJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionSuccessMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"evaluateTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum EvaluateTransactionSuccessMethod {
    #[serde(rename = "evaluateTransaction")]
    EvaluateTransaction,
}
impl ::std::convert::From<&Self> for EvaluateTransactionSuccessMethod {
    fn from(value: &EvaluateTransactionSuccessMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for EvaluateTransactionSuccessMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::EvaluateTransaction => write!(f, "evaluateTransaction"),
        }
    }
}
impl ::std::str::FromStr for EvaluateTransactionSuccessMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "evaluateTransaction" => Ok(Self::EvaluateTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for EvaluateTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EvaluateTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EvaluateTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "EvaluateTransactionSuccessResultItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"budget\","]
#[doc = "    \"validator\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"budget\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"validator\": {"]
#[doc = "      \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct EvaluateTransactionSuccessResultItem {
    pub budget: ExecutionUnits,
    pub validator: RedeemerPointer,
}
impl ::std::convert::From<&EvaluateTransactionSuccessResultItem>
    for EvaluateTransactionSuccessResultItem
{
    fn from(value: &EvaluateTransactionSuccessResultItem) -> Self {
        value.clone()
    }
}
#[doc = "ExecutionUnits"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ExecutionUnits\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cpu\","]
#[doc = "    \"memory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cpu\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"memory\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ExecutionUnits {
    pub cpu: UInt64,
    pub memory: UInt64,
}
impl ::std::convert::From<&ExecutionUnits> for ExecutionUnits {
    fn from(value: &ExecutionUnits) -> Self {
        value.clone()
    }
}
#[doc = "An Ed25519-BIP32 Byron genesis delegate verification key with chain-code."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ExtendedVerificationKey\","]
#[doc = "  \"description\": \"An Ed25519-BIP32 Byron genesis delegate verification key with chain-code.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 128,"]
#[doc = "  \"minLength\": 128,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ExtendedVerificationKey(::std::string::String);
impl ::std::ops::Deref for ExtendedVerificationKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ExtendedVerificationKey> for ::std::string::String {
    fn from(value: ExtendedVerificationKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ExtendedVerificationKey> for ExtendedVerificationKey {
    fn from(value: &ExtendedVerificationKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ExtendedVerificationKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 128usize {
            return Err("longer than 128 characters".into());
        }
        if value.len() < 128usize {
            return Err("shorter than 128 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ExtendedVerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExtendedVerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExtendedVerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ExtendedVerificationKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Ask cardano-node to find an intersection between its local chain and the given points."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"FindIntersection\","]
#[doc = "  \"description\": \"Ask cardano-node to find an intersection between its local chain and the given points.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"findIntersection\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"points\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FindIntersection {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: FindIntersectionJsonrpc,
    pub method: FindIntersectionMethod,
    pub params: FindIntersectionParams,
}
impl ::std::convert::From<&FindIntersection> for FindIntersection {
    fn from(value: &FindIntersection) -> Self {
        value.clone()
    }
}
#[doc = "FindIntersectionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FindIntersectionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for FindIntersectionJsonrpc {
    fn from(value: &FindIntersectionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FindIntersectionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for FindIntersectionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FindIntersectionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FindIntersectionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FindIntersectionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "FindIntersectionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"findIntersection\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FindIntersectionMethod {
    #[serde(rename = "findIntersection")]
    FindIntersection,
}
impl ::std::convert::From<&Self> for FindIntersectionMethod {
    fn from(value: &FindIntersectionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FindIntersectionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FindIntersection => write!(f, "findIntersection"),
        }
    }
}
impl ::std::str::FromStr for FindIntersectionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "findIntersection" => Ok(Self::FindIntersection),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FindIntersectionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FindIntersectionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FindIntersectionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "FindIntersectionParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"points\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FindIntersectionParams {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub points: ::std::vec::Vec<PointOrOrigin>,
}
impl ::std::convert::From<&FindIntersectionParams> for FindIntersectionParams {
    fn from(value: &FindIntersectionParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for FindIntersectionParams {
    fn default() -> Self {
        Self {
            points: Default::default(),
        }
    }
}
#[doc = "An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Genesis<Alonzo>\","]
#[doc = "  \"description\": \"An Alonzo genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"era\","]
#[doc = "    \"updatableParameters\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"alonzo\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updatableParameters\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"collateralPercentage\","]
#[doc = "        \"maxCollateralInputs\","]
#[doc = "        \"maxExecutionUnitsPerBlock\","]
#[doc = "        \"maxExecutionUnitsPerTransaction\","]
#[doc = "        \"maxValueSize\","]
#[doc = "        \"minUtxoDepositCoefficient\","]
#[doc = "        \"plutusCostModels\","]
#[doc = "        \"scriptExecutionPrices\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"collateralPercentage\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"maxCollateralInputs\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"maxExecutionUnitsPerBlock\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "        },"]
#[doc = "        \"maxExecutionUnitsPerTransaction\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "        },"]
#[doc = "        \"maxValueSize\": {"]
#[doc = "          \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "        },"]
#[doc = "        \"minUtxoDepositCoefficient\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"plutusCostModels\": {"]
#[doc = "          \"$ref\": \"#/definitions/CostModels\""]
#[doc = "        },"]
#[doc = "        \"scriptExecutionPrices\": {"]
#[doc = "          \"$ref\": \"#/definitions/ScriptExecutionPrices\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisAlonzo {
    pub era: GenesisAlonzoEra,
    #[serde(rename = "updatableParameters")]
    pub updatable_parameters: GenesisAlonzoUpdatableParameters,
}
impl ::std::convert::From<&GenesisAlonzo> for GenesisAlonzo {
    fn from(value: &GenesisAlonzo) -> Self {
        value.clone()
    }
}
#[doc = "GenesisAlonzoEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"alonzo\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GenesisAlonzoEra {
    #[serde(rename = "alonzo")]
    Alonzo,
}
impl ::std::convert::From<&Self> for GenesisAlonzoEra {
    fn from(value: &GenesisAlonzoEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GenesisAlonzoEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Alonzo => write!(f, "alonzo"),
        }
    }
}
impl ::std::str::FromStr for GenesisAlonzoEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "alonzo" => Ok(Self::Alonzo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GenesisAlonzoEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GenesisAlonzoEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GenesisAlonzoEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GenesisAlonzoUpdatableParameters"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"collateralPercentage\","]
#[doc = "    \"maxCollateralInputs\","]
#[doc = "    \"maxExecutionUnitsPerBlock\","]
#[doc = "    \"maxExecutionUnitsPerTransaction\","]
#[doc = "    \"maxValueSize\","]
#[doc = "    \"minUtxoDepositCoefficient\","]
#[doc = "    \"plutusCostModels\","]
#[doc = "    \"scriptExecutionPrices\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"collateralPercentage\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"maxCollateralInputs\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerBlock\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerTransaction\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxValueSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"minUtxoDepositCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"plutusCostModels\": {"]
#[doc = "      \"$ref\": \"#/definitions/CostModels\""]
#[doc = "    },"]
#[doc = "    \"scriptExecutionPrices\": {"]
#[doc = "      \"$ref\": \"#/definitions/ScriptExecutionPrices\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisAlonzoUpdatableParameters {
    #[serde(rename = "collateralPercentage")]
    pub collateral_percentage: UInt64,
    #[serde(rename = "maxCollateralInputs")]
    pub max_collateral_inputs: UInt64,
    #[serde(rename = "maxExecutionUnitsPerBlock")]
    pub max_execution_units_per_block: ExecutionUnits,
    #[serde(rename = "maxExecutionUnitsPerTransaction")]
    pub max_execution_units_per_transaction: ExecutionUnits,
    #[serde(rename = "maxValueSize")]
    pub max_value_size: NumberOfBytes,
    #[serde(rename = "minUtxoDepositCoefficient")]
    pub min_utxo_deposit_coefficient: UInt64,
    #[serde(rename = "plutusCostModels")]
    pub plutus_cost_models: CostModels,
    #[serde(rename = "scriptExecutionPrices")]
    pub script_execution_prices: ScriptExecutionPrices,
}
impl ::std::convert::From<&GenesisAlonzoUpdatableParameters> for GenesisAlonzoUpdatableParameters {
    fn from(value: &GenesisAlonzoUpdatableParameters) -> Self {
        value.clone()
    }
}
#[doc = "A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Genesis<Byron>\","]
#[doc = "  \"description\": \"A Byron genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"era\","]
#[doc = "    \"genesisDelegations\","]
#[doc = "    \"genesisKeyHashes\","]
#[doc = "    \"initialFunds\","]
#[doc = "    \"initialVouchers\","]
#[doc = "    \"networkMagic\","]
#[doc = "    \"protocolParameters\","]
#[doc = "    \"securityParameter\","]
#[doc = "    \"startTime\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"byron\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"genesisDelegations\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/BootstrapOperationalCertificate\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"genesisKeyHashes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"initialFunds\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/Address\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"initialVouchers\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"networkMagic\": {"]
#[doc = "      \"$ref\": \"#/definitions/NetworkMagic\""]
#[doc = "    },"]
#[doc = "    \"securityParameter\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"startTime\": {"]
#[doc = "      \"$ref\": \"#/definitions/UtcTime\""]
#[doc = "    },"]
#[doc = "    \"updatableParameters\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolParameters\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisByron {
    pub era: GenesisByronEra,
    #[serde(rename = "genesisDelegations")]
    pub genesis_delegations:
        ::std::collections::HashMap<DigestBlake2b224, BootstrapOperationalCertificate>,
    #[serde(rename = "genesisKeyHashes")]
    pub genesis_key_hashes: ::std::vec::Vec<DigestBlake2b224>,
    #[serde(rename = "initialFunds")]
    pub initial_funds: ::std::collections::HashMap<Address, ValueAdaOnly>,
    #[serde(rename = "initialVouchers")]
    pub initial_vouchers: ::std::collections::HashMap<VerificationKey, ValueAdaOnly>,
    #[serde(rename = "networkMagic")]
    pub network_magic: NetworkMagic,
    #[serde(rename = "protocolParameters")]
    pub protocol_parameters: ::serde_json::Value,
    #[serde(rename = "securityParameter")]
    pub security_parameter: UInt64,
    #[serde(rename = "startTime")]
    pub start_time: UtcTime,
    #[serde(
        rename = "updatableParameters",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub updatable_parameters: ::std::option::Option<ProtocolParameters>,
}
impl ::std::convert::From<&GenesisByron> for GenesisByron {
    fn from(value: &GenesisByron) -> Self {
        value.clone()
    }
}
#[doc = "GenesisByronEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"byron\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GenesisByronEra {
    #[serde(rename = "byron")]
    Byron,
}
impl ::std::convert::From<&Self> for GenesisByronEra {
    fn from(value: &GenesisByronEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GenesisByronEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Byron => write!(f, "byron"),
        }
    }
}
impl ::std::str::FromStr for GenesisByronEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "byron" => Ok(Self::Byron),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GenesisByronEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GenesisByronEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GenesisByronEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "An Conway genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Genesis<Conway>\","]
#[doc = "  \"description\": \"An Conway genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"constitution\","]
#[doc = "    \"constitutionalCommittee\","]
#[doc = "    \"era\","]
#[doc = "    \"updatableParameters\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"constitution\": {"]
#[doc = "      \"$ref\": \"#/definitions/Constitution\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommittee\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"members\","]
#[doc = "        \"quorum\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"members\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/ConstitutionalCommitteeMemberSummary\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"quorum\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"conway\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"updatableParameters\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"constitutionalCommitteeMaxTermLength\","]
#[doc = "        \"constitutionalCommitteeMinSize\","]
#[doc = "        \"delegateRepresentativeDeposit\","]
#[doc = "        \"delegateRepresentativeMaxIdleTime\","]
#[doc = "        \"delegateRepresentativeVotingThresholds\","]
#[doc = "        \"governanceActionDeposit\","]
#[doc = "        \"governanceActionLifetime\","]
#[doc = "        \"stakePoolVotingThresholds\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"constitutionalCommitteeMaxTermLength\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"constitutionalCommitteeMinSize\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"delegateRepresentativeDeposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"delegateRepresentativeMaxIdleTime\": {"]
#[doc = "          \"$ref\": \"#/definitions/Epoch\""]
#[doc = "        },"]
#[doc = "        \"delegateRepresentativeVotingThresholds\": {"]
#[doc = "          \"$ref\": \"#/definitions/DelegateRepresentativeVotingThresholds\""]
#[doc = "        },"]
#[doc = "        \"governanceActionDeposit\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"governanceActionLifetime\": {"]
#[doc = "          \"$ref\": \"#/definitions/Epoch\""]
#[doc = "        },"]
#[doc = "        \"stakePoolVotingThresholds\": {"]
#[doc = "          \"$ref\": \"#/definitions/StakePoolVotingThresholds\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisConway {
    pub constitution: Constitution,
    #[serde(rename = "constitutionalCommittee")]
    pub constitutional_committee: GenesisConwayConstitutionalCommittee,
    pub era: GenesisConwayEra,
    #[serde(rename = "updatableParameters")]
    pub updatable_parameters: GenesisConwayUpdatableParameters,
}
impl ::std::convert::From<&GenesisConway> for GenesisConway {
    fn from(value: &GenesisConway) -> Self {
        value.clone()
    }
}
#[doc = "GenesisConwayConstitutionalCommittee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"members\","]
#[doc = "    \"quorum\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ConstitutionalCommitteeMemberSummary\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"quorum\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisConwayConstitutionalCommittee {
    pub members: ::std::vec::Vec<ConstitutionalCommitteeMemberSummary>,
    pub quorum: Ratio,
}
impl ::std::convert::From<&GenesisConwayConstitutionalCommittee>
    for GenesisConwayConstitutionalCommittee
{
    fn from(value: &GenesisConwayConstitutionalCommittee) -> Self {
        value.clone()
    }
}
#[doc = "GenesisConwayEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"conway\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GenesisConwayEra {
    #[serde(rename = "conway")]
    Conway,
}
impl ::std::convert::From<&Self> for GenesisConwayEra {
    fn from(value: &GenesisConwayEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GenesisConwayEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Conway => write!(f, "conway"),
        }
    }
}
impl ::std::str::FromStr for GenesisConwayEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "conway" => Ok(Self::Conway),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GenesisConwayEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GenesisConwayEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GenesisConwayEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GenesisConwayUpdatableParameters"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"constitutionalCommitteeMaxTermLength\","]
#[doc = "    \"constitutionalCommitteeMinSize\","]
#[doc = "    \"delegateRepresentativeDeposit\","]
#[doc = "    \"delegateRepresentativeMaxIdleTime\","]
#[doc = "    \"delegateRepresentativeVotingThresholds\","]
#[doc = "    \"governanceActionDeposit\","]
#[doc = "    \"governanceActionLifetime\","]
#[doc = "    \"stakePoolVotingThresholds\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"constitutionalCommitteeMaxTermLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommitteeMinSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeMaxIdleTime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/DelegateRepresentativeVotingThresholds\""]
#[doc = "    },"]
#[doc = "    \"governanceActionDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"governanceActionLifetime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"stakePoolVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolVotingThresholds\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisConwayUpdatableParameters {
    #[serde(rename = "constitutionalCommitteeMaxTermLength")]
    pub constitutional_committee_max_term_length: UInt64,
    #[serde(rename = "constitutionalCommitteeMinSize")]
    pub constitutional_committee_min_size: UInt64,
    #[serde(rename = "delegateRepresentativeDeposit")]
    pub delegate_representative_deposit: ValueAdaOnly,
    #[serde(rename = "delegateRepresentativeMaxIdleTime")]
    pub delegate_representative_max_idle_time: Epoch,
    #[serde(rename = "delegateRepresentativeVotingThresholds")]
    pub delegate_representative_voting_thresholds: DelegateRepresentativeVotingThresholds,
    #[serde(rename = "governanceActionDeposit")]
    pub governance_action_deposit: ValueAdaOnly,
    #[serde(rename = "governanceActionLifetime")]
    pub governance_action_lifetime: Epoch,
    #[serde(rename = "stakePoolVotingThresholds")]
    pub stake_pool_voting_thresholds: StakePoolVotingThresholds,
}
impl ::std::convert::From<&GenesisConwayUpdatableParameters> for GenesisConwayUpdatableParameters {
    fn from(value: &GenesisConwayUpdatableParameters) -> Self {
        value.clone()
    }
}
#[doc = "A Genesis delegate, in charge of Cardano's governance."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GenesisDelegate\","]
#[doc = "  \"description\": \"A Genesis delegate, in charge of Cardano's governance.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"vrfVerificationKeyHash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    },"]
#[doc = "    \"vrfVerificationKeyHash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisDelegate {
    pub id: DigestBlake2b224,
    #[serde(rename = "vrfVerificationKeyHash")]
    pub vrf_verification_key_hash: DigestBlake2b256,
}
impl ::std::convert::From<&GenesisDelegate> for GenesisDelegate {
    fn from(value: &GenesisDelegate) -> Self {
        value.clone()
    }
}
#[doc = "GenesisHash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GenesisHash\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"genesis\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GenesisHash {
    #[serde(rename = "genesis")]
    Genesis,
}
impl ::std::convert::From<&Self> for GenesisHash {
    fn from(value: &GenesisHash) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GenesisHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Genesis => write!(f, "genesis"),
        }
    }
}
impl ::std::str::FromStr for GenesisHash {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "genesis" => Ok(Self::Genesis),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GenesisHash {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GenesisHash {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GenesisHash {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Genesis<Shelley>\","]
#[doc = "  \"description\": \"A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"activeSlotsCoefficient\","]
#[doc = "    \"epochLength\","]
#[doc = "    \"era\","]
#[doc = "    \"initialDelegates\","]
#[doc = "    \"initialFunds\","]
#[doc = "    \"initialParameters\","]
#[doc = "    \"initialStakePools\","]
#[doc = "    \"maxKesEvolutions\","]
#[doc = "    \"maxLovelaceSupply\","]
#[doc = "    \"network\","]
#[doc = "    \"networkMagic\","]
#[doc = "    \"securityParameter\","]
#[doc = "    \"slotLength\","]
#[doc = "    \"slotsPerKesPeriod\","]
#[doc = "    \"startTime\","]
#[doc = "    \"updateQuorum\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"activeSlotsCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"epochLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"era\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"shelley\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"initialDelegates\": {"]
#[doc = "      \"$ref\": \"#/definitions/InitialDelegates\""]
#[doc = "    },"]
#[doc = "    \"initialFunds\": {"]
#[doc = "      \"title\": \"InitialFunds\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/Address\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"initialParameters\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolParameters\""]
#[doc = "    },"]
#[doc = "    \"initialStakePools\": {"]
#[doc = "      \"$ref\": \"#/definitions/GenesisStakePools\""]
#[doc = "    },"]
#[doc = "    \"maxKesEvolutions\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"maxLovelaceSupply\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"network\": {"]
#[doc = "      \"$ref\": \"#/definitions/Network\""]
#[doc = "    },"]
#[doc = "    \"networkMagic\": {"]
#[doc = "      \"$ref\": \"#/definitions/NetworkMagic\""]
#[doc = "    },"]
#[doc = "    \"securityParameter\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"slotLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/SlotLength\""]
#[doc = "    },"]
#[doc = "    \"slotsPerKesPeriod\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"startTime\": {"]
#[doc = "      \"$ref\": \"#/definitions/UtcTime\""]
#[doc = "    },"]
#[doc = "    \"updateQuorum\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisShelley {
    #[serde(rename = "activeSlotsCoefficient")]
    pub active_slots_coefficient: Ratio,
    #[serde(rename = "epochLength")]
    pub epoch_length: Epoch,
    pub era: GenesisShelleyEra,
    #[serde(rename = "initialDelegates")]
    pub initial_delegates: InitialDelegates,
    #[serde(rename = "initialFunds")]
    pub initial_funds: ::std::collections::HashMap<Address, ValueAdaOnly>,
    #[serde(rename = "initialParameters")]
    pub initial_parameters: ProtocolParameters,
    #[serde(rename = "initialStakePools")]
    pub initial_stake_pools: GenesisStakePools,
    #[serde(rename = "maxKesEvolutions")]
    pub max_kes_evolutions: UInt64,
    #[serde(rename = "maxLovelaceSupply")]
    pub max_lovelace_supply: UInt64,
    pub network: Network,
    #[serde(rename = "networkMagic")]
    pub network_magic: NetworkMagic,
    #[serde(rename = "securityParameter")]
    pub security_parameter: UInt64,
    #[serde(rename = "slotLength")]
    pub slot_length: SlotLength,
    #[serde(rename = "slotsPerKesPeriod")]
    pub slots_per_kes_period: UInt64,
    #[serde(rename = "startTime")]
    pub start_time: UtcTime,
    #[serde(rename = "updateQuorum")]
    pub update_quorum: UInt64,
}
impl ::std::convert::From<&GenesisShelley> for GenesisShelley {
    fn from(value: &GenesisShelley) -> Self {
        value.clone()
    }
}
#[doc = "GenesisShelleyEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"shelley\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GenesisShelleyEra {
    #[serde(rename = "shelley")]
    Shelley,
}
impl ::std::convert::From<&Self> for GenesisShelleyEra {
    fn from(value: &GenesisShelleyEra) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GenesisShelleyEra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Shelley => write!(f, "shelley"),
        }
    }
}
impl ::std::str::FromStr for GenesisShelleyEra {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "shelley" => Ok(Self::Shelley),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GenesisShelleyEra {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GenesisShelleyEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GenesisShelleyEra {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A Genesis stake pools configuration; primarily used for bootstrapping test networks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GenesisStakePools\","]
#[doc = "  \"description\": \"A Genesis stake pools configuration; primarily used for bootstrapping test networks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegators\","]
#[doc = "    \"stakePools\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegators\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"stakePools\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/StakePool\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GenesisStakePools {
    pub delegators: ::std::collections::HashMap<DigestBlake2b224, StakePoolId>,
    #[serde(rename = "stakePools")]
    pub stake_pools: ::std::collections::HashMap<StakePoolId, StakePool>,
}
impl ::std::convert::From<&GenesisStakePools> for GenesisStakePools {
    fn from(value: &GenesisStakePools) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceAction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<ProtocolParametersUpdate>\","]
#[doc = "      \"description\": \"The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"guardrails\","]
#[doc = "        \"parameters\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ancestor\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "        },"]
#[doc = "        \"guardrails\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"parameters\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProposedProtocolParameters\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"protocolParametersUpdate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<HardForkInitiation>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ancestor\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"hardForkInitiation\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<TreasuryTransfer>\","]
#[doc = "      \"description\": \"A transfer from or to the treasury / reserves authored by genesis delegates.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"source\","]
#[doc = "        \"target\","]
#[doc = "        \"type\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"source\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"reserves\","]
#[doc = "            \"treasury\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"target\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"reserves\","]
#[doc = "            \"treasury\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"treasuryTransfer\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<TreasuryWithdrawals>\","]
#[doc = "      \"description\": \"One of more withdrawals from the treasury.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"guardrails\","]
#[doc = "        \"type\","]
#[doc = "        \"withdrawals\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"guardrails\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"treasuryWithdrawals\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"withdrawals\": {"]
#[doc = "          \"$ref\": \"#/definitions/RewardTransfer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<ConstitutionalCommittee>\","]
#[doc = "      \"description\": \"A change (partial or total) in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group (also includes no confidence actions in this case). It is optional for the first one and required after so that they all actions of a same group form a chain.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"members\","]
#[doc = "        \"quorum\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ancestor\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "        },"]
#[doc = "        \"members\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"added\","]
#[doc = "            \"removed\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"added\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/ConstitutionalCommitteeMemberSummary\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"removed\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"from\","]
#[doc = "                  \"id\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"from\": {"]
#[doc = "                    \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "                  },"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"quorum\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"constitutionalCommittee\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<Constitution>\","]
#[doc = "      \"description\": \"A change in the constitution. Only its hash is recorded on-chain. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"guardrails\","]
#[doc = "        \"metadata\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ancestor\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "        },"]
#[doc = "        \"guardrails\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"$ref\": \"#/definitions/Anchor\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"constitution\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<NoConfidence>\","]
#[doc = "      \"description\": \"A motion of no-confidence, indicate a lack of trust in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ancestor\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"noConfidence\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceAction<Information>\","]
#[doc = "      \"description\": \"An action that has no effect on-chain, other than an on-chain record\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"information\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", deny_unknown_fields)]
pub enum GovernanceAction {
    #[doc = "GovernanceAction<ProtocolParametersUpdate>\n\nThe 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain."]
    #[serde(rename = "protocolParametersUpdate")]
    ProtocolParametersUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ancestor: ::std::option::Option<GovernanceProposalReference>,
        guardrails: GovernanceActionGuardrails,
        parameters: ProposedProtocolParameters,
    },
    #[doc = "GovernanceAction<HardForkInitiation>"]
    #[serde(rename = "hardForkInitiation")]
    HardForkInitiation {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ancestor: ::std::option::Option<GovernanceProposalReference>,
        version: ProtocolVersion,
    },
    #[doc = "GovernanceAction<TreasuryTransfer>\n\nA transfer from or to the treasury / reserves authored by genesis delegates."]
    #[serde(rename = "treasuryTransfer")]
    TreasuryTransfer {
        source: GovernanceActionSource,
        target: GovernanceActionTarget,
        value: ValueAdaOnly,
    },
    #[doc = "GovernanceAction<TreasuryWithdrawals>\n\nOne of more withdrawals from the treasury."]
    #[serde(rename = "treasuryWithdrawals")]
    TreasuryWithdrawals {
        guardrails: GovernanceActionGuardrails,
        withdrawals: RewardTransfer,
    },
    #[doc = "GovernanceAction<ConstitutionalCommittee>\n\nA change (partial or total) in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group (also includes no confidence actions in this case). It is optional for the first one and required after so that they all actions of a same group form a chain."]
    #[serde(rename = "constitutionalCommittee")]
    ConstitutionalCommittee {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ancestor: ::std::option::Option<GovernanceProposalReference>,
        members: GovernanceActionMembers,
        quorum: Ratio,
    },
    #[doc = "GovernanceAction<Constitution>\n\nA change in the constitution. Only its hash is recorded on-chain. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain."]
    #[serde(rename = "constitution")]
    Constitution {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ancestor: ::std::option::Option<GovernanceProposalReference>,
        guardrails: GovernanceActionGuardrails,
        metadata: Anchor,
    },
    #[doc = "GovernanceAction<NoConfidence>\n\nA motion of no-confidence, indicate a lack of trust in the constitutional committee. The 'ancestor' is a reference to the previous governance action of this group. It is optional for the first one and required after so that they all actions of a same group form a chain."]
    #[serde(rename = "noConfidence")]
    NoConfidence {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ancestor: ::std::option::Option<GovernanceProposalReference>,
    },
    #[serde(rename = "information")]
    Information,
}
impl ::std::convert::From<&Self> for GovernanceAction {
    fn from(value: &GovernanceAction) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceActionGuardrails"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum GovernanceActionGuardrails {
    Variant0(Null),
    Variant1 { hash: DigestBlake2b224 },
}
impl ::std::convert::From<&Self> for GovernanceActionGuardrails {
    fn from(value: &GovernanceActionGuardrails) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Null> for GovernanceActionGuardrails {
    fn from(value: Null) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "GovernanceActionMembers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"added\","]
#[doc = "    \"removed\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"added\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ConstitutionalCommitteeMemberSummary\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"removed\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"from\","]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"from\": {"]
#[doc = "            \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceActionMembers {
    pub added: ::std::vec::Vec<ConstitutionalCommitteeMemberSummary>,
    pub removed: ::std::vec::Vec<GovernanceActionMembersRemovedItem>,
}
impl ::std::convert::From<&GovernanceActionMembers> for GovernanceActionMembers {
    fn from(value: &GovernanceActionMembers) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceActionMembersRemovedItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceActionMembersRemovedItem {
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
}
impl ::std::convert::From<&GovernanceActionMembersRemovedItem>
    for GovernanceActionMembersRemovedItem
{
    fn from(value: &GovernanceActionMembersRemovedItem) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceActionSource"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reserves\","]
#[doc = "    \"treasury\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GovernanceActionSource {
    #[serde(rename = "reserves")]
    Reserves,
    #[serde(rename = "treasury")]
    Treasury,
}
impl ::std::convert::From<&Self> for GovernanceActionSource {
    fn from(value: &GovernanceActionSource) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GovernanceActionSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reserves => write!(f, "reserves"),
            Self::Treasury => write!(f, "treasury"),
        }
    }
}
impl ::std::str::FromStr for GovernanceActionSource {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reserves" => Ok(Self::Reserves),
            "treasury" => Ok(Self::Treasury),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GovernanceActionSource {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GovernanceActionSource {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GovernanceActionSource {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GovernanceActionTarget"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"reserves\","]
#[doc = "    \"treasury\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GovernanceActionTarget {
    #[serde(rename = "reserves")]
    Reserves,
    #[serde(rename = "treasury")]
    Treasury,
}
impl ::std::convert::From<&Self> for GovernanceActionTarget {
    fn from(value: &GovernanceActionTarget) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GovernanceActionTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Reserves => write!(f, "reserves"),
            Self::Treasury => write!(f, "treasury"),
        }
    }
}
impl ::std::str::FromStr for GovernanceActionTarget {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "reserves" => Ok(Self::Reserves),
            "treasury" => Ok(Self::Treasury),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GovernanceActionTarget {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GovernanceActionTarget {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GovernanceActionTarget {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GovernanceProposal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GovernanceProposal\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceAction\""]
#[doc = "    },"]
#[doc = "    \"deposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    },"]
#[doc = "    \"returnAccount\": {"]
#[doc = "      \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposal {
    pub action: GovernanceAction,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<Anchor>,
    #[serde(
        rename = "returnAccount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub return_account: ::std::option::Option<RewardAccount>,
}
impl ::std::convert::From<&GovernanceProposal> for GovernanceProposal {
    fn from(value: &GovernanceProposal) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceProposalReference"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GovernanceProposalReference\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"index\","]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"index\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposalReference {
    pub index: UInt32,
    pub transaction: GovernanceProposalReferenceTransaction,
}
impl ::std::convert::From<&GovernanceProposalReference> for GovernanceProposalReference {
    fn from(value: &GovernanceProposalReference) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceProposalReferenceTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposalReferenceTransaction {
    pub id: TransactionId,
}
impl ::std::convert::From<&GovernanceProposalReferenceTransaction>
    for GovernanceProposalReferenceTransaction
{
    fn from(value: &GovernanceProposalReferenceTransaction) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceProposalState"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GovernanceProposalState\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action\","]
#[doc = "    \"deposit\","]
#[doc = "    \"metadata\","]
#[doc = "    \"proposal\","]
#[doc = "    \"returnAccount\","]
#[doc = "    \"since\","]
#[doc = "    \"until\","]
#[doc = "    \"votes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceAction\""]
#[doc = "    },"]
#[doc = "    \"deposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    },"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "    },"]
#[doc = "    \"returnAccount\": {"]
#[doc = "      \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "    },"]
#[doc = "    \"since\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"epoch\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"epoch\": {"]
#[doc = "          \"$ref\": \"#/definitions/Epoch\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"until\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"epoch\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"epoch\": {"]
#[doc = "          \"$ref\": \"#/definitions/Epoch\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"votes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GovernanceVote\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposalState {
    pub action: GovernanceAction,
    pub deposit: ValueAdaOnly,
    pub metadata: Anchor,
    pub proposal: GovernanceProposalReference,
    #[serde(rename = "returnAccount")]
    pub return_account: RewardAccount,
    pub since: GovernanceProposalStateSince,
    pub until: GovernanceProposalStateUntil,
    pub votes: ::std::vec::Vec<GovernanceVote>,
}
impl ::std::convert::From<&GovernanceProposalState> for GovernanceProposalState {
    fn from(value: &GovernanceProposalState) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceProposalStateSince"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epoch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"epoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposalStateSince {
    pub epoch: Epoch,
}
impl ::std::convert::From<&GovernanceProposalStateSince> for GovernanceProposalStateSince {
    fn from(value: &GovernanceProposalStateSince) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceProposalStateUntil"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epoch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"epoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceProposalStateUntil {
    pub epoch: Epoch,
}
impl ::std::convert::From<&GovernanceProposalStateUntil> for GovernanceProposalStateUntil {
    fn from(value: &GovernanceProposalStateUntil) -> Self {
        value.clone()
    }
}
#[doc = "A vote on a governance proposal. The 'anchor' is optional and 'proposal' is only present from Conway onwards. Before Conway, a vote would always refer to all proposals part of the same transaction."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GovernanceVote\","]
#[doc = "  \"description\": \"A vote on a governance proposal. The 'anchor' is optional and 'proposal' is only present from Conway onwards. Before Conway, a vote would always refer to all proposals part of the same transaction.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"issuer\","]
#[doc = "    \"vote\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"issuer\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    },"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "    },"]
#[doc = "    \"vote\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"yes\","]
#[doc = "        \"no\","]
#[doc = "        \"abstain\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GovernanceVote {
    pub issuer: GovernanceVoter,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<Anchor>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub proposal: ::std::option::Option<GovernanceProposalReference>,
    pub vote: GovernanceVoteVote,
}
impl ::std::convert::From<&GovernanceVote> for GovernanceVote {
    fn from(value: &GovernanceVote) -> Self {
        value.clone()
    }
}
#[doc = "GovernanceVoteVote"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"yes\","]
#[doc = "    \"no\","]
#[doc = "    \"abstain\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GovernanceVoteVote {
    #[serde(rename = "yes")]
    Yes,
    #[serde(rename = "no")]
    No,
    #[serde(rename = "abstain")]
    Abstain,
}
impl ::std::convert::From<&Self> for GovernanceVoteVote {
    fn from(value: &GovernanceVoteVote) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GovernanceVoteVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Yes => write!(f, "yes"),
            Self::No => write!(f, "no"),
            Self::Abstain => write!(f, "abstain"),
        }
    }
}
impl ::std::str::FromStr for GovernanceVoteVote {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "yes" => Ok(Self::Yes),
            "no" => Ok(Self::No),
            "abstain" => Ok(Self::Abstain),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GovernanceVoteVote {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GovernanceVoteVote {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GovernanceVoteVote {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GovernanceVoter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Voter<GenesisDelegate>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"role\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"role\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"genesisDelegate\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Voter<ConstitutionalCommittee>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"role\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"role\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"constitutionalCommittee\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Voter<DelegateRepresentative>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\","]
#[doc = "        \"role\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        },"]
#[doc = "        \"role\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"delegateRepresentative\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Voter<StakePoolOperator>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"role\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "        },"]
#[doc = "        \"role\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakePoolOperator\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "role", deny_unknown_fields)]
pub enum GovernanceVoter {
    #[doc = "Voter<GenesisDelegate>"]
    #[serde(rename = "genesisDelegate")]
    GenesisDelegate {
        from: CredentialOrigin,
        id: DigestBlake2b224,
    },
    #[doc = "Voter<ConstitutionalCommittee>"]
    #[serde(rename = "constitutionalCommittee")]
    ConstitutionalCommittee {
        from: CredentialOrigin,
        id: DigestBlake2b224,
    },
    #[doc = "Voter<DelegateRepresentative>"]
    #[serde(rename = "delegateRepresentative")]
    DelegateRepresentative {
        from: CredentialOrigin,
        id: DigestBlake2b224,
    },
    #[doc = "Voter<StakePoolOperator>"]
    #[serde(rename = "stakePoolOperator")]
    StakePoolOperator { id: StakePoolId },
}
impl ::std::convert::From<&Self> for GovernanceVoter {
    fn from(value: &GovernanceVoter) -> Self {
        value.clone()
    }
}
#[doc = "Ask whether a given transaction is present in the acquired mempool snapshot."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"HasTransaction\","]
#[doc = "  \"description\": \"Ask whether a given transaction is present in the acquired mempool snapshot.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"hasTransaction\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct HasTransaction {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: HasTransactionJsonrpc,
    pub method: HasTransactionMethod,
    pub params: HasTransactionParams,
}
impl ::std::convert::From<&HasTransaction> for HasTransaction {
    fn from(value: &HasTransaction) -> Self {
        value.clone()
    }
}
#[doc = "HasTransactionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HasTransactionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for HasTransactionJsonrpc {
    fn from(value: &HasTransactionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HasTransactionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for HasTransactionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HasTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HasTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HasTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "HasTransactionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"hasTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HasTransactionMethod {
    #[serde(rename = "hasTransaction")]
    HasTransaction,
}
impl ::std::convert::From<&Self> for HasTransactionMethod {
    fn from(value: &HasTransactionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HasTransactionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::HasTransaction => write!(f, "hasTransaction"),
        }
    }
}
impl ::std::str::FromStr for HasTransactionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "hasTransaction" => Ok(Self::HasTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HasTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HasTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HasTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "HasTransactionParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct HasTransactionParams {
    pub id: TransactionId,
}
impl ::std::convert::From<&HasTransactionParams> for HasTransactionParams {
    fn from(value: &HasTransactionParams) -> Self {
        value.clone()
    }
}
#[doc = "HasTransactionResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HasTransactionResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for HasTransactionResponseJsonrpc {
    fn from(value: &HasTransactionResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HasTransactionResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for HasTransactionResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HasTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HasTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HasTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "HasTransactionResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"hasTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HasTransactionResponseMethod {
    #[serde(rename = "hasTransaction")]
    HasTransaction,
}
impl ::std::convert::From<&Self> for HasTransactionResponseMethod {
    fn from(value: &HasTransactionResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HasTransactionResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::HasTransaction => write!(f, "hasTransaction"),
        }
    }
}
impl ::std::str::FromStr for HasTransactionResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "hasTransaction" => Ok(Self::HasTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HasTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HasTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HasTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "InitialDelegates"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"InitialDelegates\","]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"delegate\","]
#[doc = "      \"issuer\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"delegate\": {"]
#[doc = "        \"$ref\": \"#/definitions/GenesisDelegate\""]
#[doc = "      },"]
#[doc = "      \"issuer\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct InitialDelegates(pub ::std::vec::Vec<InitialDelegatesItem>);
impl ::std::ops::Deref for InitialDelegates {
    type Target = ::std::vec::Vec<InitialDelegatesItem>;
    fn deref(&self) -> &::std::vec::Vec<InitialDelegatesItem> {
        &self.0
    }
}
impl ::std::convert::From<InitialDelegates> for ::std::vec::Vec<InitialDelegatesItem> {
    fn from(value: InitialDelegates) -> Self {
        value.0
    }
}
impl ::std::convert::From<&InitialDelegates> for InitialDelegates {
    fn from(value: &InitialDelegates) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<InitialDelegatesItem>> for InitialDelegates {
    fn from(value: ::std::vec::Vec<InitialDelegatesItem>) -> Self {
        Self(value)
    }
}
#[doc = "InitialDelegatesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegate\","]
#[doc = "    \"issuer\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegate\": {"]
#[doc = "      \"$ref\": \"#/definitions/GenesisDelegate\""]
#[doc = "    },"]
#[doc = "    \"issuer\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InitialDelegatesItem {
    pub delegate: GenesisDelegate,
    pub issuer: InitialDelegatesItemIssuer,
}
impl ::std::convert::From<&InitialDelegatesItem> for InitialDelegatesItem {
    fn from(value: &InitialDelegatesItem) -> Self {
        value.clone()
    }
}
#[doc = "InitialDelegatesItemIssuer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct InitialDelegatesItemIssuer {
    pub id: DigestBlake2b224,
}
impl ::std::convert::From<&InitialDelegatesItemIssuer> for InitialDelegatesItemIssuer {
    fn from(value: &InitialDelegatesItemIssuer) -> Self {
        value.clone()
    }
}
#[doc = "InputSource"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"inputs\","]
#[doc = "    \"collaterals\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum InputSource {
    #[serde(rename = "inputs")]
    Inputs,
    #[serde(rename = "collaterals")]
    Collaterals,
}
impl ::std::convert::From<&Self> for InputSource {
    fn from(value: &InputSource) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for InputSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Inputs => write!(f, "inputs"),
            Self::Collaterals => write!(f, "collaterals"),
        }
    }
}
impl ::std::str::FromStr for InputSource {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "inputs" => Ok(Self::Inputs),
            "collaterals" => Ok(Self::Collaterals),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for InputSource {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for InputSource {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for InputSource {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Int64"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Int64\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 9.223372036854776e18,"]
#[doc = "  \"minimum\": -9.223372036854776e18"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Int64(pub i64);
impl ::std::ops::Deref for Int64 {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<Int64> for i64 {
    fn from(value: Int64) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Int64> for Int64 {
    fn from(value: &Int64) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for Int64 {
    fn from(value: i64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Int64 {
    type Err = <i64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for Int64 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for Int64 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for Int64 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for Int64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "IntersectionFoundJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionFoundJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for IntersectionFoundJsonrpc {
    fn from(value: &IntersectionFoundJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionFoundJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for IntersectionFoundJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IntersectionFoundMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"findIntersection\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionFoundMethod {
    #[serde(rename = "findIntersection")]
    FindIntersection,
}
impl ::std::convert::From<&Self> for IntersectionFoundMethod {
    fn from(value: &IntersectionFoundMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionFoundMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FindIntersection => write!(f, "findIntersection"),
        }
    }
}
impl ::std::str::FromStr for IntersectionFoundMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "findIntersection" => Ok(Self::FindIntersection),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IntersectionFoundResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"intersection\","]
#[doc = "    \"tip\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"intersection\": {"]
#[doc = "      \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "    },"]
#[doc = "    \"tip\": {"]
#[doc = "      \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IntersectionFoundResult {
    pub intersection: PointOrOrigin,
    pub tip: TipOrOrigin,
}
impl ::std::convert::From<&IntersectionFoundResult> for IntersectionFoundResult {
    fn from(value: &IntersectionFoundResult) -> Self {
        value.clone()
    }
}
#[doc = "An internal error indicating that requests were interleaved in an unexpected way. Shouldn't ever happen."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An internal error indicating that requests were interleaved in an unexpected way. Shouldn't ever happen.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        1001"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IntersectionInterleavedError {
    pub code: IntersectionInterleavedErrorCode,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&IntersectionInterleavedError> for IntersectionInterleavedError {
    fn from(value: &IntersectionInterleavedError) -> Self {
        value.clone()
    }
}
#[doc = "IntersectionInterleavedErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    1001"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct IntersectionInterleavedErrorCode(i64);
impl ::std::ops::Deref for IntersectionInterleavedErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<IntersectionInterleavedErrorCode> for i64 {
    fn from(value: IntersectionInterleavedErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&IntersectionInterleavedErrorCode> for IntersectionInterleavedErrorCode {
    fn from(value: &IntersectionInterleavedErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for IntersectionInterleavedErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![1001_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for IntersectionInterleavedErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "IntersectionInterleavedJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionInterleavedJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for IntersectionInterleavedJsonrpc {
    fn from(value: &IntersectionInterleavedJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionInterleavedJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for IntersectionInterleavedJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionInterleavedJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionInterleavedJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionInterleavedJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IntersectionInterleavedMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"findIntersection\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionInterleavedMethod {
    #[serde(rename = "findIntersection")]
    FindIntersection,
}
impl ::std::convert::From<&Self> for IntersectionInterleavedMethod {
    fn from(value: &IntersectionInterleavedMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionInterleavedMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FindIntersection => write!(f, "findIntersection"),
        }
    }
}
impl ::std::str::FromStr for IntersectionInterleavedMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "findIntersection" => Ok(Self::FindIntersection),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionInterleavedMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionInterleavedMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionInterleavedMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "No intersection found with the requested points."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"No intersection found with the requested points.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        1000"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"tip\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"tip\": {"]
#[doc = "          \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IntersectionNotFoundError {
    pub code: IntersectionNotFoundErrorCode,
    pub data: IntersectionNotFoundErrorData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&IntersectionNotFoundError> for IntersectionNotFoundError {
    fn from(value: &IntersectionNotFoundError) -> Self {
        value.clone()
    }
}
#[doc = "IntersectionNotFoundErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    1000"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct IntersectionNotFoundErrorCode(i64);
impl ::std::ops::Deref for IntersectionNotFoundErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<IntersectionNotFoundErrorCode> for i64 {
    fn from(value: IntersectionNotFoundErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&IntersectionNotFoundErrorCode> for IntersectionNotFoundErrorCode {
    fn from(value: &IntersectionNotFoundErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for IntersectionNotFoundErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![1000_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for IntersectionNotFoundErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "IntersectionNotFoundErrorData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"tip\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"tip\": {"]
#[doc = "      \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IntersectionNotFoundErrorData {
    pub tip: TipOrOrigin,
}
impl ::std::convert::From<&IntersectionNotFoundErrorData> for IntersectionNotFoundErrorData {
    fn from(value: &IntersectionNotFoundErrorData) -> Self {
        value.clone()
    }
}
#[doc = "IntersectionNotFoundJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionNotFoundJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for IntersectionNotFoundJsonrpc {
    fn from(value: &IntersectionNotFoundJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionNotFoundJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for IntersectionNotFoundJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionNotFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionNotFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionNotFoundJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IntersectionNotFoundMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"findIntersection\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IntersectionNotFoundMethod {
    #[serde(rename = "findIntersection")]
    FindIntersection,
}
impl ::std::convert::From<&Self> for IntersectionNotFoundMethod {
    fn from(value: &IntersectionNotFoundMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IntersectionNotFoundMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FindIntersection => write!(f, "findIntersection"),
        }
    }
}
impl ::std::str::FromStr for IntersectionNotFoundMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "findIntersection" => Ok(Self::FindIntersection),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IntersectionNotFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IntersectionNotFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IntersectionNotFoundMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "KesVerificationKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"KesVerificationKey\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct KesVerificationKey(pub ::std::string::String);
impl ::std::ops::Deref for KesVerificationKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<KesVerificationKey> for ::std::string::String {
    fn from(value: KesVerificationKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&KesVerificationKey> for KesVerificationKey {
    fn from(value: &KesVerificationKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for KesVerificationKey {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for KesVerificationKey {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for KesVerificationKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Language"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Language\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"plutus:v1\","]
#[doc = "    \"plutus:v2\","]
#[doc = "    \"plutus:v3\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Language {
    #[serde(rename = "plutus:v1")]
    PlutusV1,
    #[serde(rename = "plutus:v2")]
    PlutusV2,
    #[serde(rename = "plutus:v3")]
    PlutusV3,
}
impl ::std::convert::From<&Self> for Language {
    fn from(value: &Language) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Language {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PlutusV1 => write!(f, "plutus:v1"),
            Self::PlutusV2 => write!(f, "plutus:v2"),
            Self::PlutusV3 => write!(f, "plutus:v3"),
        }
    }
}
impl ::std::str::FromStr for Language {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "plutus:v1" => Ok(Self::PlutusV1),
            "plutus:v2" => Ok(Self::PlutusV2),
            "plutus:v3" => Ok(Self::PlutusV3),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Language {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Language {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Language {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Distribution of stake across registered stake pools. Each key in the map corresponds to a pool id.\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"pool1qqqqpanw9zc0rzh0yp247nzf2s35uvnsm7aaesfl2nnejaev0uc\": {"]
#[doc = "        \"stake\": \"7072561631906/10793821269806117\","]
#[doc = "        \"vrf\": \"bb862fcc397de6c06dea9a9ad8442a3d17826e01799a79b861fc083341eaed3d\""]
#[doc = "      },"]
#[doc = "      \"pool1qqqqqdk4zhsjuxxd8jyvwncf5eucfskz0xjjj64fdmlgj735lr9\": {"]
#[doc = "        \"stake\": \"64666784451745/32381463809418351\","]
#[doc = "        \"vrf\": \"6de7605b2afd7e205318fc8b4329d26439b5b179b4746fea12f1ce50395f5d9e\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"stake\","]
#[doc = "      \"vrf\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"stake\": {"]
#[doc = "        \"$ref\": \"#/definitions/Ratio\""]
#[doc = "      },"]
#[doc = "      \"vrf\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct LiveStakeDistribution(
    pub ::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue>,
);
impl ::std::ops::Deref for LiveStakeDistribution {
    type Target = ::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue>;
    fn deref(&self) -> &::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue> {
        &self.0
    }
}
impl ::std::convert::From<LiveStakeDistribution>
    for ::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue>
{
    fn from(value: LiveStakeDistribution) -> Self {
        value.0
    }
}
impl ::std::convert::From<&LiveStakeDistribution> for LiveStakeDistribution {
    fn from(value: &LiveStakeDistribution) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue>>
    for LiveStakeDistribution
{
    fn from(value: ::std::collections::HashMap<StakePoolId, LiveStakeDistributionValue>) -> Self {
        Self(value)
    }
}
#[doc = "LiveStakeDistributionValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"stake\","]
#[doc = "    \"vrf\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"stake\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"vrf\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LiveStakeDistributionValue {
    pub stake: Ratio,
    pub vrf: DigestBlake2b256,
}
impl ::std::convert::From<&LiveStakeDistributionValue> for LiveStakeDistributionValue {
    fn from(value: &LiveStakeDistributionValue) -> Self {
        value.clone()
    }
}
#[doc = "Mandate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Mandate\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epoch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"epoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Mandate {
    pub epoch: Epoch,
}
impl ::std::convert::From<&Mandate> for Mandate {
    fn from(value: &Mandate) -> Self {
        value.clone()
    }
}
#[doc = "MempoolSizeAndCapacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"currentSize\","]
#[doc = "    \"maxCapacity\","]
#[doc = "    \"transactions\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"currentSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxCapacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"transactions\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"count\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt32\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MempoolSizeAndCapacity {
    #[serde(rename = "currentSize")]
    pub current_size: NumberOfBytes,
    #[serde(rename = "maxCapacity")]
    pub max_capacity: NumberOfBytes,
    pub transactions: MempoolSizeAndCapacityTransactions,
}
impl ::std::convert::From<&MempoolSizeAndCapacity> for MempoolSizeAndCapacity {
    fn from(value: &MempoolSizeAndCapacity) -> Self {
        value.clone()
    }
}
#[doc = "MempoolSizeAndCapacityTransactions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"count\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MempoolSizeAndCapacityTransactions {
    pub count: UInt32,
}
impl ::std::convert::From<&MempoolSizeAndCapacityTransactions>
    for MempoolSizeAndCapacityTransactions
{
    fn from(value: &MempoolSizeAndCapacityTransactions) -> Self {
        value.clone()
    }
}
#[doc = "MustAcquireMempoolFirst"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"MustAcquireMempoolFirst\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"Must acquire a mempool snapshot prior to performing any query.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            4000"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"hasTransaction\","]
#[doc = "        \"nextTransaction\","]
#[doc = "        \"sizeOfMempool\","]
#[doc = "        \"releaseMempool\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MustAcquireMempoolFirst {
    pub error: MustAcquireMempoolFirstError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: MustAcquireMempoolFirstJsonrpc,
    pub method: MustAcquireMempoolFirstMethod,
}
impl ::std::convert::From<&MustAcquireMempoolFirst> for MustAcquireMempoolFirst {
    fn from(value: &MustAcquireMempoolFirst) -> Self {
        value.clone()
    }
}
#[doc = "Must acquire a mempool snapshot prior to performing any query."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Must acquire a mempool snapshot prior to performing any query.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        4000"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct MustAcquireMempoolFirstError {
    pub code: MustAcquireMempoolFirstErrorCode,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&MustAcquireMempoolFirstError> for MustAcquireMempoolFirstError {
    fn from(value: &MustAcquireMempoolFirstError) -> Self {
        value.clone()
    }
}
#[doc = "MustAcquireMempoolFirstErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    4000"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct MustAcquireMempoolFirstErrorCode(i64);
impl ::std::ops::Deref for MustAcquireMempoolFirstErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<MustAcquireMempoolFirstErrorCode> for i64 {
    fn from(value: MustAcquireMempoolFirstErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&MustAcquireMempoolFirstErrorCode> for MustAcquireMempoolFirstErrorCode {
    fn from(value: &MustAcquireMempoolFirstErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for MustAcquireMempoolFirstErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![4000_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for MustAcquireMempoolFirstErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "MustAcquireMempoolFirstJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MustAcquireMempoolFirstJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for MustAcquireMempoolFirstJsonrpc {
    fn from(value: &MustAcquireMempoolFirstJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MustAcquireMempoolFirstJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for MustAcquireMempoolFirstJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MustAcquireMempoolFirstJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MustAcquireMempoolFirstJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MustAcquireMempoolFirstJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "MustAcquireMempoolFirstMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"hasTransaction\","]
#[doc = "    \"nextTransaction\","]
#[doc = "    \"sizeOfMempool\","]
#[doc = "    \"releaseMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MustAcquireMempoolFirstMethod {
    #[serde(rename = "hasTransaction")]
    HasTransaction,
    #[serde(rename = "nextTransaction")]
    NextTransaction,
    #[serde(rename = "sizeOfMempool")]
    SizeOfMempool,
    #[serde(rename = "releaseMempool")]
    ReleaseMempool,
}
impl ::std::convert::From<&Self> for MustAcquireMempoolFirstMethod {
    fn from(value: &MustAcquireMempoolFirstMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MustAcquireMempoolFirstMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::HasTransaction => write!(f, "hasTransaction"),
            Self::NextTransaction => write!(f, "nextTransaction"),
            Self::SizeOfMempool => write!(f, "sizeOfMempool"),
            Self::ReleaseMempool => write!(f, "releaseMempool"),
        }
    }
}
impl ::std::str::FromStr for MustAcquireMempoolFirstMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "hasTransaction" => Ok(Self::HasTransaction),
            "nextTransaction" => Ok(Self::NextTransaction),
            "sizeOfMempool" => Ok(Self::SizeOfMempool),
            "releaseMempool" => Ok(Self::ReleaseMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MustAcquireMempoolFirstMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MustAcquireMempoolFirstMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MustAcquireMempoolFirstMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NativeLanguage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"native\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NativeLanguage {
    #[serde(rename = "native")]
    Native,
}
impl ::std::convert::From<&Self> for NativeLanguage {
    fn from(value: &NativeLanguage) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NativeLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Native => write!(f, "native"),
        }
    }
}
impl ::std::str::FromStr for NativeLanguage {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "native" => Ok(Self::Native),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NativeLanguage {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NativeLanguage {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NativeLanguage {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A network target, as defined since the Shelley era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Network\","]
#[doc = "  \"description\": \"A network target, as defined since the Shelley era.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"mainnet\","]
#[doc = "    \"testnet\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Network {
    #[serde(rename = "mainnet")]
    Mainnet,
    #[serde(rename = "testnet")]
    Testnet,
}
impl ::std::convert::From<&Self> for Network {
    fn from(value: &Network) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Network {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Mainnet => write!(f, "mainnet"),
            Self::Testnet => write!(f, "testnet"),
        }
    }
}
impl ::std::str::FromStr for Network {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "mainnet" => Ok(Self::Mainnet),
            "testnet" => Ok(Self::Testnet),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Network {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Network {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Network {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A magic number for telling networks apart. (e.g. 764824073)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"NetworkMagic\","]
#[doc = "  \"description\": \"A magic number for telling networks apart. (e.g. 764824073)\","]
#[doc = "  \"examples\": ["]
#[doc = "    764824073"]
#[doc = "  ],"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 4294967296.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct NetworkMagic(pub i64);
impl ::std::ops::Deref for NetworkMagic {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<NetworkMagic> for i64 {
    fn from(value: NetworkMagic) -> Self {
        value.0
    }
}
impl ::std::convert::From<&NetworkMagic> for NetworkMagic {
    fn from(value: &NetworkMagic) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for NetworkMagic {
    fn from(value: i64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for NetworkMagic {
    type Err = <i64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for NetworkMagic {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for NetworkMagic {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for NetworkMagic {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for NetworkMagic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Neutral"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Neutral\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"neutral\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Neutral {
    #[serde(rename = "neutral")]
    Neutral,
}
impl ::std::convert::From<&Self> for Neutral {
    fn from(value: &Neutral) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Neutral {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Neutral => write!(f, "neutral"),
        }
    }
}
impl ::std::str::FromStr for Neutral {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "neutral" => Ok(Self::Neutral),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Neutral {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Neutral {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Neutral {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Request next block from the current cardano-node's cursor."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"NextBlock\","]
#[doc = "  \"description\": \"Request next block from the current cardano-node's cursor.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"nextBlock\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NextBlock {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: NextBlockJsonrpc,
    pub method: NextBlockMethod,
}
impl ::std::convert::From<&NextBlock> for NextBlock {
    fn from(value: &NextBlock) -> Self {
        value.clone()
    }
}
#[doc = "NextBlockJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextBlockJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for NextBlockJsonrpc {
    fn from(value: &NextBlockJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextBlockJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for NextBlockJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextBlockJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextBlockJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextBlockJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextBlockMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"nextBlock\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextBlockMethod {
    #[serde(rename = "nextBlock")]
    NextBlock,
}
impl ::std::convert::From<&Self> for NextBlockMethod {
    fn from(value: &NextBlockMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextBlockMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NextBlock => write!(f, "nextBlock"),
        }
    }
}
impl ::std::str::FromStr for NextBlockMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "nextBlock" => Ok(Self::NextBlock),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Response to a 'nextBlock' request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"NextBlockResponse\","]
#[doc = "  \"description\": \"Response to a 'nextBlock' request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"nextBlock\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"RollForward\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block\","]
#[doc = "            \"direction\","]
#[doc = "            \"tip\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block\": {"]
#[doc = "              \"$ref\": \"#/definitions/Block\""]
#[doc = "            },"]
#[doc = "            \"direction\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"forward\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"tip\": {"]
#[doc = "              \"$ref\": \"#/definitions/Tip\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RollBackward\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"direction\","]
#[doc = "            \"point\","]
#[doc = "            \"tip\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"direction\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"backward\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"point\": {"]
#[doc = "              \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "            },"]
#[doc = "            \"tip\": {"]
#[doc = "              \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NextBlockResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: NextBlockResponseJsonrpc,
    pub method: NextBlockResponseMethod,
    pub result: NextBlockResponseResult,
}
impl ::std::convert::From<&NextBlockResponse> for NextBlockResponse {
    fn from(value: &NextBlockResponse) -> Self {
        value.clone()
    }
}
#[doc = "NextBlockResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextBlockResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for NextBlockResponseJsonrpc {
    fn from(value: &NextBlockResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextBlockResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for NextBlockResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextBlockResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextBlockResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextBlockResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextBlockResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"nextBlock\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextBlockResponseMethod {
    #[serde(rename = "nextBlock")]
    NextBlock,
}
impl ::std::convert::From<&Self> for NextBlockResponseMethod {
    fn from(value: &NextBlockResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextBlockResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NextBlock => write!(f, "nextBlock"),
        }
    }
}
impl ::std::str::FromStr for NextBlockResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "nextBlock" => Ok(Self::NextBlock),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextBlockResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextBlockResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextBlockResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextBlockResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"RollForward\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block\","]
#[doc = "        \"direction\","]
#[doc = "        \"tip\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block\": {"]
#[doc = "          \"$ref\": \"#/definitions/Block\""]
#[doc = "        },"]
#[doc = "        \"direction\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"forward\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tip\": {"]
#[doc = "          \"$ref\": \"#/definitions/Tip\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RollBackward\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"direction\","]
#[doc = "        \"point\","]
#[doc = "        \"tip\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"direction\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"backward\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"point\": {"]
#[doc = "          \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "        },"]
#[doc = "        \"tip\": {"]
#[doc = "          \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "direction", deny_unknown_fields)]
pub enum NextBlockResponseResult {
    #[doc = "RollForward"]
    #[serde(rename = "forward")]
    Forward { block: Block, tip: Tip },
    #[doc = "RollBackward"]
    #[serde(rename = "backward")]
    Backward {
        point: PointOrOrigin,
        tip: TipOrOrigin,
    },
}
impl ::std::convert::From<&Self> for NextBlockResponseResult {
    fn from(value: &NextBlockResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "Request the next transaction from an acquired mempools napshot."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"NextTransaction\","]
#[doc = "  \"description\": \"Request the next transaction from an acquired mempools napshot.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"nextTransaction\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"all\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NextTransaction {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: NextTransactionJsonrpc,
    pub method: NextTransactionMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<NextTransactionParams>,
}
impl ::std::convert::From<&NextTransaction> for NextTransaction {
    fn from(value: &NextTransaction) -> Self {
        value.clone()
    }
}
#[doc = "NextTransactionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextTransactionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for NextTransactionJsonrpc {
    fn from(value: &NextTransactionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextTransactionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for NextTransactionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextTransactionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"nextTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextTransactionMethod {
    #[serde(rename = "nextTransaction")]
    NextTransaction,
}
impl ::std::convert::From<&Self> for NextTransactionMethod {
    fn from(value: &NextTransactionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextTransactionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NextTransaction => write!(f, "nextTransaction"),
        }
    }
}
impl ::std::str::FromStr for NextTransactionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "nextTransaction" => Ok(Self::NextTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextTransactionParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"fields\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NextTransactionParams {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<NextTransactionParamsFields>,
}
impl ::std::convert::From<&NextTransactionParams> for NextTransactionParams {
    fn from(value: &NextTransactionParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NextTransactionParams {
    fn default() -> Self {
        Self {
            fields: Default::default(),
        }
    }
}
#[doc = "NextTransactionParamsFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextTransactionParamsFields {
    #[serde(rename = "all")]
    All,
}
impl ::std::convert::From<&Self> for NextTransactionParamsFields {
    fn from(value: &NextTransactionParamsFields) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextTransactionParamsFields {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
        }
    }
}
impl ::std::str::FromStr for NextTransactionParamsFields {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextTransactionParamsFields {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextTransactionParamsFields {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextTransactionParamsFields {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextTransactionResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextTransactionResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for NextTransactionResponseJsonrpc {
    fn from(value: &NextTransactionResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextTransactionResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for NextTransactionResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextTransactionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NextTransactionResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"nextTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NextTransactionResponseMethod {
    #[serde(rename = "nextTransaction")]
    NextTransaction,
}
impl ::std::convert::From<&Self> for NextTransactionResponseMethod {
    fn from(value: &NextTransactionResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NextTransactionResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NextTransaction => write!(f, "nextTransaction"),
        }
    }
}
impl ::std::str::FromStr for NextTransactionResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "nextTransaction" => Ok(Self::NextTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NextTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NextTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NextTransactionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A transaction (or id) or an empty object if there's no more transactions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A transaction (or id) or an empty object if there's no more transactions.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Transaction\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NextTransactionResponseResult {
    pub transaction: NextTransactionResponseResultTransaction,
}
impl ::std::convert::From<&NextTransactionResponseResult> for NextTransactionResponseResult {
    fn from(value: &NextTransactionResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "NextTransactionResponseResultTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Transaction\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum NextTransactionResponseResultTransaction {
    Variant0 { id: TransactionId },
    Variant1(Transaction),
    Variant2,
}
impl ::std::convert::From<&Self> for NextTransactionResponseResultTransaction {
    fn from(value: &NextTransactionResponseResultTransaction) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Transaction> for NextTransactionResponseResultTransaction {
    fn from(value: Transaction) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Nonce"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Nonce\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Neutral\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"neutral\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Nonce {
    Neutral(Neutral),
    DigestBlake2b256(DigestBlake2b256),
}
impl ::std::convert::From<&Self> for Nonce {
    fn from(value: &Nonce) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Neutral> for Nonce {
    fn from(value: Neutral) -> Self {
        Self::Neutral(value)
    }
}
impl ::std::convert::From<DigestBlake2b256> for Nonce {
    fn from(value: DigestBlake2b256) -> Self {
        Self::DigestBlake2b256(value)
    }
}
#[doc = "Null"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Null(pub ());
impl ::std::ops::Deref for Null {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<Null> for () {
    fn from(value: Null) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Null> for Null {
    fn from(value: &Null) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for Null {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "NumberOfBytes"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bytes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bytes\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NumberOfBytes {
    pub bytes: UInt64,
}
impl ::std::convert::From<&NumberOfBytes> for NumberOfBytes {
    fn from(value: &NumberOfBytes) -> Self {
        value.clone()
    }
}
#[doc = "Ogmios"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$id\": \"ogmios.json\","]
#[doc = "  \"title\": \"ogmios\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"AcquireLedgerState\","]
#[doc = "    \"AcquireLedgerStateResponse\","]
#[doc = "    \"AcquireMempool\","]
#[doc = "    \"AcquireMempoolResponse\","]
#[doc = "    \"EvaluateTransaction\","]
#[doc = "    \"EvaluateTransactionResponse\","]
#[doc = "    \"FindIntersection\","]
#[doc = "    \"FindIntersectionResponse\","]
#[doc = "    \"HasTransaction\","]
#[doc = "    \"HasTransactionResponse\","]
#[doc = "    \"NextBlock\","]
#[doc = "    \"NextBlockResponse\","]
#[doc = "    \"NextTransaction\","]
#[doc = "    \"NextTransactionResponse\","]
#[doc = "    \"QueryLedgerStateConstitution\","]
#[doc = "    \"QueryLedgerStateConstitutionResponse\","]
#[doc = "    \"QueryLedgerStateConstitutionalCommittee\","]
#[doc = "    \"QueryLedgerStateConstitutionalCommitteeResponse\","]
#[doc = "    \"QueryLedgerStateDelegateRepresentatives\","]
#[doc = "    \"QueryLedgerStateDelegateRepresentativesResponse\","]
#[doc = "    \"QueryLedgerStateDump\","]
#[doc = "    \"QueryLedgerStateDumpResponse\","]
#[doc = "    \"QueryLedgerStateEpoch\","]
#[doc = "    \"QueryLedgerStateEpochResponse\","]
#[doc = "    \"QueryLedgerStateEraStart\","]
#[doc = "    \"QueryLedgerStateEraStartResponse\","]
#[doc = "    \"QueryLedgerStateEraSummaries\","]
#[doc = "    \"QueryLedgerStateEraSummariesResponse\","]
#[doc = "    \"QueryLedgerStateGovernanceProposals\","]
#[doc = "    \"QueryLedgerStateGovernanceProposalsResponse\","]
#[doc = "    \"QueryLedgerStateLiveStakeDistribution\","]
#[doc = "    \"QueryLedgerStateLiveStakeDistributionResponse\","]
#[doc = "    \"QueryLedgerStateProjectedRewards\","]
#[doc = "    \"QueryLedgerStateProjectedRewardsResponse\","]
#[doc = "    \"QueryLedgerStateProposedProtocolParameters\","]
#[doc = "    \"QueryLedgerStateProposedProtocolParametersResponse\","]
#[doc = "    \"QueryLedgerStateProtocolParameters\","]
#[doc = "    \"QueryLedgerStateProtocolParametersResponse\","]
#[doc = "    \"QueryLedgerStateRewardAccountSummaries\","]
#[doc = "    \"QueryLedgerStateRewardAccountSummariesResponse\","]
#[doc = "    \"QueryLedgerStateRewardsProvenance\","]
#[doc = "    \"QueryLedgerStateRewardsProvenanceResponse\","]
#[doc = "    \"QueryLedgerStateStakePools\","]
#[doc = "    \"QueryLedgerStateStakePoolsResponse\","]
#[doc = "    \"QueryLedgerStateTip\","]
#[doc = "    \"QueryLedgerStateTipResponse\","]
#[doc = "    \"QueryLedgerStateTreasuryAndReserves\","]
#[doc = "    \"QueryLedgerStateTreasuryAndReservesResponse\","]
#[doc = "    \"QueryLedgerStateUtxo\","]
#[doc = "    \"QueryLedgerStateUtxoResponse\","]
#[doc = "    \"QueryNetworkBlockHeight\","]
#[doc = "    \"QueryNetworkBlockHeightResponse\","]
#[doc = "    \"QueryNetworkGenesisConfiguration\","]
#[doc = "    \"QueryNetworkGenesisConfigurationResponse\","]
#[doc = "    \"QueryNetworkStartTime\","]
#[doc = "    \"QueryNetworkStartTimeResponse\","]
#[doc = "    \"QueryNetworkTip\","]
#[doc = "    \"QueryNetworkTipResponse\","]
#[doc = "    \"ReleaseLedgerState\","]
#[doc = "    \"ReleaseLedgerStateResponse\","]
#[doc = "    \"ReleaseMempool\","]
#[doc = "    \"ReleaseMempoolResponse\","]
#[doc = "    \"RpcError\","]
#[doc = "    \"SizeAndCapacityResponse\","]
#[doc = "    \"SizeOfMempool\","]
#[doc = "    \"SubmitTransaction\","]
#[doc = "    \"SubmitTransactionResponse\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"AcquireLedgerState\": {"]
#[doc = "      \"title\": \"AcquireLedgerState\","]
#[doc = "      \"description\": \"Acquire a point on chain from which to run ledger-state queries.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"acquireLedgerState\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"point\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"point\": {"]
#[doc = "              \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"AcquireLedgerStateResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"AcquireLedgerStateSuccess\","]
#[doc = "          \"description\": \"Response to an 'acquireLedgerState' request.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"acquireLedgerState\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"acquired\","]
#[doc = "                \"point\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"acquired\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"ledgerState\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"point\": {"]
#[doc = "                  \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/AcquireLedgerStateFailure\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"AcquireMempool\": {"]
#[doc = "      \"title\": \"AcquireMempool\","]
#[doc = "      \"description\": \"Acquire a mempool snapshot. This is blocking until a new (i.e different) snapshot is available.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"acquireMempool\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"AcquireMempoolResponse\": {"]
#[doc = "      \"title\": \"AcquireMempoolResponse\","]
#[doc = "      \"description\": \"Response to a 'acquireMempool' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"acquireMempool\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"acquired\","]
#[doc = "            \"slot\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"acquired\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"mempool\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"slot\": {"]
#[doc = "              \"$ref\": \"#/definitions/Slot\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"EvaluateTransaction\": {"]
#[doc = "      \"title\": \"EvaluateTransaction\","]
#[doc = "      \"description\": \"Evaluate execution units for which redeemers's budget hasn't yet been set.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"evaluateTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"additionalUtxo\": {"]
#[doc = "              \"$ref\": \"#/definitions/Utxo\""]
#[doc = "            },"]
#[doc = "            \"transaction\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"cbor\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"cbor\": {"]
#[doc = "                  \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "                  \"contentEncoding\": \"base16\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"EvaluateTransactionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"EvaluateTransactionSuccess\","]
#[doc = "          \"examples\": ["]
#[doc = "            {"]
#[doc = "              \"jsonrpc\": \"2.0\","]
#[doc = "              \"result\": ["]
#[doc = "                {"]
#[doc = "                  \"budget\": {"]
#[doc = "                    \"cpu\": 1212353,"]
#[doc = "                    \"memory\": 5236222"]
#[doc = "                  },"]
#[doc = "                  \"validator\": \"spend:1\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"budget\": {"]
#[doc = "                    \"cpu\": 42,"]
#[doc = "                    \"memory\": 5000"]
#[doc = "                  },"]
#[doc = "                  \"validator\": \"mint:0\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"evaluateTransaction\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"budget\","]
#[doc = "                  \"validator\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"budget\": {"]
#[doc = "                    \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "                  },"]
#[doc = "                  \"validator\": {"]
#[doc = "                    \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"EvaluateTransactionError\","]
#[doc = "          \"description\": \"Happens when attempting to evaluate execution units on a node that isn't enough synchronized.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"$ref\": \"#/definitions/EvaluateTransactionFailure\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"evaluateTransaction\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"EvaluateTransactionDeserialisationError\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"$ref\": \"#/definitions/DeserialisationFailure\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"evaluateTransaction\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"FindIntersection\": {"]
#[doc = "      \"title\": \"FindIntersection\","]
#[doc = "      \"description\": \"Ask cardano-node to find an intersection between its local chain and the given points.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"findIntersection\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"points\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"FindIntersectionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"IntersectionFound\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"findIntersection\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"intersection\","]
#[doc = "                \"tip\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"intersection\": {"]
#[doc = "                  \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "                },"]
#[doc = "                \"tip\": {"]
#[doc = "                  \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"IntersectionNotFound\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"description\": \"No intersection found with the requested points.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"code\","]
#[doc = "                \"data\","]
#[doc = "                \"message\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"code\": {"]
#[doc = "                  \"type\": \"integer\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    1000"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"data\": {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"tip\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"tip\": {"]
#[doc = "                      \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                \"message\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"findIntersection\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"IntersectionInterleaved\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"description\": \"An internal error indicating that requests were interleaved in an unexpected way. Shouldn't ever happen.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"code\","]
#[doc = "                \"message\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"code\": {"]
#[doc = "                  \"type\": \"integer\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    1001"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"message\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"findIntersection\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"HasTransaction\": {"]
#[doc = "      \"title\": \"HasTransaction\","]
#[doc = "      \"description\": \"Ask whether a given transaction is present in the acquired mempool snapshot.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"hasTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"HasTransactionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"HasTransactionResponse\","]
#[doc = "          \"description\": \"Response to a 'HasTransaction' request.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"hasTransaction\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"NextBlock\": {"]
#[doc = "      \"title\": \"NextBlock\","]
#[doc = "      \"description\": \"Request next block from the current cardano-node's cursor.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"nextBlock\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"NextBlockResponse\": {"]
#[doc = "      \"title\": \"NextBlockResponse\","]
#[doc = "      \"description\": \"Response to a 'nextBlock' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"nextBlock\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"RollForward\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"block\","]
#[doc = "                \"direction\","]
#[doc = "                \"tip\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"block\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Block\""]
#[doc = "                },"]
#[doc = "                \"direction\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"forward\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"tip\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Tip\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"RollBackward\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"direction\","]
#[doc = "                \"point\","]
#[doc = "                \"tip\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"direction\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"backward\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"point\": {"]
#[doc = "                  \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "                },"]
#[doc = "                \"tip\": {"]
#[doc = "                  \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"NextTransaction\": {"]
#[doc = "      \"title\": \"NextTransaction\","]
#[doc = "      \"description\": \"Request the next transaction from an acquired mempools napshot.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"nextTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"NextTransactionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"NextTransactionResponse\","]
#[doc = "          \"description\": \"Response to a 'nextTransaction' request.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"nextTransaction\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"description\": \"A transaction (or id) or an empty object if there's no more transactions.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"transaction\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"transaction\": {"]
#[doc = "                  \"anyOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"id\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"id\": {"]
#[doc = "                          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/Transaction\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"null\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateConstitution\": {"]
#[doc = "      \"title\": \"QueryLedgerStateConstitution\","]
#[doc = "      \"description\": \"Query the current constitution definition (only available from Conway onwards).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/constitution\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateConstitutionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateConstitutionResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/constitution\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/Constitution\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateConstitutionalCommittee\": {"]
#[doc = "      \"title\": \"QueryLedgerStateConstitutionalCommittee\","]
#[doc = "      \"description\": \"Get the state of the constitutional committee (only available from Conway onwards).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/constitutionalCommittee\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateConstitutionalCommitteeResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateConstitutionalCommitteeResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/constitutionalCommittee\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"members\","]
#[doc = "                    \"quorum\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"members\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/ConstitutionalCommitteeMember\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"quorum\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"null\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateDelegateRepresentatives\": {"]
#[doc = "      \"title\": \"QueryLedgerStateDelegateRepresentatives\","]
#[doc = "      \"description\": \"Query currently registered delegate representatives, their stake (i.e. voting powers) and metadata about them. Note that 'params' is optional and can be used to filter out delegates. When omitted, ALL delegates are returned. Pre-defined options (always abstain and always no confidence) are ALWAYS returned.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/delegateRepresentatives\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"scripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateDelegateRepresentativesResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateDelegateRepresentativesResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/delegateRepresentatives\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/DelegateRepresentativeSummary\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateDump\": {"]
#[doc = "      \"title\": \"QueryLedgerStateDump\","]
#[doc = "      \"description\": \"Get a dump of the entire Cardano ledger state (base16-encoded CBOR) corresponding to the 'EpochState'. Use at your own risks.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/dump\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateDumpResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateDumpResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/dump\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"contentEncoding\": \"base16\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEpoch\": {"]
#[doc = "      \"title\": \"QueryLedgerStateEpoch\","]
#[doc = "      \"description\": \"Query the current epoch number the ledger is at.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/epoch\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEpochResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateEpochResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/epoch\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/Epoch\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEraStart\": {"]
#[doc = "      \"title\": \"QueryLedgerStateEraStart\","]
#[doc = "      \"description\": \"Query the start of the current ledger era.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/eraStart\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEraStartResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateEraStartResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/eraStart\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/Bound\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEraSummaries\": {"]
#[doc = "      \"title\": \"QueryLedgerStateEraSummaries\","]
#[doc = "      \"description\": \"Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/eraSummaries\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateEraSummariesResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateEraSummariesResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/eraSummaries\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/EraSummary\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateGovernanceProposals\": {"]
#[doc = "      \"title\": \"QueryLedgerStateGovernanceProposals\","]
#[doc = "      \"description\": \"Query currently active governance proposals, optionally restricted to specific governance proposal references.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/governanceProposals\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"GovernanceProposalsByReferences\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"proposals\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"proposals\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"WholeGovernanceProposals\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateGovernanceProposalsResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateGovernanceProposalsResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/governanceProposals\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/GovernanceProposalState\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateLiveStakeDistribution\": {"]
#[doc = "      \"title\": \"QueryLedgerStateLiveStakeDistribution\","]
#[doc = "      \"description\": \"Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/liveStakeDistribution\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateLiveStakeDistributionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateLiveStakeDistributionResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/liveStakeDistribution\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/LiveStakeDistribution\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProjectedRewards\": {"]
#[doc = "      \"title\": \"QueryLedgerStateProjectedRewards\","]
#[doc = "      \"description\": \"Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/projectedRewards\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"scripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"stake\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProjectedRewardsResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateProjectedRewardsResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/projectedRewards\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/ProjectedRewards\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProposedProtocolParameters\": {"]
#[doc = "      \"title\": \"QueryLedgerStateProposedProtocolParameters\","]
#[doc = "      \"description\": \"Query the last update proposal w.r.t. protocol parameters, if any.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProposedProtocolParametersResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateProposedProtocolParametersResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/ProposedProtocolParameters\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProtocolParameters\": {"]
#[doc = "      \"title\": \"QueryLedgerStateProtocolParameters\","]
#[doc = "      \"description\": \"Query the current protocol parameters.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/protocolParameters\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateProtocolParametersResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateProtocolParametersResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/protocolParameters\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/ProtocolParameters\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateRewardAccountSummaries\": {"]
#[doc = "      \"title\": \"QueryLedgerStateRewardAccountSummaries\","]
#[doc = "      \"description\": \"Query current delegation settings and rewards of some given reward accounts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"scripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateRewardAccountSummariesResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateRewardAccountSummariesResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"title\": \"RewardAccountSummaries\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": {"]
#[doc = "                \"$ref\": \"#/definitions/RewardAccountSummary\""]
#[doc = "              },"]
#[doc = "              \"propertyNames\": {"]
#[doc = "                \"pattern\": \"^[0-9]+|[0-9a-f]+$\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateRewardsProvenance\": {"]
#[doc = "      \"title\": \"QueryLedgerStateRewardsProvenance\","]
#[doc = "      \"description\": \"Query details about rewards calculation for the ongoing epoch.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/rewardsProvenance\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateRewardsProvenanceResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateRewardsProvenanceResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/rewardsProvenance\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/RewardsProvenance\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateStakePools\": {"]
#[doc = "      \"title\": \"QueryLedgerStateStakePools\","]
#[doc = "      \"description\": \"Query the list of all stake pools currently registered and active, optionally filtered by ids.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/stakePools\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"includeStake\": {"]
#[doc = "              \"description\": \"When provided and set to 'true', the result will also include the live stake associated to each pool. This may take some additional time the first time this is queried within an epoch.\","]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"stakePools\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"id\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateStakePoolsResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateStakePoolsResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/stakePools\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": {"]
#[doc = "                \"$ref\": \"#/definitions/StakePool\""]
#[doc = "              },"]
#[doc = "              \"propertyNames\": {"]
#[doc = "                \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateTip\": {"]
#[doc = "      \"title\": \"QueryLedgerStateTip\","]
#[doc = "      \"description\": \"Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/tip\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateTipResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateTipResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/tip\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateTreasuryAndReserves\": {"]
#[doc = "      \"title\": \"QueryLedgerStateTreasuryAndReserves\","]
#[doc = "      \"description\": \"Query the Ada value of the treasury and reserves accounts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/treasuryAndReserves\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateTreasuryAndReservesResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateTreasuryAndReservesResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/treasuryAndReserves\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"reserves\","]
#[doc = "                \"treasury\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"reserves\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "                },"]
#[doc = "                \"treasury\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateUtxo\": {"]
#[doc = "      \"title\": \"QueryLedgerStateUtxo\","]
#[doc = "      \"description\": \"Query the current Utxo set, restricted to some output references or addresses.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/utxo\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"UtxoByOutputReferences\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"outputReferences\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"outputReferences\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"UtxoByAddresses\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"addresses\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"addresses\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Address\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"WholeUtxo\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryLedgerStateUtxoResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"QueryLedgerStateUtxoResponse\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"queryLedgerState/utxo\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/Utxo\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkBlockHeight\": {"]
#[doc = "      \"title\": \"QueryNetworkBlockHeight\","]
#[doc = "      \"description\": \"Query the networks highest block number.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/blockHeight\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkBlockHeightResponse\": {"]
#[doc = "      \"title\": \"QueryNetworkBlockHeightResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/blockHeight\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Origin\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkGenesisConfiguration\": {"]
#[doc = "      \"title\": \"QueryNetworkGenesisConfiguration\","]
#[doc = "      \"description\": \"Query the genesis configuration of a given era.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/genesisConfiguration\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"era\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"era\": {"]
#[doc = "              \"$ref\": \"#/definitions/EraWithGenesis\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkGenesisConfigurationResponse\": {"]
#[doc = "      \"title\": \"QueryNetworkGenesisConfigurationResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/genesisConfiguration\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/QueryNetworkInvalidGenesis\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Genesis<Byron>\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Genesis<Shelley>\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Genesis<Alonzo>\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Genesis<Conway>\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkStartTime\": {"]
#[doc = "      \"title\": \"QueryNetworkStartTime\","]
#[doc = "      \"description\": \"Query the network start time.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/startTime\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkStartTimeResponse\": {"]
#[doc = "      \"title\": \"QueryNetworkStartTimeResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/startTime\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/UtcTime\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkTip\": {"]
#[doc = "      \"title\": \"QueryNetworkTip\","]
#[doc = "      \"description\": \"Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/tip\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"QueryNetworkTipResponse\": {"]
#[doc = "      \"title\": \"QueryNetworkTipResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryNetwork/tip\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"ReleaseLedgerState\": {"]
#[doc = "      \"title\": \"ReleaseLedgerState\","]
#[doc = "      \"description\": \"Release a previously acquired ledger state.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"releaseLedgerState\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"ReleaseLedgerStateResponse\": {"]
#[doc = "      \"title\": \"ReleaseLedgerStateResponse\","]
#[doc = "      \"description\": \"Response to a 'releaseLedgerState' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"releaseLedgerState\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"released\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"released\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"ledgerState\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"ReleaseMempool\": {"]
#[doc = "      \"title\": \"ReleaseMempool\","]
#[doc = "      \"description\": \"Release a previously acquired mempool snapshot.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"releaseMempool\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"ReleaseMempoolResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"ReleaseMempoolResponse\","]
#[doc = "          \"description\": \"Response to a 'releaseMempool' request.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"releaseMempool\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"released\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"released\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"mempool\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"RpcError\": {"]
#[doc = "      \"title\": \"RpcError\","]
#[doc = "      \"description\": \"A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.\","]
#[doc = "      \"examples\": ["]
#[doc = "        {"]
#[doc = "          \"error\": {"]
#[doc = "            \"code\": \"-32601\","]
#[doc = "            \"message\": \"Invalid request: invalid query.\""]
#[doc = "          },"]
#[doc = "          \"jsonrpc\": \"2.0\""]
#[doc = "        }"]
#[doc = "      ],"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\","]
#[doc = "            \"string\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"description\": \"An error code telling about the nature of the error.\","]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"maximum\": -32000.0,"]
#[doc = "              \"minimum\": -32700.0"]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"description\": \"Some optional data / context about the error. The exact type of this (optional) field depends on the error.\""]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"description\": \"A descriptive error message giving hints about the error.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"SizeOfMempool\": {"]
#[doc = "      \"title\": \"SizeOfMempool\","]
#[doc = "      \"description\": \"Get size and capacities of the mempool (acquired snapshot).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"sizeOfMempool\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"SizeOfMempoolResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"SizeOfMempoolResponse\","]
#[doc = "          \"description\": \"Response to a 'sizeOfMempool' request.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"sizeOfMempool\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"$ref\": \"#/definitions/MempoolSizeAndCapacity\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"SubmitTransaction\": {"]
#[doc = "      \"title\": \"SubmitTransaction\","]
#[doc = "      \"description\": \"Submit a signed and serialized transaction to the network.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"params\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"submitTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"params\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"transaction\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"cbor\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"cbor\": {"]
#[doc = "                  \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "                  \"contentEncoding\": \"base16\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"SubmitTransactionResponse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"SubmitTransactionSuccess\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\","]
#[doc = "            \"result\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"submitTransaction\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"result\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"transaction\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"transaction\": {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"id\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"id\": {"]
#[doc = "                      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"SubmitTransactionError\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"$ref\": \"#/definitions/SubmitTransactionFailure\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"submitTransaction\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"SubmitTransactionDeserialisationError\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error\","]
#[doc = "            \"jsonrpc\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error\": {"]
#[doc = "              \"$ref\": \"#/definitions/DeserialisationFailure\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "            },"]
#[doc = "            \"jsonrpc\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"2.0\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"submitTransaction\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Ogmios {
    #[serde(rename = "AcquireLedgerState")]
    pub acquire_ledger_state: AcquireLedgerState,
    #[serde(rename = "AcquireLedgerStateResponse")]
    pub acquire_ledger_state_response: OgmiosAcquireLedgerStateResponse,
    #[serde(rename = "AcquireMempool")]
    pub acquire_mempool: AcquireMempool,
    #[serde(rename = "AcquireMempoolResponse")]
    pub acquire_mempool_response: AcquireMempoolResponse,
    #[serde(rename = "EvaluateTransaction")]
    pub evaluate_transaction: EvaluateTransaction,
    #[serde(rename = "EvaluateTransactionResponse")]
    pub evaluate_transaction_response: OgmiosEvaluateTransactionResponse,
    #[serde(rename = "FindIntersection")]
    pub find_intersection: FindIntersection,
    #[serde(rename = "FindIntersectionResponse")]
    pub find_intersection_response: OgmiosFindIntersectionResponse,
    #[serde(rename = "HasTransaction")]
    pub has_transaction: HasTransaction,
    #[serde(rename = "HasTransactionResponse")]
    pub has_transaction_response: OgmiosHasTransactionResponse,
    #[serde(rename = "NextBlock")]
    pub next_block: NextBlock,
    #[serde(rename = "NextBlockResponse")]
    pub next_block_response: NextBlockResponse,
    #[serde(rename = "NextTransaction")]
    pub next_transaction: NextTransaction,
    #[serde(rename = "NextTransactionResponse")]
    pub next_transaction_response: OgmiosNextTransactionResponse,
    #[serde(rename = "QueryLedgerStateConstitution")]
    pub query_ledger_state_constitution: QueryLedgerStateConstitution,
    #[serde(rename = "QueryLedgerStateConstitutionResponse")]
    pub query_ledger_state_constitution_response: OgmiosQueryLedgerStateConstitutionResponse,
    #[serde(rename = "QueryLedgerStateConstitutionalCommittee")]
    pub query_ledger_state_constitutional_committee: QueryLedgerStateConstitutionalCommittee,
    #[serde(rename = "QueryLedgerStateConstitutionalCommitteeResponse")]
    pub query_ledger_state_constitutional_committee_response:
        OgmiosQueryLedgerStateConstitutionalCommitteeResponse,
    #[serde(rename = "QueryLedgerStateDelegateRepresentatives")]
    pub query_ledger_state_delegate_representatives: QueryLedgerStateDelegateRepresentatives,
    #[serde(rename = "QueryLedgerStateDelegateRepresentativesResponse")]
    pub query_ledger_state_delegate_representatives_response:
        OgmiosQueryLedgerStateDelegateRepresentativesResponse,
    #[serde(rename = "QueryLedgerStateDump")]
    pub query_ledger_state_dump: QueryLedgerStateDump,
    #[serde(rename = "QueryLedgerStateDumpResponse")]
    pub query_ledger_state_dump_response: OgmiosQueryLedgerStateDumpResponse,
    #[serde(rename = "QueryLedgerStateEpoch")]
    pub query_ledger_state_epoch: QueryLedgerStateEpoch,
    #[serde(rename = "QueryLedgerStateEpochResponse")]
    pub query_ledger_state_epoch_response: OgmiosQueryLedgerStateEpochResponse,
    #[serde(rename = "QueryLedgerStateEraStart")]
    pub query_ledger_state_era_start: QueryLedgerStateEraStart,
    #[serde(rename = "QueryLedgerStateEraStartResponse")]
    pub query_ledger_state_era_start_response: OgmiosQueryLedgerStateEraStartResponse,
    #[serde(rename = "QueryLedgerStateEraSummaries")]
    pub query_ledger_state_era_summaries: QueryLedgerStateEraSummaries,
    #[serde(rename = "QueryLedgerStateEraSummariesResponse")]
    pub query_ledger_state_era_summaries_response: OgmiosQueryLedgerStateEraSummariesResponse,
    #[serde(rename = "QueryLedgerStateGovernanceProposals")]
    pub query_ledger_state_governance_proposals: QueryLedgerStateGovernanceProposals,
    #[serde(rename = "QueryLedgerStateGovernanceProposalsResponse")]
    pub query_ledger_state_governance_proposals_response:
        OgmiosQueryLedgerStateGovernanceProposalsResponse,
    #[serde(rename = "QueryLedgerStateLiveStakeDistribution")]
    pub query_ledger_state_live_stake_distribution: QueryLedgerStateLiveStakeDistribution,
    #[serde(rename = "QueryLedgerStateLiveStakeDistributionResponse")]
    pub query_ledger_state_live_stake_distribution_response:
        OgmiosQueryLedgerStateLiveStakeDistributionResponse,
    #[serde(rename = "QueryLedgerStateProjectedRewards")]
    pub query_ledger_state_projected_rewards: QueryLedgerStateProjectedRewards,
    #[serde(rename = "QueryLedgerStateProjectedRewardsResponse")]
    pub query_ledger_state_projected_rewards_response:
        OgmiosQueryLedgerStateProjectedRewardsResponse,
    #[serde(rename = "QueryLedgerStateProposedProtocolParameters")]
    pub query_ledger_state_proposed_protocol_parameters: QueryLedgerStateProposedProtocolParameters,
    #[serde(rename = "QueryLedgerStateProposedProtocolParametersResponse")]
    pub query_ledger_state_proposed_protocol_parameters_response:
        OgmiosQueryLedgerStateProposedProtocolParametersResponse,
    #[serde(rename = "QueryLedgerStateProtocolParameters")]
    pub query_ledger_state_protocol_parameters: QueryLedgerStateProtocolParameters,
    #[serde(rename = "QueryLedgerStateProtocolParametersResponse")]
    pub query_ledger_state_protocol_parameters_response:
        OgmiosQueryLedgerStateProtocolParametersResponse,
    #[serde(rename = "QueryLedgerStateRewardAccountSummaries")]
    pub query_ledger_state_reward_account_summaries: QueryLedgerStateRewardAccountSummaries,
    #[serde(rename = "QueryLedgerStateRewardAccountSummariesResponse")]
    pub query_ledger_state_reward_account_summaries_response:
        OgmiosQueryLedgerStateRewardAccountSummariesResponse,
    #[serde(rename = "QueryLedgerStateRewardsProvenance")]
    pub query_ledger_state_rewards_provenance: QueryLedgerStateRewardsProvenance,
    #[serde(rename = "QueryLedgerStateRewardsProvenanceResponse")]
    pub query_ledger_state_rewards_provenance_response:
        OgmiosQueryLedgerStateRewardsProvenanceResponse,
    #[serde(rename = "QueryLedgerStateStakePools")]
    pub query_ledger_state_stake_pools: QueryLedgerStateStakePools,
    #[serde(rename = "QueryLedgerStateStakePoolsResponse")]
    pub query_ledger_state_stake_pools_response: OgmiosQueryLedgerStateStakePoolsResponse,
    #[serde(rename = "QueryLedgerStateTip")]
    pub query_ledger_state_tip: QueryLedgerStateTip,
    #[serde(rename = "QueryLedgerStateTipResponse")]
    pub query_ledger_state_tip_response: OgmiosQueryLedgerStateTipResponse,
    #[serde(rename = "QueryLedgerStateTreasuryAndReserves")]
    pub query_ledger_state_treasury_and_reserves: QueryLedgerStateTreasuryAndReserves,
    #[serde(rename = "QueryLedgerStateTreasuryAndReservesResponse")]
    pub query_ledger_state_treasury_and_reserves_response:
        OgmiosQueryLedgerStateTreasuryAndReservesResponse,
    #[serde(rename = "QueryLedgerStateUtxo")]
    pub query_ledger_state_utxo: QueryLedgerStateUtxo,
    #[serde(rename = "QueryLedgerStateUtxoResponse")]
    pub query_ledger_state_utxo_response: OgmiosQueryLedgerStateUtxoResponse,
    #[serde(rename = "QueryNetworkBlockHeight")]
    pub query_network_block_height: QueryNetworkBlockHeight,
    #[serde(rename = "QueryNetworkBlockHeightResponse")]
    pub query_network_block_height_response: QueryNetworkBlockHeightResponse,
    #[serde(rename = "QueryNetworkGenesisConfiguration")]
    pub query_network_genesis_configuration: QueryNetworkGenesisConfiguration,
    #[serde(rename = "QueryNetworkGenesisConfigurationResponse")]
    pub query_network_genesis_configuration_response: QueryNetworkGenesisConfigurationResponse,
    #[serde(rename = "QueryNetworkStartTime")]
    pub query_network_start_time: QueryNetworkStartTime,
    #[serde(rename = "QueryNetworkStartTimeResponse")]
    pub query_network_start_time_response: QueryNetworkStartTimeResponse,
    #[serde(rename = "QueryNetworkTip")]
    pub query_network_tip: QueryNetworkTip,
    #[serde(rename = "QueryNetworkTipResponse")]
    pub query_network_tip_response: QueryNetworkTipResponse,
    #[serde(rename = "ReleaseLedgerState")]
    pub release_ledger_state: ReleaseLedgerState,
    #[serde(rename = "ReleaseLedgerStateResponse")]
    pub release_ledger_state_response: ReleaseLedgerStateResponse,
    #[serde(rename = "ReleaseMempool")]
    pub release_mempool: ReleaseMempool,
    #[serde(rename = "ReleaseMempoolResponse")]
    pub release_mempool_response: OgmiosReleaseMempoolResponse,
    #[serde(rename = "RpcError")]
    pub rpc_error: RpcError,
    #[serde(rename = "SizeAndCapacityResponse")]
    pub size_and_capacity_response: ::serde_json::Value,
    #[serde(rename = "SizeOfMempool")]
    pub size_of_mempool: SizeOfMempool,
    #[serde(
        rename = "SizeOfMempoolResponse",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub size_of_mempool_response: ::std::option::Option<OgmiosSizeOfMempoolResponse>,
    #[serde(rename = "SubmitTransaction")]
    pub submit_transaction: SubmitTransaction,
    #[serde(rename = "SubmitTransactionResponse")]
    pub submit_transaction_response: OgmiosSubmitTransactionResponse,
}
impl ::std::convert::From<&Ogmios> for Ogmios {
    fn from(value: &Ogmios) -> Self {
        value.clone()
    }
}
#[doc = "OgmiosAcquireLedgerStateResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"AcquireLedgerStateSuccess\","]
#[doc = "      \"description\": \"Response to an 'acquireLedgerState' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"acquireLedgerState\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"acquired\","]
#[doc = "            \"point\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"acquired\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"ledgerState\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"point\": {"]
#[doc = "              \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/AcquireLedgerStateFailure\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosAcquireLedgerStateResponse {
    Success {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: AcquireLedgerStateSuccessJsonrpc,
        method: AcquireLedgerStateSuccessMethod,
        result: AcquireLedgerStateSuccessResult,
    },
    Failure(AcquireLedgerStateFailure),
}
impl ::std::convert::From<&Self> for OgmiosAcquireLedgerStateResponse {
    fn from(value: &OgmiosAcquireLedgerStateResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AcquireLedgerStateFailure> for OgmiosAcquireLedgerStateResponse {
    fn from(value: AcquireLedgerStateFailure) -> Self {
        Self::Failure(value)
    }
}
#[doc = "OgmiosEvaluateTransactionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionSuccess\","]
#[doc = "      \"examples\": ["]
#[doc = "        {"]
#[doc = "          \"jsonrpc\": \"2.0\","]
#[doc = "          \"result\": ["]
#[doc = "            {"]
#[doc = "              \"budget\": {"]
#[doc = "                \"cpu\": 1212353,"]
#[doc = "                \"memory\": 5236222"]
#[doc = "              },"]
#[doc = "              \"validator\": \"spend:1\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"budget\": {"]
#[doc = "                \"cpu\": 42,"]
#[doc = "                \"memory\": 5000"]
#[doc = "              },"]
#[doc = "              \"validator\": \"mint:0\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ],"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"evaluateTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"budget\","]
#[doc = "              \"validator\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"budget\": {"]
#[doc = "                \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "              },"]
#[doc = "              \"validator\": {"]
#[doc = "                \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionError\","]
#[doc = "      \"description\": \"Happens when attempting to evaluate execution units on a node that isn't enough synchronized.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/definitions/EvaluateTransactionFailure\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"evaluateTransaction\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EvaluateTransactionDeserialisationError\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/definitions/DeserialisationFailure\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"evaluateTransaction\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosEvaluateTransactionResponse {
    Success {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: EvaluateTransactionSuccessJsonrpc,
        method: EvaluateTransactionSuccessMethod,
        result: ::std::vec::Vec<EvaluateTransactionSuccessResultItem>,
    },
    Error {
        error: EvaluateTransactionFailure,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: EvaluateTransactionErrorJsonrpc,
        method: EvaluateTransactionErrorMethod,
    },
    DeserialisationError {
        error: DeserialisationFailure,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: EvaluateTransactionDeserialisationErrorJsonrpc,
        method: EvaluateTransactionDeserialisationErrorMethod,
    },
}
impl ::std::convert::From<&Self> for OgmiosEvaluateTransactionResponse {
    fn from(value: &OgmiosEvaluateTransactionResponse) -> Self {
        value.clone()
    }
}
#[doc = "OgmiosFindIntersectionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"IntersectionFound\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"findIntersection\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"intersection\","]
#[doc = "            \"tip\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"intersection\": {"]
#[doc = "              \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "            },"]
#[doc = "            \"tip\": {"]
#[doc = "              \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"IntersectionNotFound\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"description\": \"No intersection found with the requested points.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\","]
#[doc = "            \"data\","]
#[doc = "            \"message\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"enum\": ["]
#[doc = "                1000"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"tip\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"tip\": {"]
#[doc = "                  \"$ref\": \"#/definitions/TipOrOrigin\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"findIntersection\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"IntersectionInterleaved\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"description\": \"An internal error indicating that requests were interleaved in an unexpected way. Shouldn't ever happen.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\","]
#[doc = "            \"message\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"enum\": ["]
#[doc = "                1001"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"findIntersection\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosFindIntersectionResponse {
    Found {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: IntersectionFoundJsonrpc,
        method: IntersectionFoundMethod,
        result: IntersectionFoundResult,
    },
    NotFound {
        error: IntersectionNotFoundError,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: IntersectionNotFoundJsonrpc,
        method: IntersectionNotFoundMethod,
    },
    Interleaved {
        error: IntersectionInterleavedError,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: IntersectionInterleavedJsonrpc,
        method: IntersectionInterleavedMethod,
    },
}
impl ::std::convert::From<&Self> for OgmiosFindIntersectionResponse {
    fn from(value: &OgmiosFindIntersectionResponse) -> Self {
        value.clone()
    }
}
#[doc = "OgmiosHasTransactionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"HasTransactionResponse\","]
#[doc = "      \"description\": \"Response to a 'HasTransaction' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"hasTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosHasTransactionResponse {
    HasTransactionResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: HasTransactionResponseJsonrpc,
        method: HasTransactionResponseMethod,
        result: bool,
    },
    MustAcquireMempoolFirst(MustAcquireMempoolFirst),
}
impl ::std::convert::From<&Self> for OgmiosHasTransactionResponse {
    fn from(value: &OgmiosHasTransactionResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MustAcquireMempoolFirst> for OgmiosHasTransactionResponse {
    fn from(value: MustAcquireMempoolFirst) -> Self {
        Self::MustAcquireMempoolFirst(value)
    }
}
#[doc = "OgmiosNextTransactionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"NextTransactionResponse\","]
#[doc = "      \"description\": \"Response to a 'nextTransaction' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"nextTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"description\": \"A transaction (or id) or an empty object if there's no more transactions.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"transaction\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"id\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"id\": {"]
#[doc = "                      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Transaction\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosNextTransactionResponse {
    NextTransactionResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: NextTransactionResponseJsonrpc,
        method: NextTransactionResponseMethod,
        result: NextTransactionResponseResult,
    },
    MustAcquireMempoolFirst(MustAcquireMempoolFirst),
}
impl ::std::convert::From<&Self> for OgmiosNextTransactionResponse {
    fn from(value: &OgmiosNextTransactionResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MustAcquireMempoolFirst> for OgmiosNextTransactionResponse {
    fn from(value: MustAcquireMempoolFirst) -> Self {
        Self::MustAcquireMempoolFirst(value)
    }
}
#[doc = "OgmiosQueryLedgerStateConstitutionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateConstitutionResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/constitution\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/Constitution\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateConstitutionResponse {
    ConstitutionResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateConstitutionResponseJsonrpc,
        method: QueryLedgerStateConstitutionResponseMethod,
        result: Constitution,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateConstitutionResponse {
    fn from(value: &OgmiosQueryLedgerStateConstitutionResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateConstitutionResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateConstitutionResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateConstitutionResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateConstitutionalCommitteeResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateConstitutionalCommitteeResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/constitutionalCommittee\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"members\","]
#[doc = "                \"quorum\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"members\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/ConstitutionalCommitteeMember\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"quorum\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"null\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateConstitutionalCommitteeResponse {
    ConstitutionalCommitteeResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateConstitutionalCommitteeResponseJsonrpc,
        method: QueryLedgerStateConstitutionalCommitteeResponseMethod,
        result: ::std::option::Option<QueryLedgerStateConstitutionalCommitteeResponseResult>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateConstitutionalCommitteeResponse {
    fn from(value: &OgmiosQueryLedgerStateConstitutionalCommitteeResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateConstitutionalCommitteeResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateConstitutionalCommitteeResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateConstitutionalCommitteeResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateDelegateRepresentativesResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateDelegateRepresentativesResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/delegateRepresentatives\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/DelegateRepresentativeSummary\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateDelegateRepresentativesResponse {
    DelegateRepresentativesResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateDelegateRepresentativesResponseJsonrpc,
        method: QueryLedgerStateDelegateRepresentativesResponseMethod,
        result: ::std::vec::Vec<DelegateRepresentativeSummary>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateDelegateRepresentativesResponse {
    fn from(value: &OgmiosQueryLedgerStateDelegateRepresentativesResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateDelegateRepresentativesResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateDelegateRepresentativesResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateDelegateRepresentativesResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateDumpResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateDumpResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/dump\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"contentEncoding\": \"base16\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateDumpResponse {
    DumpResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateDumpResponseJsonrpc,
        method: QueryLedgerStateDumpResponseMethod,
        result: ::std::string::String,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateDumpResponse {
    fn from(value: &OgmiosQueryLedgerStateDumpResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch> for OgmiosQueryLedgerStateDumpResponse {
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateDumpResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired> for OgmiosQueryLedgerStateDumpResponse {
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateEpochResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateEpochResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/epoch\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/Epoch\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateEpochResponse {
    EpochResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateEpochResponseJsonrpc,
        method: QueryLedgerStateEpochResponseMethod,
        result: Epoch,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateEpochResponse {
    fn from(value: &OgmiosQueryLedgerStateEpochResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch> for OgmiosQueryLedgerStateEpochResponse {
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateEpochResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired> for OgmiosQueryLedgerStateEpochResponse {
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateEraStartResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateEraStartResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/eraStart\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/Bound\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateEraStartResponse {
    EraStartResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateEraStartResponseJsonrpc,
        method: QueryLedgerStateEraStartResponseMethod,
        result: Bound,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateEraStartResponse {
    fn from(value: &OgmiosQueryLedgerStateEraStartResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch> for OgmiosQueryLedgerStateEraStartResponse {
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateEraStartResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateEraStartResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateEraSummariesResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateEraSummariesResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/eraSummaries\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/EraSummary\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateEraSummariesResponse {
    EraSummariesResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateEraSummariesResponseJsonrpc,
        method: QueryLedgerStateEraSummariesResponseMethod,
        result: ::std::vec::Vec<EraSummary>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateEraSummariesResponse {
    fn from(value: &OgmiosQueryLedgerStateEraSummariesResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateEraSummariesResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateEraSummariesResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateEraSummariesResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateGovernanceProposalsResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateGovernanceProposalsResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/governanceProposals\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceProposalState\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateGovernanceProposalsResponse {
    GovernanceProposalsResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateGovernanceProposalsResponseJsonrpc,
        method: QueryLedgerStateGovernanceProposalsResponseMethod,
        result: ::std::vec::Vec<GovernanceProposalState>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateGovernanceProposalsResponse {
    fn from(value: &OgmiosQueryLedgerStateGovernanceProposalsResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateGovernanceProposalsResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateGovernanceProposalsResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateGovernanceProposalsResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateLiveStakeDistributionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateLiveStakeDistributionResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/liveStakeDistribution\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/LiveStakeDistribution\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateLiveStakeDistributionResponse {
    LiveStakeDistributionResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateLiveStakeDistributionResponseJsonrpc,
        method: QueryLedgerStateLiveStakeDistributionResponseMethod,
        result: LiveStakeDistribution,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateLiveStakeDistributionResponse {
    fn from(value: &OgmiosQueryLedgerStateLiveStakeDistributionResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateLiveStakeDistributionResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateLiveStakeDistributionResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateLiveStakeDistributionResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateProjectedRewardsResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateProjectedRewardsResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/projectedRewards\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProjectedRewards\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateProjectedRewardsResponse {
    ProjectedRewardsResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateProjectedRewardsResponseJsonrpc,
        method: QueryLedgerStateProjectedRewardsResponseMethod,
        result: ProjectedRewards,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateProjectedRewardsResponse {
    fn from(value: &OgmiosQueryLedgerStateProjectedRewardsResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateProjectedRewardsResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateProjectedRewardsResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateProjectedRewardsResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateProposedProtocolParametersResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateProposedProtocolParametersResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/ProposedProtocolParameters\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateProposedProtocolParametersResponse {
    ProposedProtocolParametersResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateProposedProtocolParametersResponseJsonrpc,
        method: QueryLedgerStateProposedProtocolParametersResponseMethod,
        result: ::std::vec::Vec<ProposedProtocolParameters>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateProposedProtocolParametersResponse {
    fn from(value: &OgmiosQueryLedgerStateProposedProtocolParametersResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateProposedProtocolParametersResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateProposedProtocolParametersResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateProposedProtocolParametersResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateProtocolParametersResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateProtocolParametersResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/protocolParameters\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/ProtocolParameters\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateProtocolParametersResponse {
    ProtocolParametersResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateProtocolParametersResponseJsonrpc,
        method: QueryLedgerStateProtocolParametersResponseMethod,
        result: ProtocolParameters,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateProtocolParametersResponse {
    fn from(value: &OgmiosQueryLedgerStateProtocolParametersResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateProtocolParametersResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateProtocolParametersResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateProtocolParametersResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateRewardAccountSummariesResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateRewardAccountSummariesResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"title\": \"RewardAccountSummaries\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/definitions/RewardAccountSummary\""]
#[doc = "          },"]
#[doc = "          \"propertyNames\": {"]
#[doc = "            \"pattern\": \"^[0-9]+|[0-9a-f]+$\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateRewardAccountSummariesResponse {
    RewardAccountSummariesResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateRewardAccountSummariesResponseJsonrpc,
        method: QueryLedgerStateRewardAccountSummariesResponseMethod,
        result: ::std::collections::HashMap<
            QueryLedgerStateRewardAccountSummariesResponseResultKey,
            RewardAccountSummary,
        >,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateRewardAccountSummariesResponse {
    fn from(value: &OgmiosQueryLedgerStateRewardAccountSummariesResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateRewardAccountSummariesResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateRewardAccountSummariesResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateRewardAccountSummariesResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateRewardsProvenanceResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateRewardsProvenanceResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/rewardsProvenance\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/RewardsProvenance\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateRewardsProvenanceResponse {
    RewardsProvenanceResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateRewardsProvenanceResponseJsonrpc,
        method: QueryLedgerStateRewardsProvenanceResponseMethod,
        result: RewardsProvenance,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateRewardsProvenanceResponse {
    fn from(value: &OgmiosQueryLedgerStateRewardsProvenanceResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateRewardsProvenanceResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateRewardsProvenanceResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateRewardsProvenanceResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateStakePoolsResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateStakePoolsResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/stakePools\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/definitions/StakePool\""]
#[doc = "          },"]
#[doc = "          \"propertyNames\": {"]
#[doc = "            \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateStakePoolsResponse {
    StakePoolsResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateStakePoolsResponseJsonrpc,
        method: QueryLedgerStateStakePoolsResponseMethod,
        result: ::std::collections::HashMap<StakePoolId, StakePool>,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateStakePoolsResponse {
    fn from(value: &OgmiosQueryLedgerStateStakePoolsResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateStakePoolsResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateStakePoolsResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateStakePoolsResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateTipResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateTipResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/tip\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateTipResponse {
    TipResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateTipResponseJsonrpc,
        method: QueryLedgerStateTipResponseMethod,
        result: PointOrOrigin,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateTipResponse {
    fn from(value: &OgmiosQueryLedgerStateTipResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch> for OgmiosQueryLedgerStateTipResponse {
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateTipResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired> for OgmiosQueryLedgerStateTipResponse {
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateTreasuryAndReservesResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateTreasuryAndReservesResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/treasuryAndReserves\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"reserves\","]
#[doc = "            \"treasury\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"reserves\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"treasury\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateTreasuryAndReservesResponse {
    TreasuryAndReservesResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateTreasuryAndReservesResponseJsonrpc,
        method: QueryLedgerStateTreasuryAndReservesResponseMethod,
        result: QueryLedgerStateTreasuryAndReservesResponseResult,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateTreasuryAndReservesResponse {
    fn from(value: &OgmiosQueryLedgerStateTreasuryAndReservesResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch>
    for OgmiosQueryLedgerStateTreasuryAndReservesResponse
{
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateTreasuryAndReservesResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired>
    for OgmiosQueryLedgerStateTreasuryAndReservesResponse
{
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosQueryLedgerStateUtxoResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"QueryLedgerStateUtxoResponse\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"queryLedgerState/utxo\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/Utxo\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateEraMismatch\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateUnavailableInCurrentEra\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryLedgerStateAcquiredExpired\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosQueryLedgerStateUtxoResponse {
    UtxoResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: QueryLedgerStateUtxoResponseJsonrpc,
        method: QueryLedgerStateUtxoResponseMethod,
        result: Utxo,
    },
    EraMismatch(QueryLedgerStateEraMismatch),
    UnavailableInCurrentEra(QueryLedgerStateUnavailableInCurrentEra),
    AcquiredExpired(QueryLedgerStateAcquiredExpired),
}
impl ::std::convert::From<&Self> for OgmiosQueryLedgerStateUtxoResponse {
    fn from(value: &OgmiosQueryLedgerStateUtxoResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatch> for OgmiosQueryLedgerStateUtxoResponse {
    fn from(value: QueryLedgerStateEraMismatch) -> Self {
        Self::EraMismatch(value)
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEra>
    for OgmiosQueryLedgerStateUtxoResponse
{
    fn from(value: QueryLedgerStateUnavailableInCurrentEra) -> Self {
        Self::UnavailableInCurrentEra(value)
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpired> for OgmiosQueryLedgerStateUtxoResponse {
    fn from(value: QueryLedgerStateAcquiredExpired) -> Self {
        Self::AcquiredExpired(value)
    }
}
#[doc = "OgmiosReleaseMempoolResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"ReleaseMempoolResponse\","]
#[doc = "      \"description\": \"Response to a 'releaseMempool' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"releaseMempool\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"released\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"released\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"mempool\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosReleaseMempoolResponse {
    ReleaseMempoolResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: ReleaseMempoolResponseJsonrpc,
        method: ReleaseMempoolResponseMethod,
        result: ReleaseMempoolResponseResult,
    },
    MustAcquireMempoolFirst(MustAcquireMempoolFirst),
}
impl ::std::convert::From<&Self> for OgmiosReleaseMempoolResponse {
    fn from(value: &OgmiosReleaseMempoolResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MustAcquireMempoolFirst> for OgmiosReleaseMempoolResponse {
    fn from(value: MustAcquireMempoolFirst) -> Self {
        Self::MustAcquireMempoolFirst(value)
    }
}
#[doc = "OgmiosSizeOfMempoolResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"SizeOfMempoolResponse\","]
#[doc = "      \"description\": \"Response to a 'sizeOfMempool' request.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"sizeOfMempool\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/definitions/MempoolSizeAndCapacity\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/MustAcquireMempoolFirst\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosSizeOfMempoolResponse {
    SizeOfMempoolResponse {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: SizeOfMempoolResponseJsonrpc,
        method: SizeOfMempoolResponseMethod,
        result: MempoolSizeAndCapacity,
    },
    MustAcquireMempoolFirst(MustAcquireMempoolFirst),
}
impl ::std::convert::From<&Self> for OgmiosSizeOfMempoolResponse {
    fn from(value: &OgmiosSizeOfMempoolResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MustAcquireMempoolFirst> for OgmiosSizeOfMempoolResponse {
    fn from(value: MustAcquireMempoolFirst) -> Self {
        Self::MustAcquireMempoolFirst(value)
    }
}
#[doc = "OgmiosSubmitTransactionResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionSuccess\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\","]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"submitTransaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"transaction\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"id\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"id\": {"]
#[doc = "                  \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionError\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/definitions/SubmitTransactionFailure\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"submitTransaction\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionDeserialisationError\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\","]
#[doc = "        \"jsonrpc\","]
#[doc = "        \"method\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/definitions/DeserialisationFailure\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "        },"]
#[doc = "        \"jsonrpc\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"2.0\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"method\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"submitTransaction\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum OgmiosSubmitTransactionResponse {
    Success {
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: SubmitTransactionSuccessJsonrpc,
        method: SubmitTransactionSuccessMethod,
        result: SubmitTransactionSuccessResult,
    },
    Error {
        error: SubmitTransactionFailure,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: SubmitTransactionErrorJsonrpc,
        method: SubmitTransactionErrorMethod,
    },
    DeserialisationError {
        error: DeserialisationFailure,
        #[doc = "Any value that was set by a client request in the 'id' field."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<::serde_json::Value>,
        jsonrpc: SubmitTransactionDeserialisationErrorJsonrpc,
        method: SubmitTransactionDeserialisationErrorMethod,
    },
}
impl ::std::convert::From<&Self> for OgmiosSubmitTransactionResponse {
    fn from(value: &OgmiosSubmitTransactionResponse) -> Self {
        value.clone()
    }
}
#[doc = "Certificate identifying a stake pool operator."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OperationalCertificate\","]
#[doc = "  \"description\": \"Certificate identifying a stake pool operator.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"count\","]
#[doc = "    \"kes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"kes\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"period\","]
#[doc = "        \"verificationKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"period\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt64\""]
#[doc = "        },"]
#[doc = "        \"verificationKey\": {"]
#[doc = "          \"$ref\": \"#/definitions/KesVerificationKey\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sigma\": {"]
#[doc = "      \"$ref\": \"#/definitions/Signature\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OperationalCertificate {
    pub count: UInt64,
    pub kes: OperationalCertificateKes,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sigma: ::std::option::Option<Signature>,
}
impl ::std::convert::From<&OperationalCertificate> for OperationalCertificate {
    fn from(value: &OperationalCertificate) -> Self {
        value.clone()
    }
}
#[doc = "OperationalCertificateKes"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"period\","]
#[doc = "    \"verificationKey\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"period\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"verificationKey\": {"]
#[doc = "      \"$ref\": \"#/definitions/KesVerificationKey\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OperationalCertificateKes {
    pub period: UInt64,
    #[serde(rename = "verificationKey")]
    pub verification_key: KesVerificationKey,
}
impl ::std::convert::From<&OperationalCertificateKes> for OperationalCertificateKes {
    fn from(value: &OperationalCertificateKes) -> Self {
        value.clone()
    }
}
#[doc = "The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Origin\","]
#[doc = "  \"description\": \"The origin of the blockchain. This point is special in the sense that it doesn't point to any existing slots, but is preceding any existing other point.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"origin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Origin {
    #[serde(rename = "origin")]
    Origin,
}
impl ::std::convert::From<&Self> for Origin {
    fn from(value: &Origin) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Origin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Origin => write!(f, "origin"),
        }
    }
}
impl ::std::str::FromStr for Origin {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "origin" => Ok(Self::Origin),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Origin {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Origin {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Origin {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PlutusLanguage"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"plutus:v1\","]
#[doc = "    \"plutus:v2\","]
#[doc = "    \"plutus:v3\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PlutusLanguage {
    #[serde(rename = "plutus:v1")]
    PlutusV1,
    #[serde(rename = "plutus:v2")]
    PlutusV2,
    #[serde(rename = "plutus:v3")]
    PlutusV3,
}
impl ::std::convert::From<&Self> for PlutusLanguage {
    fn from(value: &PlutusLanguage) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PlutusLanguage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::PlutusV1 => write!(f, "plutus:v1"),
            Self::PlutusV2 => write!(f, "plutus:v2"),
            Self::PlutusV3 => write!(f, "plutus:v3"),
        }
    }
}
impl ::std::str::FromStr for PlutusLanguage {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "plutus:v1" => Ok(Self::PlutusV1),
            "plutus:v2" => Ok(Self::PlutusV2),
            "plutus:v3" => Ok(Self::PlutusV3),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PlutusLanguage {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PlutusLanguage {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PlutusLanguage {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PointOrOrigin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Point\","]
#[doc = "      \"description\": \"A point on the chain, identified by a slot and a block header hash.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\","]
#[doc = "        \"slot\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        },"]
#[doc = "        \"slot\": {"]
#[doc = "          \"$ref\": \"#/definitions/Slot\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false,"]
#[doc = "      \"name\": \"Point\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Origin\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum PointOrOrigin {
    Point { id: DigestBlake2b256, slot: Slot },
    Origin(Origin),
}
impl ::std::convert::From<&Self> for PointOrOrigin {
    fn from(value: &PointOrOrigin) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Origin> for PointOrOrigin {
    fn from(value: Origin) -> Self {
        Self::Origin(value)
    }
}
#[doc = "PolicyId"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"PolicyId\","]
#[doc = "  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct PolicyId(pub DigestBlake2b224);
impl ::std::ops::Deref for PolicyId {
    type Target = DigestBlake2b224;
    fn deref(&self) -> &DigestBlake2b224 {
        &self.0
    }
}
impl ::std::convert::From<PolicyId> for DigestBlake2b224 {
    fn from(value: PolicyId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&PolicyId> for PolicyId {
    fn from(value: &PolicyId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DigestBlake2b224> for PolicyId {
    fn from(value: DigestBlake2b224) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for PolicyId {
    type Err = <DigestBlake2b224 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for PolicyId {
    type Error = <DigestBlake2b224 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for PolicyId {
    type Error = <DigestBlake2b224 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for PolicyId {
    type Error = <DigestBlake2b224 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for PolicyId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Rewards that can be expected assuming a pool is fully saturated. Such rewards are said non-myopic, in opposition to short-sighted rewards looking at immediate benefits. Keys of the map can be either Lovelace amounts or account credentials depending on the query.\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"1000000\": {"]
#[doc = "        \"pool1qqqqpanw9zc0rzh0yp247nzf2s35uvnsm7aaesfl2nnejaev0uc\": {"]
#[doc = "          \"ada\": {"]
#[doc = "            \"lovelace\": 676"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"pool1qqqqqdk4zhsjuxxd8jyvwncf5eucfskz0xjjj64fdmlgj735lr9\": {"]
#[doc = "          \"ada\": {"]
#[doc = "            \"lovelace\": 688"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"pool1qqqqzyqf8mlm70883zht60n4q6uqxg4a8x266sewv8ad2grkztl\": {"]
#[doc = "          \"ada\": {"]
#[doc = "            \"lovelace\": 0"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"bc1597ad71c55d2d009a9274b3831ded155118dd769f5376decc1369\": {"]
#[doc = "        \"pool1qfxukshs4fkcrflzdnxa2fdza5lfvew3y6echg8ckaa4q8m5hyf\": {"]
#[doc = "          \"ada\": {"]
#[doc = "            \"lovelace\": 103181546"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"pool1qfzjwrtupyvzx0atp5pa3m82v7s8z2eqyqffa0grpyf4j349h6r\": {"]
#[doc = "          \"ada\": {"]
#[doc = "            \"lovelace\": 0"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"additionalProperties\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"propertyNames\": {"]
#[doc = "      \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "      \"contentEncoding\": \"bech32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"pattern\": \"^[0-9]+|[0-9a-f]+$\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ProjectedRewards(
    pub  ::std::collections::HashMap<
        ProjectedRewardsKey,
        ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
    >,
);
impl ::std::ops::Deref for ProjectedRewards {
    type Target = ::std::collections::HashMap<
        ProjectedRewardsKey,
        ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
    >;
    fn deref(
        &self,
    ) -> &::std::collections::HashMap<
        ProjectedRewardsKey,
        ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
    > {
        &self.0
    }
}
impl ::std::convert::From<ProjectedRewards>
    for ::std::collections::HashMap<
        ProjectedRewardsKey,
        ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
    >
{
    fn from(value: ProjectedRewards) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ProjectedRewards> for ProjectedRewards {
    fn from(value: &ProjectedRewards) -> Self {
        value.clone()
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ProjectedRewardsKey,
            ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
        >,
    > for ProjectedRewards
{
    fn from(
        value: ::std::collections::HashMap<
            ProjectedRewardsKey,
            ::std::collections::HashMap<ProjectedRewardsValueKey, ValueAdaOnly>,
        >,
    ) -> Self {
        Self(value)
    }
}
#[doc = "ProjectedRewardsKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9]+|[0-9a-f]+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ProjectedRewardsKey(::std::string::String);
impl ::std::ops::Deref for ProjectedRewardsKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ProjectedRewardsKey> for ::std::string::String {
    fn from(value: ProjectedRewardsKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ProjectedRewardsKey> for ProjectedRewardsKey {
    fn from(value: &ProjectedRewardsKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ProjectedRewardsKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9]+|[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9]+|[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ProjectedRewardsKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectedRewardsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectedRewardsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ProjectedRewardsKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "ProjectedRewardsValueKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ProjectedRewardsValueKey(::std::string::String);
impl ::std::ops::Deref for ProjectedRewardsValueKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ProjectedRewardsValueKey> for ::std::string::String {
    fn from(value: ProjectedRewardsValueKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ProjectedRewardsValueKey> for ProjectedRewardsValueKey {
    fn from(value: &ProjectedRewardsValueKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ProjectedRewardsValueKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ProjectedRewardsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectedRewardsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectedRewardsValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ProjectedRewardsValueKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "ProposedProtocolParameters"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ProposedProtocolParameters\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"collateralPercentage\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommitteeMaxTermLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommitteeMinSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt16\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeMaxIdleTime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/DelegateRepresentativeVotingThresholds\""]
#[doc = "    },"]
#[doc = "    \"desiredNumberOfStakePools\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"extraEntropy\": {"]
#[doc = "      \"$ref\": \"#/definitions/Nonce\""]
#[doc = "    },"]
#[doc = "    \"federatedBlockProductionRatio\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"governanceActionDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"governanceActionLifetime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"maxBlockBodySize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxBlockHeaderSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxCollateralInputs\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerBlock\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerTransaction\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxReferenceScriptsSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxTransactionSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxValueSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"minFeeCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"minFeeConstant\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"minFeeReferenceScripts\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"base\","]
#[doc = "        \"multiplier\","]
#[doc = "        \"range\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"base\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"multiplier\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt32\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"minStakePoolCost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"minUtxoDepositCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"minUtxoDepositConstant\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"monetaryExpansion\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"plutusCostModels\": {"]
#[doc = "      \"$ref\": \"#/definitions/CostModels\""]
#[doc = "    },"]
#[doc = "    \"scriptExecutionPrices\": {"]
#[doc = "      \"$ref\": \"#/definitions/ScriptExecutionPrices\""]
#[doc = "    },"]
#[doc = "    \"stakeCredentialDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"stakePoolDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"stakePoolPledgeInfluence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"stakePoolRetirementEpochBound\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"stakePoolVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolVotingThresholds\""]
#[doc = "    },"]
#[doc = "    \"treasuryExpansion\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProposedProtocolParameters {
    #[serde(
        rename = "collateralPercentage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub collateral_percentage: ::std::option::Option<UInt64>,
    #[serde(
        rename = "constitutionalCommitteeMaxTermLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub constitutional_committee_max_term_length: ::std::option::Option<UInt64>,
    #[serde(
        rename = "constitutionalCommitteeMinSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub constitutional_committee_min_size: ::std::option::Option<UInt16>,
    #[serde(
        rename = "delegateRepresentativeDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "delegateRepresentativeMaxIdleTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_max_idle_time: ::std::option::Option<Epoch>,
    #[serde(
        rename = "delegateRepresentativeVotingThresholds",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_voting_thresholds:
        ::std::option::Option<DelegateRepresentativeVotingThresholds>,
    #[serde(
        rename = "desiredNumberOfStakePools",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub desired_number_of_stake_pools: ::std::option::Option<UInt64>,
    #[serde(
        rename = "extraEntropy",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub extra_entropy: ::std::option::Option<Nonce>,
    #[serde(
        rename = "federatedBlockProductionRatio",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub federated_block_production_ratio: ::std::option::Option<Ratio>,
    #[serde(
        rename = "governanceActionDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub governance_action_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "governanceActionLifetime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub governance_action_lifetime: ::std::option::Option<Epoch>,
    #[serde(
        rename = "maxBlockBodySize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_block_body_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxBlockHeaderSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_block_header_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxCollateralInputs",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_collateral_inputs: ::std::option::Option<UInt64>,
    #[serde(
        rename = "maxExecutionUnitsPerBlock",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_execution_units_per_block: ::std::option::Option<ExecutionUnits>,
    #[serde(
        rename = "maxExecutionUnitsPerTransaction",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_execution_units_per_transaction: ::std::option::Option<ExecutionUnits>,
    #[serde(
        rename = "maxReferenceScriptsSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_reference_scripts_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxTransactionSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_transaction_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxValueSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_value_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "minFeeCoefficient",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_coefficient: ::std::option::Option<UInt64>,
    #[serde(
        rename = "minFeeConstant",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_constant: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "minFeeReferenceScripts",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_reference_scripts:
        ::std::option::Option<ProposedProtocolParametersMinFeeReferenceScripts>,
    #[serde(
        rename = "minStakePoolCost",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_stake_pool_cost: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "minUtxoDepositCoefficient",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_utxo_deposit_coefficient: ::std::option::Option<UInt64>,
    #[serde(
        rename = "minUtxoDepositConstant",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_utxo_deposit_constant: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "monetaryExpansion",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub monetary_expansion: ::std::option::Option<Ratio>,
    #[serde(
        rename = "plutusCostModels",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub plutus_cost_models: ::std::option::Option<CostModels>,
    #[serde(
        rename = "scriptExecutionPrices",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub script_execution_prices: ::std::option::Option<ScriptExecutionPrices>,
    #[serde(
        rename = "stakeCredentialDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_credential_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "stakePoolDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_pool_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "stakePoolPledgeInfluence",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_pool_pledge_influence: ::std::option::Option<Ratio>,
    #[serde(
        rename = "stakePoolRetirementEpochBound",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_pool_retirement_epoch_bound: ::std::option::Option<UInt64>,
    #[serde(
        rename = "stakePoolVotingThresholds",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_pool_voting_thresholds: ::std::option::Option<StakePoolVotingThresholds>,
    #[serde(
        rename = "treasuryExpansion",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treasury_expansion: ::std::option::Option<Ratio>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<ProtocolVersion>,
}
impl ::std::convert::From<&ProposedProtocolParameters> for ProposedProtocolParameters {
    fn from(value: &ProposedProtocolParameters) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ProposedProtocolParameters {
    fn default() -> Self {
        Self {
            collateral_percentage: Default::default(),
            constitutional_committee_max_term_length: Default::default(),
            constitutional_committee_min_size: Default::default(),
            delegate_representative_deposit: Default::default(),
            delegate_representative_max_idle_time: Default::default(),
            delegate_representative_voting_thresholds: Default::default(),
            desired_number_of_stake_pools: Default::default(),
            extra_entropy: Default::default(),
            federated_block_production_ratio: Default::default(),
            governance_action_deposit: Default::default(),
            governance_action_lifetime: Default::default(),
            max_block_body_size: Default::default(),
            max_block_header_size: Default::default(),
            max_collateral_inputs: Default::default(),
            max_execution_units_per_block: Default::default(),
            max_execution_units_per_transaction: Default::default(),
            max_reference_scripts_size: Default::default(),
            max_transaction_size: Default::default(),
            max_value_size: Default::default(),
            min_fee_coefficient: Default::default(),
            min_fee_constant: Default::default(),
            min_fee_reference_scripts: Default::default(),
            min_stake_pool_cost: Default::default(),
            min_utxo_deposit_coefficient: Default::default(),
            min_utxo_deposit_constant: Default::default(),
            monetary_expansion: Default::default(),
            plutus_cost_models: Default::default(),
            script_execution_prices: Default::default(),
            stake_credential_deposit: Default::default(),
            stake_pool_deposit: Default::default(),
            stake_pool_pledge_influence: Default::default(),
            stake_pool_retirement_epoch_bound: Default::default(),
            stake_pool_voting_thresholds: Default::default(),
            treasury_expansion: Default::default(),
            version: Default::default(),
        }
    }
}
#[doc = "ProposedProtocolParametersMinFeeReferenceScripts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base\","]
#[doc = "    \"multiplier\","]
#[doc = "    \"range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"multiplier\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"range\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProposedProtocolParametersMinFeeReferenceScripts {
    pub base: f64,
    pub multiplier: f64,
    pub range: UInt32,
}
impl ::std::convert::From<&ProposedProtocolParametersMinFeeReferenceScripts>
    for ProposedProtocolParametersMinFeeReferenceScripts
{
    fn from(value: &ProposedProtocolParametersMinFeeReferenceScripts) -> Self {
        value.clone()
    }
}
#[doc = "ProtocolParameters"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ProtocolParameters\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"desiredNumberOfStakePools\","]
#[doc = "    \"maxBlockBodySize\","]
#[doc = "    \"maxBlockHeaderSize\","]
#[doc = "    \"minFeeCoefficient\","]
#[doc = "    \"minFeeConstant\","]
#[doc = "    \"minStakePoolCost\","]
#[doc = "    \"minUtxoDepositCoefficient\","]
#[doc = "    \"minUtxoDepositConstant\","]
#[doc = "    \"monetaryExpansion\","]
#[doc = "    \"stakeCredentialDeposit\","]
#[doc = "    \"stakePoolDeposit\","]
#[doc = "    \"stakePoolPledgeInfluence\","]
#[doc = "    \"stakePoolRetirementEpochBound\","]
#[doc = "    \"treasuryExpansion\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"collateralPercentage\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommitteeMaxTermLength\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"constitutionalCommitteeMinSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt16\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeMaxIdleTime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"delegateRepresentativeVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/DelegateRepresentativeVotingThresholds\""]
#[doc = "    },"]
#[doc = "    \"desiredNumberOfStakePools\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"extraEntropy\": {"]
#[doc = "      \"$ref\": \"#/definitions/Nonce\""]
#[doc = "    },"]
#[doc = "    \"federatedBlockProductionRatio\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"governanceActionDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"governanceActionLifetime\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"maxBlockBodySize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxBlockHeaderSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxCollateralInputs\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerBlock\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxExecutionUnitsPerTransaction\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"maxReferenceScriptsSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxTransactionSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"maxValueSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"minFeeCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"minFeeConstant\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"minFeeReferenceScripts\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"base\","]
#[doc = "        \"multiplier\","]
#[doc = "        \"range\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"base\": {"]
#[doc = "          \"description\": \"The base cost for the tier-price calculation.\","]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"multiplier\": {"]
#[doc = "          \"description\": \"The multiplier increasing the cost of each tier.\","]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"$ref\": \"#/definitions/UInt32\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"minStakePoolCost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"minUtxoDepositCoefficient\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"minUtxoDepositConstant\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"monetaryExpansion\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"plutusCostModels\": {"]
#[doc = "      \"$ref\": \"#/definitions/CostModels\""]
#[doc = "    },"]
#[doc = "    \"scriptExecutionPrices\": {"]
#[doc = "      \"$ref\": \"#/definitions/ScriptExecutionPrices\""]
#[doc = "    },"]
#[doc = "    \"stakeCredentialDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"stakePoolDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"stakePoolPledgeInfluence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"stakePoolRetirementEpochBound\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"stakePoolVotingThresholds\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolVotingThresholds\""]
#[doc = "    },"]
#[doc = "    \"treasuryExpansion\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProtocolParameters {
    #[serde(
        rename = "collateralPercentage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub collateral_percentage: ::std::option::Option<UInt64>,
    #[serde(
        rename = "constitutionalCommitteeMaxTermLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub constitutional_committee_max_term_length: ::std::option::Option<UInt64>,
    #[serde(
        rename = "constitutionalCommitteeMinSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub constitutional_committee_min_size: ::std::option::Option<UInt16>,
    #[serde(
        rename = "delegateRepresentativeDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "delegateRepresentativeMaxIdleTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_max_idle_time: ::std::option::Option<Epoch>,
    #[serde(
        rename = "delegateRepresentativeVotingThresholds",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub delegate_representative_voting_thresholds:
        ::std::option::Option<DelegateRepresentativeVotingThresholds>,
    #[serde(rename = "desiredNumberOfStakePools")]
    pub desired_number_of_stake_pools: UInt64,
    #[serde(
        rename = "extraEntropy",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub extra_entropy: ::std::option::Option<Nonce>,
    #[serde(
        rename = "federatedBlockProductionRatio",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub federated_block_production_ratio: ::std::option::Option<Ratio>,
    #[serde(
        rename = "governanceActionDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub governance_action_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(
        rename = "governanceActionLifetime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub governance_action_lifetime: ::std::option::Option<Epoch>,
    #[serde(rename = "maxBlockBodySize")]
    pub max_block_body_size: NumberOfBytes,
    #[serde(rename = "maxBlockHeaderSize")]
    pub max_block_header_size: NumberOfBytes,
    #[serde(
        rename = "maxCollateralInputs",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_collateral_inputs: ::std::option::Option<UInt64>,
    #[serde(
        rename = "maxExecutionUnitsPerBlock",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_execution_units_per_block: ::std::option::Option<ExecutionUnits>,
    #[serde(
        rename = "maxExecutionUnitsPerTransaction",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_execution_units_per_transaction: ::std::option::Option<ExecutionUnits>,
    #[serde(
        rename = "maxReferenceScriptsSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_reference_scripts_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxTransactionSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_transaction_size: ::std::option::Option<NumberOfBytes>,
    #[serde(
        rename = "maxValueSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_value_size: ::std::option::Option<NumberOfBytes>,
    #[serde(rename = "minFeeCoefficient")]
    pub min_fee_coefficient: UInt64,
    #[serde(rename = "minFeeConstant")]
    pub min_fee_constant: ValueAdaOnly,
    #[serde(
        rename = "minFeeReferenceScripts",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_fee_reference_scripts: ::std::option::Option<ProtocolParametersMinFeeReferenceScripts>,
    #[serde(rename = "minStakePoolCost")]
    pub min_stake_pool_cost: ValueAdaOnly,
    #[serde(rename = "minUtxoDepositCoefficient")]
    pub min_utxo_deposit_coefficient: UInt64,
    #[serde(rename = "minUtxoDepositConstant")]
    pub min_utxo_deposit_constant: ValueAdaOnly,
    #[serde(rename = "monetaryExpansion")]
    pub monetary_expansion: Ratio,
    #[serde(
        rename = "plutusCostModels",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub plutus_cost_models: ::std::option::Option<CostModels>,
    #[serde(
        rename = "scriptExecutionPrices",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub script_execution_prices: ::std::option::Option<ScriptExecutionPrices>,
    #[serde(rename = "stakeCredentialDeposit")]
    pub stake_credential_deposit: ValueAdaOnly,
    #[serde(rename = "stakePoolDeposit")]
    pub stake_pool_deposit: ValueAdaOnly,
    #[serde(rename = "stakePoolPledgeInfluence")]
    pub stake_pool_pledge_influence: Ratio,
    #[serde(rename = "stakePoolRetirementEpochBound")]
    pub stake_pool_retirement_epoch_bound: UInt64,
    #[serde(
        rename = "stakePoolVotingThresholds",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stake_pool_voting_thresholds: ::std::option::Option<StakePoolVotingThresholds>,
    #[serde(rename = "treasuryExpansion")]
    pub treasury_expansion: Ratio,
    pub version: ProtocolVersion,
}
impl ::std::convert::From<&ProtocolParameters> for ProtocolParameters {
    fn from(value: &ProtocolParameters) -> Self {
        value.clone()
    }
}
#[doc = "ProtocolParametersMinFeeReferenceScripts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base\","]
#[doc = "    \"multiplier\","]
#[doc = "    \"range\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base\": {"]
#[doc = "      \"description\": \"The base cost for the tier-price calculation.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"multiplier\": {"]
#[doc = "      \"description\": \"The multiplier increasing the cost of each tier.\","]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"range\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProtocolParametersMinFeeReferenceScripts {
    pub base: f64,
    pub multiplier: f64,
    pub range: UInt32,
}
impl ::std::convert::From<&ProtocolParametersMinFeeReferenceScripts>
    for ProtocolParametersMinFeeReferenceScripts
{
    fn from(value: &ProtocolParametersMinFeeReferenceScripts) -> Self {
        value.clone()
    }
}
#[doc = "ProtocolVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ProtocolVersion\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"major\","]
#[doc = "    \"minor\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"major\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    },"]
#[doc = "    \"minor\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    },"]
#[doc = "    \"patch\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProtocolVersion {
    pub major: UInt32,
    pub minor: UInt32,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub patch: ::std::option::Option<UInt32>,
}
impl ::std::convert::From<&ProtocolVersion> for ProtocolVersion {
    fn from(value: &ProtocolVersion) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateAcquiredExpired"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateAcquiredExpired\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"Previously acquired ledger state is no longer available.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            2003"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"A reason for the failure.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/constitution\","]
#[doc = "        \"queryLedgerState/constitutionalCommittee\","]
#[doc = "        \"queryLedgerState/delegateRepresentatives\","]
#[doc = "        \"queryLedgerState/epoch\","]
#[doc = "        \"queryLedgerState/eraStart\","]
#[doc = "        \"queryLedgerState/eraSummaries\","]
#[doc = "        \"queryLedgerState/governanceProposals\","]
#[doc = "        \"queryLedgerState/liveStakeDistribution\","]
#[doc = "        \"queryLedgerState/projectedRewards\","]
#[doc = "        \"queryLedgerState/protocolParameters\","]
#[doc = "        \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "        \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "        \"queryLedgerState/rewardsProvenance\","]
#[doc = "        \"queryLedgerState/stakePools\","]
#[doc = "        \"queryLedgerState/utxo\","]
#[doc = "        \"queryLedgerState/tip\","]
#[doc = "        \"queryLedgerState/treasuryAndReserves\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateAcquiredExpired {
    pub error: QueryLedgerStateAcquiredExpiredError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateAcquiredExpiredJsonrpc,
    pub method: QueryLedgerStateAcquiredExpiredMethod,
}
impl ::std::convert::From<&QueryLedgerStateAcquiredExpired> for QueryLedgerStateAcquiredExpired {
    fn from(value: &QueryLedgerStateAcquiredExpired) -> Self {
        value.clone()
    }
}
#[doc = "Previously acquired ledger state is no longer available."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Previously acquired ledger state is no longer available.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        2003"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"A reason for the failure.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateAcquiredExpiredError {
    pub code: QueryLedgerStateAcquiredExpiredErrorCode,
    #[doc = "A reason for the failure."]
    pub data: ::std::string::String,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&QueryLedgerStateAcquiredExpiredError>
    for QueryLedgerStateAcquiredExpiredError
{
    fn from(value: &QueryLedgerStateAcquiredExpiredError) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateAcquiredExpiredErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    2003"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct QueryLedgerStateAcquiredExpiredErrorCode(i64);
impl ::std::ops::Deref for QueryLedgerStateAcquiredExpiredErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<QueryLedgerStateAcquiredExpiredErrorCode> for i64 {
    fn from(value: QueryLedgerStateAcquiredExpiredErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&QueryLedgerStateAcquiredExpiredErrorCode>
    for QueryLedgerStateAcquiredExpiredErrorCode
{
    fn from(value: &QueryLedgerStateAcquiredExpiredErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for QueryLedgerStateAcquiredExpiredErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2003_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for QueryLedgerStateAcquiredExpiredErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "QueryLedgerStateAcquiredExpiredJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateAcquiredExpiredJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateAcquiredExpiredJsonrpc {
    fn from(value: &QueryLedgerStateAcquiredExpiredJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateAcquiredExpiredJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateAcquiredExpiredJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateAcquiredExpiredJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateAcquiredExpiredJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateAcquiredExpiredJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateAcquiredExpiredMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitution\","]
#[doc = "    \"queryLedgerState/constitutionalCommittee\","]
#[doc = "    \"queryLedgerState/delegateRepresentatives\","]
#[doc = "    \"queryLedgerState/epoch\","]
#[doc = "    \"queryLedgerState/eraStart\","]
#[doc = "    \"queryLedgerState/eraSummaries\","]
#[doc = "    \"queryLedgerState/governanceProposals\","]
#[doc = "    \"queryLedgerState/liveStakeDistribution\","]
#[doc = "    \"queryLedgerState/projectedRewards\","]
#[doc = "    \"queryLedgerState/protocolParameters\","]
#[doc = "    \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "    \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "    \"queryLedgerState/rewardsProvenance\","]
#[doc = "    \"queryLedgerState/stakePools\","]
#[doc = "    \"queryLedgerState/utxo\","]
#[doc = "    \"queryLedgerState/tip\","]
#[doc = "    \"queryLedgerState/treasuryAndReserves\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateAcquiredExpiredMethod {
    #[serde(rename = "queryLedgerState/constitution")]
    QueryLedgerStateConstitution,
    #[serde(rename = "queryLedgerState/constitutionalCommittee")]
    QueryLedgerStateConstitutionalCommittee,
    #[serde(rename = "queryLedgerState/delegateRepresentatives")]
    QueryLedgerStateDelegateRepresentatives,
    #[serde(rename = "queryLedgerState/epoch")]
    QueryLedgerStateEpoch,
    #[serde(rename = "queryLedgerState/eraStart")]
    QueryLedgerStateEraStart,
    #[serde(rename = "queryLedgerState/eraSummaries")]
    QueryLedgerStateEraSummaries,
    #[serde(rename = "queryLedgerState/governanceProposals")]
    QueryLedgerStateGovernanceProposals,
    #[serde(rename = "queryLedgerState/liveStakeDistribution")]
    QueryLedgerStateLiveStakeDistribution,
    #[serde(rename = "queryLedgerState/projectedRewards")]
    QueryLedgerStateProjectedRewards,
    #[serde(rename = "queryLedgerState/protocolParameters")]
    QueryLedgerStateProtocolParameters,
    #[serde(rename = "queryLedgerState/proposedProtocolParameters")]
    QueryLedgerStateProposedProtocolParameters,
    #[serde(rename = "queryLedgerState/rewardAccountSummaries")]
    QueryLedgerStateRewardAccountSummaries,
    #[serde(rename = "queryLedgerState/rewardsProvenance")]
    QueryLedgerStateRewardsProvenance,
    #[serde(rename = "queryLedgerState/stakePools")]
    QueryLedgerStateStakePools,
    #[serde(rename = "queryLedgerState/utxo")]
    QueryLedgerStateUtxo,
    #[serde(rename = "queryLedgerState/tip")]
    QueryLedgerStateTip,
    #[serde(rename = "queryLedgerState/treasuryAndReserves")]
    QueryLedgerStateTreasuryAndReserves,
}
impl ::std::convert::From<&Self> for QueryLedgerStateAcquiredExpiredMethod {
    fn from(value: &QueryLedgerStateAcquiredExpiredMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateAcquiredExpiredMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitution => write!(f, "queryLedgerState/constitution"),
            Self::QueryLedgerStateConstitutionalCommittee => {
                write!(f, "queryLedgerState/constitutionalCommittee")
            }
            Self::QueryLedgerStateDelegateRepresentatives => {
                write!(f, "queryLedgerState/delegateRepresentatives")
            }
            Self::QueryLedgerStateEpoch => write!(f, "queryLedgerState/epoch"),
            Self::QueryLedgerStateEraStart => write!(f, "queryLedgerState/eraStart"),
            Self::QueryLedgerStateEraSummaries => write!(f, "queryLedgerState/eraSummaries"),
            Self::QueryLedgerStateGovernanceProposals => {
                write!(f, "queryLedgerState/governanceProposals")
            }
            Self::QueryLedgerStateLiveStakeDistribution => {
                write!(f, "queryLedgerState/liveStakeDistribution")
            }
            Self::QueryLedgerStateProjectedRewards => {
                write!(f, "queryLedgerState/projectedRewards")
            }
            Self::QueryLedgerStateProtocolParameters => {
                write!(f, "queryLedgerState/protocolParameters")
            }
            Self::QueryLedgerStateProposedProtocolParameters => {
                write!(f, "queryLedgerState/proposedProtocolParameters")
            }
            Self::QueryLedgerStateRewardAccountSummaries => {
                write!(f, "queryLedgerState/rewardAccountSummaries")
            }
            Self::QueryLedgerStateRewardsProvenance => {
                write!(f, "queryLedgerState/rewardsProvenance")
            }
            Self::QueryLedgerStateStakePools => write!(f, "queryLedgerState/stakePools"),
            Self::QueryLedgerStateUtxo => write!(f, "queryLedgerState/utxo"),
            Self::QueryLedgerStateTip => write!(f, "queryLedgerState/tip"),
            Self::QueryLedgerStateTreasuryAndReserves => {
                write!(f, "queryLedgerState/treasuryAndReserves")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateAcquiredExpiredMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitution" => Ok(Self::QueryLedgerStateConstitution),
            "queryLedgerState/constitutionalCommittee" => {
                Ok(Self::QueryLedgerStateConstitutionalCommittee)
            }
            "queryLedgerState/delegateRepresentatives" => {
                Ok(Self::QueryLedgerStateDelegateRepresentatives)
            }
            "queryLedgerState/epoch" => Ok(Self::QueryLedgerStateEpoch),
            "queryLedgerState/eraStart" => Ok(Self::QueryLedgerStateEraStart),
            "queryLedgerState/eraSummaries" => Ok(Self::QueryLedgerStateEraSummaries),
            "queryLedgerState/governanceProposals" => Ok(Self::QueryLedgerStateGovernanceProposals),
            "queryLedgerState/liveStakeDistribution" => {
                Ok(Self::QueryLedgerStateLiveStakeDistribution)
            }
            "queryLedgerState/projectedRewards" => Ok(Self::QueryLedgerStateProjectedRewards),
            "queryLedgerState/protocolParameters" => Ok(Self::QueryLedgerStateProtocolParameters),
            "queryLedgerState/proposedProtocolParameters" => {
                Ok(Self::QueryLedgerStateProposedProtocolParameters)
            }
            "queryLedgerState/rewardAccountSummaries" => {
                Ok(Self::QueryLedgerStateRewardAccountSummaries)
            }
            "queryLedgerState/rewardsProvenance" => Ok(Self::QueryLedgerStateRewardsProvenance),
            "queryLedgerState/stakePools" => Ok(Self::QueryLedgerStateStakePools),
            "queryLedgerState/utxo" => Ok(Self::QueryLedgerStateUtxo),
            "queryLedgerState/tip" => Ok(Self::QueryLedgerStateTip),
            "queryLedgerState/treasuryAndReserves" => Ok(Self::QueryLedgerStateTreasuryAndReserves),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateAcquiredExpiredMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateAcquiredExpiredMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateAcquiredExpiredMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current constitution definition (only available from Conway onwards)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateConstitution\","]
#[doc = "  \"description\": \"Query the current constitution definition (only available from Conway onwards).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/constitution\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateConstitution {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateConstitutionJsonrpc,
    pub method: QueryLedgerStateConstitutionMethod,
}
impl ::std::convert::From<&QueryLedgerStateConstitution> for QueryLedgerStateConstitution {
    fn from(value: &QueryLedgerStateConstitution) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateConstitutionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionJsonrpc {
    fn from(value: &QueryLedgerStateConstitutionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateConstitutionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateConstitutionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitution\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionMethod {
    #[serde(rename = "queryLedgerState/constitution")]
    QueryLedgerStateConstitution,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionMethod {
    fn from(value: &QueryLedgerStateConstitutionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitution => write!(f, "queryLedgerState/constitution"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitution" => Ok(Self::QueryLedgerStateConstitution),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateConstitutionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateConstitutionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionResponseJsonrpc {
    fn from(value: &QueryLedgerStateConstitutionResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateConstitutionResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitution\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionResponseMethod {
    #[serde(rename = "queryLedgerState/constitution")]
    QueryLedgerStateConstitution,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionResponseMethod {
    fn from(value: &QueryLedgerStateConstitutionResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitution => write!(f, "queryLedgerState/constitution"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitution" => Ok(Self::QueryLedgerStateConstitution),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateConstitutionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Get the state of the constitutional committee (only available from Conway onwards)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateConstitutionalCommittee\","]
#[doc = "  \"description\": \"Get the state of the constitutional committee (only available from Conway onwards).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/constitutionalCommittee\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateConstitutionalCommittee {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateConstitutionalCommitteeJsonrpc,
    pub method: QueryLedgerStateConstitutionalCommitteeMethod,
}
impl ::std::convert::From<&QueryLedgerStateConstitutionalCommittee>
    for QueryLedgerStateConstitutionalCommittee
{
    fn from(value: &QueryLedgerStateConstitutionalCommittee) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateConstitutionalCommitteeJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionalCommitteeJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionalCommitteeJsonrpc {
    fn from(value: &QueryLedgerStateConstitutionalCommitteeJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionalCommitteeJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionalCommitteeJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionalCommitteeJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionalCommitteeMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitutionalCommittee\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionalCommitteeMethod {
    #[serde(rename = "queryLedgerState/constitutionalCommittee")]
    QueryLedgerStateConstitutionalCommittee,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionalCommitteeMethod {
    fn from(value: &QueryLedgerStateConstitutionalCommitteeMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionalCommitteeMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitutionalCommittee => {
                write!(f, "queryLedgerState/constitutionalCommittee")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionalCommitteeMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitutionalCommittee" => {
                Ok(Self::QueryLedgerStateConstitutionalCommittee)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionalCommitteeMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionalCommitteeResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionalCommitteeResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc {
    fn from(value: &QueryLedgerStateConstitutionalCommitteeResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionalCommitteeResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitutionalCommittee\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateConstitutionalCommitteeResponseMethod {
    #[serde(rename = "queryLedgerState/constitutionalCommittee")]
    QueryLedgerStateConstitutionalCommittee,
}
impl ::std::convert::From<&Self> for QueryLedgerStateConstitutionalCommitteeResponseMethod {
    fn from(value: &QueryLedgerStateConstitutionalCommitteeResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateConstitutionalCommitteeResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitutionalCommittee => {
                write!(f, "queryLedgerState/constitutionalCommittee")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateConstitutionalCommitteeResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitutionalCommittee" => {
                Ok(Self::QueryLedgerStateConstitutionalCommittee)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateConstitutionalCommitteeResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateConstitutionalCommitteeResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateConstitutionalCommitteeResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"members\","]
#[doc = "    \"quorum\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"members\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ConstitutionalCommitteeMember\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"quorum\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateConstitutionalCommitteeResponseResult {
    pub members: ::std::vec::Vec<ConstitutionalCommitteeMember>,
    pub quorum: ::std::option::Option<Ratio>,
}
impl ::std::convert::From<&QueryLedgerStateConstitutionalCommitteeResponseResult>
    for QueryLedgerStateConstitutionalCommitteeResponseResult
{
    fn from(value: &QueryLedgerStateConstitutionalCommitteeResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "Query currently registered delegate representatives, their stake (i.e. voting powers) and metadata about them. Note that 'params' is optional and can be used to filter out delegates. When omitted, ALL delegates are returned. Pre-defined options (always abstain and always no confidence) are ALWAYS returned."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateDelegateRepresentatives\","]
#[doc = "  \"description\": \"Query currently registered delegate representatives, their stake (i.e. voting powers) and metadata about them. Note that 'params' is optional and can be used to filter out delegates. When omitted, ALL delegates are returned. Pre-defined options (always abstain and always no confidence) are ALWAYS returned.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/delegateRepresentatives\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"keys\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"scripts\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateDelegateRepresentatives {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateDelegateRepresentativesJsonrpc,
    pub method: QueryLedgerStateDelegateRepresentativesMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<QueryLedgerStateDelegateRepresentativesParams>,
}
impl ::std::convert::From<&QueryLedgerStateDelegateRepresentatives>
    for QueryLedgerStateDelegateRepresentatives
{
    fn from(value: &QueryLedgerStateDelegateRepresentatives) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateDelegateRepresentativesJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDelegateRepresentativesJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDelegateRepresentativesJsonrpc {
    fn from(value: &QueryLedgerStateDelegateRepresentativesJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDelegateRepresentativesJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDelegateRepresentativesJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDelegateRepresentativesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateDelegateRepresentativesJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateDelegateRepresentativesJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDelegateRepresentativesMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/delegateRepresentatives\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDelegateRepresentativesMethod {
    #[serde(rename = "queryLedgerState/delegateRepresentatives")]
    QueryLedgerStateDelegateRepresentatives,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDelegateRepresentativesMethod {
    fn from(value: &QueryLedgerStateDelegateRepresentativesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDelegateRepresentativesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateDelegateRepresentatives => {
                write!(f, "queryLedgerState/delegateRepresentatives")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDelegateRepresentativesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/delegateRepresentatives" => {
                Ok(Self::QueryLedgerStateDelegateRepresentatives)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDelegateRepresentativesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateDelegateRepresentativesMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateDelegateRepresentativesMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDelegateRepresentativesParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"keys\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyDelegateRepresentativeCredential\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateDelegateRepresentativesParams {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub keys: ::std::vec::Vec<AnyDelegateRepresentativeCredential>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scripts: ::std::vec::Vec<AnyDelegateRepresentativeCredential>,
}
impl ::std::convert::From<&QueryLedgerStateDelegateRepresentativesParams>
    for QueryLedgerStateDelegateRepresentativesParams
{
    fn from(value: &QueryLedgerStateDelegateRepresentativesParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QueryLedgerStateDelegateRepresentativesParams {
    fn default() -> Self {
        Self {
            keys: Default::default(),
            scripts: Default::default(),
        }
    }
}
#[doc = "QueryLedgerStateDelegateRepresentativesResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDelegateRepresentativesResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDelegateRepresentativesResponseJsonrpc {
    fn from(value: &QueryLedgerStateDelegateRepresentativesResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDelegateRepresentativesResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDelegateRepresentativesResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDelegateRepresentativesResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateDelegateRepresentativesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateDelegateRepresentativesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDelegateRepresentativesResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/delegateRepresentatives\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDelegateRepresentativesResponseMethod {
    #[serde(rename = "queryLedgerState/delegateRepresentatives")]
    QueryLedgerStateDelegateRepresentatives,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDelegateRepresentativesResponseMethod {
    fn from(value: &QueryLedgerStateDelegateRepresentativesResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDelegateRepresentativesResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateDelegateRepresentatives => {
                write!(f, "queryLedgerState/delegateRepresentatives")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDelegateRepresentativesResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/delegateRepresentatives" => {
                Ok(Self::QueryLedgerStateDelegateRepresentatives)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDelegateRepresentativesResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateDelegateRepresentativesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateDelegateRepresentativesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Get a dump of the entire Cardano ledger state (base16-encoded CBOR) corresponding to the 'EpochState'. Use at your own risks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateDump\","]
#[doc = "  \"description\": \"Get a dump of the entire Cardano ledger state (base16-encoded CBOR) corresponding to the 'EpochState'. Use at your own risks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/dump\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateDump {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateDumpJsonrpc,
    pub method: QueryLedgerStateDumpMethod,
}
impl ::std::convert::From<&QueryLedgerStateDump> for QueryLedgerStateDump {
    fn from(value: &QueryLedgerStateDump) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateDumpJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDumpJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDumpJsonrpc {
    fn from(value: &QueryLedgerStateDumpJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDumpJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDumpJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDumpJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateDumpJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateDumpJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDumpMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/dump\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDumpMethod {
    #[serde(rename = "queryLedgerState/dump")]
    QueryLedgerStateDump,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDumpMethod {
    fn from(value: &QueryLedgerStateDumpMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDumpMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateDump => write!(f, "queryLedgerState/dump"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDumpMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/dump" => Ok(Self::QueryLedgerStateDump),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDumpMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateDumpMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateDumpMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDumpResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDumpResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDumpResponseJsonrpc {
    fn from(value: &QueryLedgerStateDumpResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDumpResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDumpResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDumpResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateDumpResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateDumpResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateDumpResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/dump\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateDumpResponseMethod {
    #[serde(rename = "queryLedgerState/dump")]
    QueryLedgerStateDump,
}
impl ::std::convert::From<&Self> for QueryLedgerStateDumpResponseMethod {
    fn from(value: &QueryLedgerStateDumpResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateDumpResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateDump => write!(f, "queryLedgerState/dump"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateDumpResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/dump" => Ok(Self::QueryLedgerStateDump),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateDumpResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateDumpResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateDumpResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current epoch number the ledger is at."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateEpoch\","]
#[doc = "  \"description\": \"Query the current epoch number the ledger is at.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/epoch\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateEpoch {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateEpochJsonrpc,
    pub method: QueryLedgerStateEpochMethod,
}
impl ::std::convert::From<&QueryLedgerStateEpoch> for QueryLedgerStateEpoch {
    fn from(value: &QueryLedgerStateEpoch) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateEpochJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEpochJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEpochJsonrpc {
    fn from(value: &QueryLedgerStateEpochJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEpochJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEpochJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEpochJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEpochJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEpochJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEpochMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/epoch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEpochMethod {
    #[serde(rename = "queryLedgerState/epoch")]
    QueryLedgerStateEpoch,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEpochMethod {
    fn from(value: &QueryLedgerStateEpochMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEpochMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEpoch => write!(f, "queryLedgerState/epoch"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEpochMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/epoch" => Ok(Self::QueryLedgerStateEpoch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEpochMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEpochMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEpochMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEpochResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEpochResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEpochResponseJsonrpc {
    fn from(value: &QueryLedgerStateEpochResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEpochResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEpochResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEpochResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEpochResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEpochResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEpochResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/epoch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEpochResponseMethod {
    #[serde(rename = "queryLedgerState/epoch")]
    QueryLedgerStateEpoch,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEpochResponseMethod {
    fn from(value: &QueryLedgerStateEpochResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEpochResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEpoch => write!(f, "queryLedgerState/epoch"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEpochResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/epoch" => Ok(Self::QueryLedgerStateEpoch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEpochResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEpochResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEpochResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraMismatch"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateEraMismatch\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            2001"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"$ref\": \"#/definitions/EraMismatch\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/constitution\","]
#[doc = "        \"queryLedgerState/constitutionalCommittee\","]
#[doc = "        \"queryLedgerState/delegateRepresentatives\","]
#[doc = "        \"queryLedgerState/epoch\","]
#[doc = "        \"queryLedgerState/eraStart\","]
#[doc = "        \"queryLedgerState/eraSummaries\","]
#[doc = "        \"queryLedgerState/governanceProposals\","]
#[doc = "        \"queryLedgerState/liveStakeDistribution\","]
#[doc = "        \"queryLedgerState/projectedRewards\","]
#[doc = "        \"queryLedgerState/protocolParameters\","]
#[doc = "        \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "        \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "        \"queryLedgerState/rewardsProvenance\","]
#[doc = "        \"queryLedgerState/stakePools\","]
#[doc = "        \"queryLedgerState/utxo\","]
#[doc = "        \"queryLedgerState/tip\","]
#[doc = "        \"queryLedgerState/treasuryAndReserves\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateEraMismatch {
    pub error: QueryLedgerStateEraMismatchError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateEraMismatchJsonrpc,
    pub method: QueryLedgerStateEraMismatchMethod,
}
impl ::std::convert::From<&QueryLedgerStateEraMismatch> for QueryLedgerStateEraMismatch {
    fn from(value: &QueryLedgerStateEraMismatch) -> Self {
        value.clone()
    }
}
#[doc = "An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An era mismatch between a client request and the era the ledger is in. This may occur when running queries on a syncing node and/or when the node is crossing an era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        2001"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"$ref\": \"#/definitions/EraMismatch\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateEraMismatchError {
    pub code: QueryLedgerStateEraMismatchErrorCode,
    pub data: EraMismatch,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&QueryLedgerStateEraMismatchError> for QueryLedgerStateEraMismatchError {
    fn from(value: &QueryLedgerStateEraMismatchError) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateEraMismatchErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    2001"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct QueryLedgerStateEraMismatchErrorCode(i64);
impl ::std::ops::Deref for QueryLedgerStateEraMismatchErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<QueryLedgerStateEraMismatchErrorCode> for i64 {
    fn from(value: QueryLedgerStateEraMismatchErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&QueryLedgerStateEraMismatchErrorCode>
    for QueryLedgerStateEraMismatchErrorCode
{
    fn from(value: &QueryLedgerStateEraMismatchErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for QueryLedgerStateEraMismatchErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2001_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for QueryLedgerStateEraMismatchErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "QueryLedgerStateEraMismatchJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraMismatchJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraMismatchJsonrpc {
    fn from(value: &QueryLedgerStateEraMismatchJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraMismatchJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraMismatchJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraMismatchJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraMismatchJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraMismatchJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraMismatchMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitution\","]
#[doc = "    \"queryLedgerState/constitutionalCommittee\","]
#[doc = "    \"queryLedgerState/delegateRepresentatives\","]
#[doc = "    \"queryLedgerState/epoch\","]
#[doc = "    \"queryLedgerState/eraStart\","]
#[doc = "    \"queryLedgerState/eraSummaries\","]
#[doc = "    \"queryLedgerState/governanceProposals\","]
#[doc = "    \"queryLedgerState/liveStakeDistribution\","]
#[doc = "    \"queryLedgerState/projectedRewards\","]
#[doc = "    \"queryLedgerState/protocolParameters\","]
#[doc = "    \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "    \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "    \"queryLedgerState/rewardsProvenance\","]
#[doc = "    \"queryLedgerState/stakePools\","]
#[doc = "    \"queryLedgerState/utxo\","]
#[doc = "    \"queryLedgerState/tip\","]
#[doc = "    \"queryLedgerState/treasuryAndReserves\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraMismatchMethod {
    #[serde(rename = "queryLedgerState/constitution")]
    QueryLedgerStateConstitution,
    #[serde(rename = "queryLedgerState/constitutionalCommittee")]
    QueryLedgerStateConstitutionalCommittee,
    #[serde(rename = "queryLedgerState/delegateRepresentatives")]
    QueryLedgerStateDelegateRepresentatives,
    #[serde(rename = "queryLedgerState/epoch")]
    QueryLedgerStateEpoch,
    #[serde(rename = "queryLedgerState/eraStart")]
    QueryLedgerStateEraStart,
    #[serde(rename = "queryLedgerState/eraSummaries")]
    QueryLedgerStateEraSummaries,
    #[serde(rename = "queryLedgerState/governanceProposals")]
    QueryLedgerStateGovernanceProposals,
    #[serde(rename = "queryLedgerState/liveStakeDistribution")]
    QueryLedgerStateLiveStakeDistribution,
    #[serde(rename = "queryLedgerState/projectedRewards")]
    QueryLedgerStateProjectedRewards,
    #[serde(rename = "queryLedgerState/protocolParameters")]
    QueryLedgerStateProtocolParameters,
    #[serde(rename = "queryLedgerState/proposedProtocolParameters")]
    QueryLedgerStateProposedProtocolParameters,
    #[serde(rename = "queryLedgerState/rewardAccountSummaries")]
    QueryLedgerStateRewardAccountSummaries,
    #[serde(rename = "queryLedgerState/rewardsProvenance")]
    QueryLedgerStateRewardsProvenance,
    #[serde(rename = "queryLedgerState/stakePools")]
    QueryLedgerStateStakePools,
    #[serde(rename = "queryLedgerState/utxo")]
    QueryLedgerStateUtxo,
    #[serde(rename = "queryLedgerState/tip")]
    QueryLedgerStateTip,
    #[serde(rename = "queryLedgerState/treasuryAndReserves")]
    QueryLedgerStateTreasuryAndReserves,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraMismatchMethod {
    fn from(value: &QueryLedgerStateEraMismatchMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraMismatchMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitution => write!(f, "queryLedgerState/constitution"),
            Self::QueryLedgerStateConstitutionalCommittee => {
                write!(f, "queryLedgerState/constitutionalCommittee")
            }
            Self::QueryLedgerStateDelegateRepresentatives => {
                write!(f, "queryLedgerState/delegateRepresentatives")
            }
            Self::QueryLedgerStateEpoch => write!(f, "queryLedgerState/epoch"),
            Self::QueryLedgerStateEraStart => write!(f, "queryLedgerState/eraStart"),
            Self::QueryLedgerStateEraSummaries => write!(f, "queryLedgerState/eraSummaries"),
            Self::QueryLedgerStateGovernanceProposals => {
                write!(f, "queryLedgerState/governanceProposals")
            }
            Self::QueryLedgerStateLiveStakeDistribution => {
                write!(f, "queryLedgerState/liveStakeDistribution")
            }
            Self::QueryLedgerStateProjectedRewards => {
                write!(f, "queryLedgerState/projectedRewards")
            }
            Self::QueryLedgerStateProtocolParameters => {
                write!(f, "queryLedgerState/protocolParameters")
            }
            Self::QueryLedgerStateProposedProtocolParameters => {
                write!(f, "queryLedgerState/proposedProtocolParameters")
            }
            Self::QueryLedgerStateRewardAccountSummaries => {
                write!(f, "queryLedgerState/rewardAccountSummaries")
            }
            Self::QueryLedgerStateRewardsProvenance => {
                write!(f, "queryLedgerState/rewardsProvenance")
            }
            Self::QueryLedgerStateStakePools => write!(f, "queryLedgerState/stakePools"),
            Self::QueryLedgerStateUtxo => write!(f, "queryLedgerState/utxo"),
            Self::QueryLedgerStateTip => write!(f, "queryLedgerState/tip"),
            Self::QueryLedgerStateTreasuryAndReserves => {
                write!(f, "queryLedgerState/treasuryAndReserves")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraMismatchMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitution" => Ok(Self::QueryLedgerStateConstitution),
            "queryLedgerState/constitutionalCommittee" => {
                Ok(Self::QueryLedgerStateConstitutionalCommittee)
            }
            "queryLedgerState/delegateRepresentatives" => {
                Ok(Self::QueryLedgerStateDelegateRepresentatives)
            }
            "queryLedgerState/epoch" => Ok(Self::QueryLedgerStateEpoch),
            "queryLedgerState/eraStart" => Ok(Self::QueryLedgerStateEraStart),
            "queryLedgerState/eraSummaries" => Ok(Self::QueryLedgerStateEraSummaries),
            "queryLedgerState/governanceProposals" => Ok(Self::QueryLedgerStateGovernanceProposals),
            "queryLedgerState/liveStakeDistribution" => {
                Ok(Self::QueryLedgerStateLiveStakeDistribution)
            }
            "queryLedgerState/projectedRewards" => Ok(Self::QueryLedgerStateProjectedRewards),
            "queryLedgerState/protocolParameters" => Ok(Self::QueryLedgerStateProtocolParameters),
            "queryLedgerState/proposedProtocolParameters" => {
                Ok(Self::QueryLedgerStateProposedProtocolParameters)
            }
            "queryLedgerState/rewardAccountSummaries" => {
                Ok(Self::QueryLedgerStateRewardAccountSummaries)
            }
            "queryLedgerState/rewardsProvenance" => Ok(Self::QueryLedgerStateRewardsProvenance),
            "queryLedgerState/stakePools" => Ok(Self::QueryLedgerStateStakePools),
            "queryLedgerState/utxo" => Ok(Self::QueryLedgerStateUtxo),
            "queryLedgerState/tip" => Ok(Self::QueryLedgerStateTip),
            "queryLedgerState/treasuryAndReserves" => Ok(Self::QueryLedgerStateTreasuryAndReserves),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraMismatchMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraMismatchMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraMismatchMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the start of the current ledger era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateEraStart\","]
#[doc = "  \"description\": \"Query the start of the current ledger era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/eraStart\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateEraStart {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateEraStartJsonrpc,
    pub method: QueryLedgerStateEraStartMethod,
}
impl ::std::convert::From<&QueryLedgerStateEraStart> for QueryLedgerStateEraStart {
    fn from(value: &QueryLedgerStateEraStart) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateEraStartJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraStartJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraStartJsonrpc {
    fn from(value: &QueryLedgerStateEraStartJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraStartJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraStartJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraStartJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraStartJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraStartJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraStartMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/eraStart\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraStartMethod {
    #[serde(rename = "queryLedgerState/eraStart")]
    QueryLedgerStateEraStart,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraStartMethod {
    fn from(value: &QueryLedgerStateEraStartMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraStartMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEraStart => write!(f, "queryLedgerState/eraStart"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraStartMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/eraStart" => Ok(Self::QueryLedgerStateEraStart),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraStartMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraStartResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraStartResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraStartResponseJsonrpc {
    fn from(value: &QueryLedgerStateEraStartResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraStartResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraStartResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraStartResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraStartResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraStartResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraStartResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/eraStart\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraStartResponseMethod {
    #[serde(rename = "queryLedgerState/eraStart")]
    QueryLedgerStateEraStart,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraStartResponseMethod {
    fn from(value: &QueryLedgerStateEraStartResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraStartResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEraStart => write!(f, "queryLedgerState/eraStart"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraStartResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/eraStart" => Ok(Self::QueryLedgerStateEraStart),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraStartResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraStartResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraStartResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateEraSummaries\","]
#[doc = "  \"description\": \"Query a summary of the slotting parameters and boundaries for each known era. Useful for doing slot-arithmetic and time conversions.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/eraSummaries\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateEraSummaries {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateEraSummariesJsonrpc,
    pub method: QueryLedgerStateEraSummariesMethod,
}
impl ::std::convert::From<&QueryLedgerStateEraSummaries> for QueryLedgerStateEraSummaries {
    fn from(value: &QueryLedgerStateEraSummaries) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateEraSummariesJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraSummariesJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraSummariesJsonrpc {
    fn from(value: &QueryLedgerStateEraSummariesJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraSummariesJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraSummariesJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraSummariesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraSummariesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraSummariesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraSummariesMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/eraSummaries\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraSummariesMethod {
    #[serde(rename = "queryLedgerState/eraSummaries")]
    QueryLedgerStateEraSummaries,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraSummariesMethod {
    fn from(value: &QueryLedgerStateEraSummariesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraSummariesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEraSummaries => write!(f, "queryLedgerState/eraSummaries"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraSummariesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/eraSummaries" => Ok(Self::QueryLedgerStateEraSummaries),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraSummariesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateEraSummariesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraSummariesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraSummariesResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraSummariesResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraSummariesResponseJsonrpc {
    fn from(value: &QueryLedgerStateEraSummariesResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraSummariesResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraSummariesResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraSummariesResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateEraSummariesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateEraSummariesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateEraSummariesResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/eraSummaries\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateEraSummariesResponseMethod {
    #[serde(rename = "queryLedgerState/eraSummaries")]
    QueryLedgerStateEraSummaries,
}
impl ::std::convert::From<&Self> for QueryLedgerStateEraSummariesResponseMethod {
    fn from(value: &QueryLedgerStateEraSummariesResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateEraSummariesResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateEraSummaries => write!(f, "queryLedgerState/eraSummaries"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateEraSummariesResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/eraSummaries" => Ok(Self::QueryLedgerStateEraSummaries),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateEraSummariesResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateEraSummariesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateEraSummariesResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query currently active governance proposals, optionally restricted to specific governance proposal references."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateGovernanceProposals\","]
#[doc = "  \"description\": \"Query currently active governance proposals, optionally restricted to specific governance proposal references.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/governanceProposals\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"GovernanceProposalsByReferences\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"proposals\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"proposals\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"WholeGovernanceProposals\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateGovernanceProposals {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateGovernanceProposalsJsonrpc,
    pub method: QueryLedgerStateGovernanceProposalsMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<QueryLedgerStateGovernanceProposalsParams>,
}
impl ::std::convert::From<&QueryLedgerStateGovernanceProposals>
    for QueryLedgerStateGovernanceProposals
{
    fn from(value: &QueryLedgerStateGovernanceProposals) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateGovernanceProposalsJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateGovernanceProposalsJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateGovernanceProposalsJsonrpc {
    fn from(value: &QueryLedgerStateGovernanceProposalsJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateGovernanceProposalsJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateGovernanceProposalsJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateGovernanceProposalsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateGovernanceProposalsJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateGovernanceProposalsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateGovernanceProposalsMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/governanceProposals\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateGovernanceProposalsMethod {
    #[serde(rename = "queryLedgerState/governanceProposals")]
    QueryLedgerStateGovernanceProposals,
}
impl ::std::convert::From<&Self> for QueryLedgerStateGovernanceProposalsMethod {
    fn from(value: &QueryLedgerStateGovernanceProposalsMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateGovernanceProposalsMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateGovernanceProposals => {
                write!(f, "queryLedgerState/governanceProposals")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateGovernanceProposalsMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/governanceProposals" => Ok(Self::QueryLedgerStateGovernanceProposals),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateGovernanceProposalsMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateGovernanceProposalsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateGovernanceProposalsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateGovernanceProposalsParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"GovernanceProposalsByReferences\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"proposals\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"proposals\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"WholeGovernanceProposals\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum QueryLedgerStateGovernanceProposalsParams {
    GovernanceProposalsByReferences {
        proposals: ::std::vec::Vec<GovernanceProposalReference>,
    },
    WholeGovernanceProposals {},
}
impl ::std::convert::From<&Self> for QueryLedgerStateGovernanceProposalsParams {
    fn from(value: &QueryLedgerStateGovernanceProposalsParams) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateGovernanceProposalsResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateGovernanceProposalsResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateGovernanceProposalsResponseJsonrpc {
    fn from(value: &QueryLedgerStateGovernanceProposalsResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateGovernanceProposalsResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateGovernanceProposalsResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateGovernanceProposalsResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateGovernanceProposalsResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateGovernanceProposalsResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateGovernanceProposalsResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/governanceProposals\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateGovernanceProposalsResponseMethod {
    #[serde(rename = "queryLedgerState/governanceProposals")]
    QueryLedgerStateGovernanceProposals,
}
impl ::std::convert::From<&Self> for QueryLedgerStateGovernanceProposalsResponseMethod {
    fn from(value: &QueryLedgerStateGovernanceProposalsResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateGovernanceProposalsResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateGovernanceProposals => {
                write!(f, "queryLedgerState/governanceProposals")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateGovernanceProposalsResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/governanceProposals" => Ok(Self::QueryLedgerStateGovernanceProposals),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateGovernanceProposalsResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateGovernanceProposalsResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateGovernanceProposalsResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateLiveStakeDistribution\","]
#[doc = "  \"description\": \"Query the current distribution of the stake across all known stake pools, relative to the TOTAL stake in the network.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/liveStakeDistribution\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateLiveStakeDistribution {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateLiveStakeDistributionJsonrpc,
    pub method: QueryLedgerStateLiveStakeDistributionMethod,
}
impl ::std::convert::From<&QueryLedgerStateLiveStakeDistribution>
    for QueryLedgerStateLiveStakeDistribution
{
    fn from(value: &QueryLedgerStateLiveStakeDistribution) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateLiveStakeDistributionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateLiveStakeDistributionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateLiveStakeDistributionJsonrpc {
    fn from(value: &QueryLedgerStateLiveStakeDistributionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateLiveStakeDistributionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateLiveStakeDistributionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateLiveStakeDistributionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateLiveStakeDistributionJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateLiveStakeDistributionJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateLiveStakeDistributionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/liveStakeDistribution\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateLiveStakeDistributionMethod {
    #[serde(rename = "queryLedgerState/liveStakeDistribution")]
    QueryLedgerStateLiveStakeDistribution,
}
impl ::std::convert::From<&Self> for QueryLedgerStateLiveStakeDistributionMethod {
    fn from(value: &QueryLedgerStateLiveStakeDistributionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateLiveStakeDistributionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateLiveStakeDistribution => {
                write!(f, "queryLedgerState/liveStakeDistribution")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateLiveStakeDistributionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/liveStakeDistribution" => {
                Ok(Self::QueryLedgerStateLiveStakeDistribution)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateLiveStakeDistributionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateLiveStakeDistributionMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateLiveStakeDistributionMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateLiveStakeDistributionResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateLiveStakeDistributionResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateLiveStakeDistributionResponseJsonrpc {
    fn from(value: &QueryLedgerStateLiveStakeDistributionResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateLiveStakeDistributionResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateLiveStakeDistributionResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateLiveStakeDistributionResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateLiveStakeDistributionResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateLiveStakeDistributionResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateLiveStakeDistributionResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/liveStakeDistribution\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateLiveStakeDistributionResponseMethod {
    #[serde(rename = "queryLedgerState/liveStakeDistribution")]
    QueryLedgerStateLiveStakeDistribution,
}
impl ::std::convert::From<&Self> for QueryLedgerStateLiveStakeDistributionResponseMethod {
    fn from(value: &QueryLedgerStateLiveStakeDistributionResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateLiveStakeDistributionResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateLiveStakeDistribution => {
                write!(f, "queryLedgerState/liveStakeDistribution")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateLiveStakeDistributionResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/liveStakeDistribution" => {
                Ok(Self::QueryLedgerStateLiveStakeDistribution)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateLiveStakeDistributionResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateLiveStakeDistributionResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateLiveStakeDistributionResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateProjectedRewards\","]
#[doc = "  \"description\": \"Query the projected rewards of an account in a context where the top stake pools are fully saturated. This projection gives, in principle, a ranking of stake pools that maximizes delegator rewards.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/projectedRewards\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"keys\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"scripts\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"stake\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateProjectedRewards {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateProjectedRewardsJsonrpc,
    pub method: QueryLedgerStateProjectedRewardsMethod,
    pub params: QueryLedgerStateProjectedRewardsParams,
}
impl ::std::convert::From<&QueryLedgerStateProjectedRewards> for QueryLedgerStateProjectedRewards {
    fn from(value: &QueryLedgerStateProjectedRewards) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateProjectedRewardsJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProjectedRewardsJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProjectedRewardsJsonrpc {
    fn from(value: &QueryLedgerStateProjectedRewardsJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProjectedRewardsJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProjectedRewardsJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProjectedRewardsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateProjectedRewardsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateProjectedRewardsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProjectedRewardsMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/projectedRewards\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProjectedRewardsMethod {
    #[serde(rename = "queryLedgerState/projectedRewards")]
    QueryLedgerStateProjectedRewards,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProjectedRewardsMethod {
    fn from(value: &QueryLedgerStateProjectedRewardsMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProjectedRewardsMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProjectedRewards => {
                write!(f, "queryLedgerState/projectedRewards")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProjectedRewardsMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/projectedRewards" => Ok(Self::QueryLedgerStateProjectedRewards),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProjectedRewardsMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateProjectedRewardsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateProjectedRewardsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProjectedRewardsParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"keys\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateProjectedRewardsParams {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub keys: ::std::vec::Vec<AnyStakeCredential>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scripts: ::std::vec::Vec<AnyStakeCredential>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub stake: ::std::vec::Vec<ValueAdaOnly>,
}
impl ::std::convert::From<&QueryLedgerStateProjectedRewardsParams>
    for QueryLedgerStateProjectedRewardsParams
{
    fn from(value: &QueryLedgerStateProjectedRewardsParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QueryLedgerStateProjectedRewardsParams {
    fn default() -> Self {
        Self {
            keys: Default::default(),
            scripts: Default::default(),
            stake: Default::default(),
        }
    }
}
#[doc = "QueryLedgerStateProjectedRewardsResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProjectedRewardsResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProjectedRewardsResponseJsonrpc {
    fn from(value: &QueryLedgerStateProjectedRewardsResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProjectedRewardsResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProjectedRewardsResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProjectedRewardsResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProjectedRewardsResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProjectedRewardsResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProjectedRewardsResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/projectedRewards\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProjectedRewardsResponseMethod {
    #[serde(rename = "queryLedgerState/projectedRewards")]
    QueryLedgerStateProjectedRewards,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProjectedRewardsResponseMethod {
    fn from(value: &QueryLedgerStateProjectedRewardsResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProjectedRewardsResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProjectedRewards => {
                write!(f, "queryLedgerState/projectedRewards")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProjectedRewardsResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/projectedRewards" => Ok(Self::QueryLedgerStateProjectedRewards),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProjectedRewardsResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProjectedRewardsResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProjectedRewardsResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the last update proposal w.r.t. protocol parameters, if any."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateProposedProtocolParameters\","]
#[doc = "  \"description\": \"Query the last update proposal w.r.t. protocol parameters, if any.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateProposedProtocolParameters {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateProposedProtocolParametersJsonrpc,
    pub method: QueryLedgerStateProposedProtocolParametersMethod,
}
impl ::std::convert::From<&QueryLedgerStateProposedProtocolParameters>
    for QueryLedgerStateProposedProtocolParameters
{
    fn from(value: &QueryLedgerStateProposedProtocolParameters) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateProposedProtocolParametersJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProposedProtocolParametersJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProposedProtocolParametersJsonrpc {
    fn from(value: &QueryLedgerStateProposedProtocolParametersJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProposedProtocolParametersJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProposedProtocolParametersJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProposedProtocolParametersJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProposedProtocolParametersJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProposedProtocolParametersJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProposedProtocolParametersMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProposedProtocolParametersMethod {
    #[serde(rename = "queryLedgerState/proposedProtocolParameters")]
    QueryLedgerStateProposedProtocolParameters,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProposedProtocolParametersMethod {
    fn from(value: &QueryLedgerStateProposedProtocolParametersMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProposedProtocolParametersMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProposedProtocolParameters => {
                write!(f, "queryLedgerState/proposedProtocolParameters")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProposedProtocolParametersMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/proposedProtocolParameters" => {
                Ok(Self::QueryLedgerStateProposedProtocolParameters)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProposedProtocolParametersMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProposedProtocolParametersMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProposedProtocolParametersMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProposedProtocolParametersResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProposedProtocolParametersResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProposedProtocolParametersResponseJsonrpc {
    fn from(value: &QueryLedgerStateProposedProtocolParametersResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProposedProtocolParametersResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProposedProtocolParametersResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProposedProtocolParametersResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProposedProtocolParametersResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProposedProtocolParametersResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProposedProtocolParametersResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/proposedProtocolParameters\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProposedProtocolParametersResponseMethod {
    #[serde(rename = "queryLedgerState/proposedProtocolParameters")]
    QueryLedgerStateProposedProtocolParameters,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProposedProtocolParametersResponseMethod {
    fn from(value: &QueryLedgerStateProposedProtocolParametersResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProposedProtocolParametersResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProposedProtocolParameters => {
                write!(f, "queryLedgerState/proposedProtocolParameters")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProposedProtocolParametersResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/proposedProtocolParameters" => {
                Ok(Self::QueryLedgerStateProposedProtocolParameters)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProposedProtocolParametersResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProposedProtocolParametersResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProposedProtocolParametersResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current protocol parameters."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateProtocolParameters\","]
#[doc = "  \"description\": \"Query the current protocol parameters.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/protocolParameters\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateProtocolParameters {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateProtocolParametersJsonrpc,
    pub method: QueryLedgerStateProtocolParametersMethod,
}
impl ::std::convert::From<&QueryLedgerStateProtocolParameters>
    for QueryLedgerStateProtocolParameters
{
    fn from(value: &QueryLedgerStateProtocolParameters) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateProtocolParametersJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProtocolParametersJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProtocolParametersJsonrpc {
    fn from(value: &QueryLedgerStateProtocolParametersJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProtocolParametersJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProtocolParametersJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProtocolParametersJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateProtocolParametersJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateProtocolParametersJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProtocolParametersMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/protocolParameters\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProtocolParametersMethod {
    #[serde(rename = "queryLedgerState/protocolParameters")]
    QueryLedgerStateProtocolParameters,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProtocolParametersMethod {
    fn from(value: &QueryLedgerStateProtocolParametersMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProtocolParametersMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProtocolParameters => {
                write!(f, "queryLedgerState/protocolParameters")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProtocolParametersMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/protocolParameters" => Ok(Self::QueryLedgerStateProtocolParameters),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProtocolParametersMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateProtocolParametersMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateProtocolParametersMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProtocolParametersResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProtocolParametersResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProtocolParametersResponseJsonrpc {
    fn from(value: &QueryLedgerStateProtocolParametersResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProtocolParametersResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProtocolParametersResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProtocolParametersResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProtocolParametersResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProtocolParametersResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateProtocolParametersResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/protocolParameters\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateProtocolParametersResponseMethod {
    #[serde(rename = "queryLedgerState/protocolParameters")]
    QueryLedgerStateProtocolParameters,
}
impl ::std::convert::From<&Self> for QueryLedgerStateProtocolParametersResponseMethod {
    fn from(value: &QueryLedgerStateProtocolParametersResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateProtocolParametersResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateProtocolParameters => {
                write!(f, "queryLedgerState/protocolParameters")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateProtocolParametersResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/protocolParameters" => Ok(Self::QueryLedgerStateProtocolParameters),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateProtocolParametersResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateProtocolParametersResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateProtocolParametersResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query current delegation settings and rewards of some given reward accounts."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateRewardAccountSummaries\","]
#[doc = "  \"description\": \"Query current delegation settings and rewards of some given reward accounts.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"keys\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"scripts\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateRewardAccountSummaries {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateRewardAccountSummariesJsonrpc,
    pub method: QueryLedgerStateRewardAccountSummariesMethod,
    pub params: QueryLedgerStateRewardAccountSummariesParams,
}
impl ::std::convert::From<&QueryLedgerStateRewardAccountSummaries>
    for QueryLedgerStateRewardAccountSummaries
{
    fn from(value: &QueryLedgerStateRewardAccountSummaries) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardAccountSummariesJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardAccountSummariesJsonrpc {
    fn from(value: &QueryLedgerStateRewardAccountSummariesJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardAccountSummariesJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardAccountSummariesJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardAccountSummariesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardAccountSummariesJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardAccountSummariesJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardAccountSummariesMethod {
    #[serde(rename = "queryLedgerState/rewardAccountSummaries")]
    QueryLedgerStateRewardAccountSummaries,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardAccountSummariesMethod {
    fn from(value: &QueryLedgerStateRewardAccountSummariesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardAccountSummariesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateRewardAccountSummaries => {
                write!(f, "queryLedgerState/rewardAccountSummaries")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardAccountSummariesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/rewardAccountSummaries" => {
                Ok(Self::QueryLedgerStateRewardAccountSummaries)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardAccountSummariesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardAccountSummariesMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardAccountSummariesMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"keys\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/AnyStakeCredential\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateRewardAccountSummariesParams {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub keys: ::std::vec::Vec<AnyStakeCredential>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scripts: ::std::vec::Vec<AnyStakeCredential>,
}
impl ::std::convert::From<&QueryLedgerStateRewardAccountSummariesParams>
    for QueryLedgerStateRewardAccountSummariesParams
{
    fn from(value: &QueryLedgerStateRewardAccountSummariesParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QueryLedgerStateRewardAccountSummariesParams {
    fn default() -> Self {
        Self {
            keys: Default::default(),
            scripts: Default::default(),
        }
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardAccountSummariesResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardAccountSummariesResponseJsonrpc {
    fn from(value: &QueryLedgerStateRewardAccountSummariesResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardAccountSummariesResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardAccountSummariesResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardAccountSummariesResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/rewardAccountSummaries\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardAccountSummariesResponseMethod {
    #[serde(rename = "queryLedgerState/rewardAccountSummaries")]
    QueryLedgerStateRewardAccountSummaries,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardAccountSummariesResponseMethod {
    fn from(value: &QueryLedgerStateRewardAccountSummariesResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardAccountSummariesResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateRewardAccountSummaries => {
                write!(f, "queryLedgerState/rewardAccountSummaries")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardAccountSummariesResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/rewardAccountSummaries" => {
                Ok(Self::QueryLedgerStateRewardAccountSummaries)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardAccountSummariesResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardAccountSummariesResponseResultKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9]+|[0-9a-f]+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct QueryLedgerStateRewardAccountSummariesResponseResultKey(::std::string::String);
impl ::std::ops::Deref for QueryLedgerStateRewardAccountSummariesResponseResultKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<QueryLedgerStateRewardAccountSummariesResponseResultKey>
    for ::std::string::String
{
    fn from(value: QueryLedgerStateRewardAccountSummariesResponseResultKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&QueryLedgerStateRewardAccountSummariesResponseResultKey>
    for QueryLedgerStateRewardAccountSummariesResponseResultKey
{
    fn from(value: &QueryLedgerStateRewardAccountSummariesResponseResultKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardAccountSummariesResponseResultKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9]+|[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9]+|[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardAccountSummariesResponseResultKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseResultKey
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardAccountSummariesResponseResultKey
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for QueryLedgerStateRewardAccountSummariesResponseResultKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Query details about rewards calculation for the ongoing epoch."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateRewardsProvenance\","]
#[doc = "  \"description\": \"Query details about rewards calculation for the ongoing epoch.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/rewardsProvenance\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateRewardsProvenance {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateRewardsProvenanceJsonrpc,
    pub method: QueryLedgerStateRewardsProvenanceMethod,
}
impl ::std::convert::From<&QueryLedgerStateRewardsProvenance>
    for QueryLedgerStateRewardsProvenance
{
    fn from(value: &QueryLedgerStateRewardsProvenance) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateRewardsProvenanceJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardsProvenanceJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardsProvenanceJsonrpc {
    fn from(value: &QueryLedgerStateRewardsProvenanceJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardsProvenanceJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardsProvenanceJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardsProvenanceJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateRewardsProvenanceJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateRewardsProvenanceJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardsProvenanceMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/rewardsProvenance\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardsProvenanceMethod {
    #[serde(rename = "queryLedgerState/rewardsProvenance")]
    QueryLedgerStateRewardsProvenance,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardsProvenanceMethod {
    fn from(value: &QueryLedgerStateRewardsProvenanceMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardsProvenanceMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateRewardsProvenance => {
                write!(f, "queryLedgerState/rewardsProvenance")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardsProvenanceMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/rewardsProvenance" => Ok(Self::QueryLedgerStateRewardsProvenance),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardsProvenanceMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateRewardsProvenanceMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateRewardsProvenanceMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardsProvenanceResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardsProvenanceResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardsProvenanceResponseJsonrpc {
    fn from(value: &QueryLedgerStateRewardsProvenanceResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardsProvenanceResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardsProvenanceResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardsProvenanceResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardsProvenanceResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardsProvenanceResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateRewardsProvenanceResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/rewardsProvenance\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateRewardsProvenanceResponseMethod {
    #[serde(rename = "queryLedgerState/rewardsProvenance")]
    QueryLedgerStateRewardsProvenance,
}
impl ::std::convert::From<&Self> for QueryLedgerStateRewardsProvenanceResponseMethod {
    fn from(value: &QueryLedgerStateRewardsProvenanceResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateRewardsProvenanceResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateRewardsProvenance => {
                write!(f, "queryLedgerState/rewardsProvenance")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateRewardsProvenanceResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/rewardsProvenance" => Ok(Self::QueryLedgerStateRewardsProvenance),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateRewardsProvenanceResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateRewardsProvenanceResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateRewardsProvenanceResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the list of all stake pools currently registered and active, optionally filtered by ids."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateStakePools\","]
#[doc = "  \"description\": \"Query the list of all stake pools currently registered and active, optionally filtered by ids.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/stakePools\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"includeStake\": {"]
#[doc = "          \"description\": \"When provided and set to 'true', the result will also include the live stake associated to each pool. This may take some additional time the first time this is queried within an epoch.\","]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"stakePools\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"id\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"id\": {"]
#[doc = "                \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateStakePools {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateStakePoolsJsonrpc,
    pub method: QueryLedgerStateStakePoolsMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<QueryLedgerStateStakePoolsParams>,
}
impl ::std::convert::From<&QueryLedgerStateStakePools> for QueryLedgerStateStakePools {
    fn from(value: &QueryLedgerStateStakePools) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateStakePoolsJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateStakePoolsJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateStakePoolsJsonrpc {
    fn from(value: &QueryLedgerStateStakePoolsJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateStakePoolsJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateStakePoolsJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateStakePoolsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateStakePoolsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateStakePoolsJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateStakePoolsMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/stakePools\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateStakePoolsMethod {
    #[serde(rename = "queryLedgerState/stakePools")]
    QueryLedgerStateStakePools,
}
impl ::std::convert::From<&Self> for QueryLedgerStateStakePoolsMethod {
    fn from(value: &QueryLedgerStateStakePoolsMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateStakePoolsMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateStakePools => write!(f, "queryLedgerState/stakePools"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateStakePoolsMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/stakePools" => Ok(Self::QueryLedgerStateStakePools),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateStakePoolsMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateStakePoolsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateStakePoolsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateStakePoolsParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"includeStake\": {"]
#[doc = "      \"description\": \"When provided and set to 'true', the result will also include the live stake associated to each pool. This may take some additional time the first time this is queried within an epoch.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"stakePools\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateStakePoolsParams {
    #[doc = "When provided and set to 'true', the result will also include the live stake associated to each pool. This may take some additional time the first time this is queried within an epoch."]
    #[serde(
        rename = "includeStake",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub include_stake: ::std::option::Option<bool>,
    #[serde(
        rename = "stakePools",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub stake_pools: ::std::vec::Vec<QueryLedgerStateStakePoolsParamsStakePoolsItem>,
}
impl ::std::convert::From<&QueryLedgerStateStakePoolsParams> for QueryLedgerStateStakePoolsParams {
    fn from(value: &QueryLedgerStateStakePoolsParams) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QueryLedgerStateStakePoolsParams {
    fn default() -> Self {
        Self {
            include_stake: Default::default(),
            stake_pools: Default::default(),
        }
    }
}
#[doc = "QueryLedgerStateStakePoolsParamsStakePoolsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateStakePoolsParamsStakePoolsItem {
    pub id: StakePoolId,
}
impl ::std::convert::From<&QueryLedgerStateStakePoolsParamsStakePoolsItem>
    for QueryLedgerStateStakePoolsParamsStakePoolsItem
{
    fn from(value: &QueryLedgerStateStakePoolsParamsStakePoolsItem) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateStakePoolsResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateStakePoolsResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateStakePoolsResponseJsonrpc {
    fn from(value: &QueryLedgerStateStakePoolsResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateStakePoolsResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateStakePoolsResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateStakePoolsResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateStakePoolsResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateStakePoolsResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateStakePoolsResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/stakePools\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateStakePoolsResponseMethod {
    #[serde(rename = "queryLedgerState/stakePools")]
    QueryLedgerStateStakePools,
}
impl ::std::convert::From<&Self> for QueryLedgerStateStakePoolsResponseMethod {
    fn from(value: &QueryLedgerStateStakePoolsResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateStakePoolsResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateStakePools => write!(f, "queryLedgerState/stakePools"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateStakePoolsResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/stakePools" => Ok(Self::QueryLedgerStateStakePools),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateStakePoolsResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateStakePoolsResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateStakePoolsResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateTip\","]
#[doc = "  \"description\": \"Query the current tip the ledger is at. Said differently, the slot number and header hash of the last block that has been processed by the ledger.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/tip\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateTip {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateTipJsonrpc,
    pub method: QueryLedgerStateTipMethod,
}
impl ::std::convert::From<&QueryLedgerStateTip> for QueryLedgerStateTip {
    fn from(value: &QueryLedgerStateTip) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateTipJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTipJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTipJsonrpc {
    fn from(value: &QueryLedgerStateTipJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTipJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTipJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTipMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/tip\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTipMethod {
    #[serde(rename = "queryLedgerState/tip")]
    QueryLedgerStateTip,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTipMethod {
    fn from(value: &QueryLedgerStateTipMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTipMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateTip => write!(f, "queryLedgerState/tip"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTipMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/tip" => Ok(Self::QueryLedgerStateTip),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTipResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTipResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTipResponseJsonrpc {
    fn from(value: &QueryLedgerStateTipResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTipResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTipResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTipResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/tip\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTipResponseMethod {
    #[serde(rename = "queryLedgerState/tip")]
    QueryLedgerStateTip,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTipResponseMethod {
    fn from(value: &QueryLedgerStateTipResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTipResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateTip => write!(f, "queryLedgerState/tip"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTipResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/tip" => Ok(Self::QueryLedgerStateTip),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the Ada value of the treasury and reserves accounts."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateTreasuryAndReserves\","]
#[doc = "  \"description\": \"Query the Ada value of the treasury and reserves accounts.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/treasuryAndReserves\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateTreasuryAndReserves {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateTreasuryAndReservesJsonrpc,
    pub method: QueryLedgerStateTreasuryAndReservesMethod,
}
impl ::std::convert::From<&QueryLedgerStateTreasuryAndReserves>
    for QueryLedgerStateTreasuryAndReserves
{
    fn from(value: &QueryLedgerStateTreasuryAndReserves) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateTreasuryAndReservesJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTreasuryAndReservesJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTreasuryAndReservesJsonrpc {
    fn from(value: &QueryLedgerStateTreasuryAndReservesJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTreasuryAndReservesJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTreasuryAndReservesJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTreasuryAndReservesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateTreasuryAndReservesJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTreasuryAndReservesJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTreasuryAndReservesMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/treasuryAndReserves\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTreasuryAndReservesMethod {
    #[serde(rename = "queryLedgerState/treasuryAndReserves")]
    QueryLedgerStateTreasuryAndReserves,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTreasuryAndReservesMethod {
    fn from(value: &QueryLedgerStateTreasuryAndReservesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTreasuryAndReservesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateTreasuryAndReserves => {
                write!(f, "queryLedgerState/treasuryAndReserves")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTreasuryAndReservesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/treasuryAndReserves" => Ok(Self::QueryLedgerStateTreasuryAndReserves),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTreasuryAndReservesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateTreasuryAndReservesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateTreasuryAndReservesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTreasuryAndReservesResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTreasuryAndReservesResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTreasuryAndReservesResponseJsonrpc {
    fn from(value: &QueryLedgerStateTreasuryAndReservesResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTreasuryAndReservesResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTreasuryAndReservesResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTreasuryAndReservesResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateTreasuryAndReservesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateTreasuryAndReservesResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTreasuryAndReservesResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/treasuryAndReserves\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateTreasuryAndReservesResponseMethod {
    #[serde(rename = "queryLedgerState/treasuryAndReserves")]
    QueryLedgerStateTreasuryAndReserves,
}
impl ::std::convert::From<&Self> for QueryLedgerStateTreasuryAndReservesResponseMethod {
    fn from(value: &QueryLedgerStateTreasuryAndReservesResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateTreasuryAndReservesResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateTreasuryAndReserves => {
                write!(f, "queryLedgerState/treasuryAndReserves")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateTreasuryAndReservesResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/treasuryAndReserves" => Ok(Self::QueryLedgerStateTreasuryAndReserves),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateTreasuryAndReservesResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateTreasuryAndReservesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateTreasuryAndReservesResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateTreasuryAndReservesResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"reserves\","]
#[doc = "    \"treasury\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"reserves\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"treasury\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateTreasuryAndReservesResponseResult {
    pub reserves: ValueAdaOnly,
    pub treasury: ValueAdaOnly,
}
impl ::std::convert::From<&QueryLedgerStateTreasuryAndReservesResponseResult>
    for QueryLedgerStateTreasuryAndReservesResponseResult
{
    fn from(value: &QueryLedgerStateTreasuryAndReservesResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateUnavailableInCurrentEra"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateUnavailableInCurrentEra\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"Some query is not available for the requested ledger era.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            2002"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/constitution\","]
#[doc = "        \"queryLedgerState/constitutionalCommittee\","]
#[doc = "        \"queryLedgerState/delegateRepresentatives\","]
#[doc = "        \"queryLedgerState/epoch\","]
#[doc = "        \"queryLedgerState/eraStart\","]
#[doc = "        \"queryLedgerState/eraSummaries\","]
#[doc = "        \"queryLedgerState/governanceProposals\","]
#[doc = "        \"queryLedgerState/liveStakeDistribution\","]
#[doc = "        \"queryLedgerState/projectedRewards\","]
#[doc = "        \"queryLedgerState/protocolParameters\","]
#[doc = "        \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "        \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "        \"queryLedgerState/rewardsProvenance\","]
#[doc = "        \"queryLedgerState/stakePools\","]
#[doc = "        \"queryLedgerState/utxo\","]
#[doc = "        \"queryLedgerState/tip\","]
#[doc = "        \"queryLedgerState/treasuryAndReserves\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateUnavailableInCurrentEra {
    pub error: QueryLedgerStateUnavailableInCurrentEraError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateUnavailableInCurrentEraJsonrpc,
    pub method: QueryLedgerStateUnavailableInCurrentEraMethod,
}
impl ::std::convert::From<&QueryLedgerStateUnavailableInCurrentEra>
    for QueryLedgerStateUnavailableInCurrentEra
{
    fn from(value: &QueryLedgerStateUnavailableInCurrentEra) -> Self {
        value.clone()
    }
}
#[doc = "Some query is not available for the requested ledger era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Some query is not available for the requested ledger era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        2002"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateUnavailableInCurrentEraError {
    pub code: QueryLedgerStateUnavailableInCurrentEraErrorCode,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&QueryLedgerStateUnavailableInCurrentEraError>
    for QueryLedgerStateUnavailableInCurrentEraError
{
    fn from(value: &QueryLedgerStateUnavailableInCurrentEraError) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateUnavailableInCurrentEraErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    2002"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct QueryLedgerStateUnavailableInCurrentEraErrorCode(i64);
impl ::std::ops::Deref for QueryLedgerStateUnavailableInCurrentEraErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<QueryLedgerStateUnavailableInCurrentEraErrorCode> for i64 {
    fn from(value: QueryLedgerStateUnavailableInCurrentEraErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&QueryLedgerStateUnavailableInCurrentEraErrorCode>
    for QueryLedgerStateUnavailableInCurrentEraErrorCode
{
    fn from(value: &QueryLedgerStateUnavailableInCurrentEraErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for QueryLedgerStateUnavailableInCurrentEraErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2002_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for QueryLedgerStateUnavailableInCurrentEraErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "QueryLedgerStateUnavailableInCurrentEraJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUnavailableInCurrentEraJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUnavailableInCurrentEraJsonrpc {
    fn from(value: &QueryLedgerStateUnavailableInCurrentEraJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUnavailableInCurrentEraJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUnavailableInCurrentEraJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUnavailableInCurrentEraJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateUnavailableInCurrentEraJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateUnavailableInCurrentEraJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateUnavailableInCurrentEraMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/constitution\","]
#[doc = "    \"queryLedgerState/constitutionalCommittee\","]
#[doc = "    \"queryLedgerState/delegateRepresentatives\","]
#[doc = "    \"queryLedgerState/epoch\","]
#[doc = "    \"queryLedgerState/eraStart\","]
#[doc = "    \"queryLedgerState/eraSummaries\","]
#[doc = "    \"queryLedgerState/governanceProposals\","]
#[doc = "    \"queryLedgerState/liveStakeDistribution\","]
#[doc = "    \"queryLedgerState/projectedRewards\","]
#[doc = "    \"queryLedgerState/protocolParameters\","]
#[doc = "    \"queryLedgerState/proposedProtocolParameters\","]
#[doc = "    \"queryLedgerState/rewardAccountSummaries\","]
#[doc = "    \"queryLedgerState/rewardsProvenance\","]
#[doc = "    \"queryLedgerState/stakePools\","]
#[doc = "    \"queryLedgerState/utxo\","]
#[doc = "    \"queryLedgerState/tip\","]
#[doc = "    \"queryLedgerState/treasuryAndReserves\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUnavailableInCurrentEraMethod {
    #[serde(rename = "queryLedgerState/constitution")]
    QueryLedgerStateConstitution,
    #[serde(rename = "queryLedgerState/constitutionalCommittee")]
    QueryLedgerStateConstitutionalCommittee,
    #[serde(rename = "queryLedgerState/delegateRepresentatives")]
    QueryLedgerStateDelegateRepresentatives,
    #[serde(rename = "queryLedgerState/epoch")]
    QueryLedgerStateEpoch,
    #[serde(rename = "queryLedgerState/eraStart")]
    QueryLedgerStateEraStart,
    #[serde(rename = "queryLedgerState/eraSummaries")]
    QueryLedgerStateEraSummaries,
    #[serde(rename = "queryLedgerState/governanceProposals")]
    QueryLedgerStateGovernanceProposals,
    #[serde(rename = "queryLedgerState/liveStakeDistribution")]
    QueryLedgerStateLiveStakeDistribution,
    #[serde(rename = "queryLedgerState/projectedRewards")]
    QueryLedgerStateProjectedRewards,
    #[serde(rename = "queryLedgerState/protocolParameters")]
    QueryLedgerStateProtocolParameters,
    #[serde(rename = "queryLedgerState/proposedProtocolParameters")]
    QueryLedgerStateProposedProtocolParameters,
    #[serde(rename = "queryLedgerState/rewardAccountSummaries")]
    QueryLedgerStateRewardAccountSummaries,
    #[serde(rename = "queryLedgerState/rewardsProvenance")]
    QueryLedgerStateRewardsProvenance,
    #[serde(rename = "queryLedgerState/stakePools")]
    QueryLedgerStateStakePools,
    #[serde(rename = "queryLedgerState/utxo")]
    QueryLedgerStateUtxo,
    #[serde(rename = "queryLedgerState/tip")]
    QueryLedgerStateTip,
    #[serde(rename = "queryLedgerState/treasuryAndReserves")]
    QueryLedgerStateTreasuryAndReserves,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUnavailableInCurrentEraMethod {
    fn from(value: &QueryLedgerStateUnavailableInCurrentEraMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUnavailableInCurrentEraMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateConstitution => write!(f, "queryLedgerState/constitution"),
            Self::QueryLedgerStateConstitutionalCommittee => {
                write!(f, "queryLedgerState/constitutionalCommittee")
            }
            Self::QueryLedgerStateDelegateRepresentatives => {
                write!(f, "queryLedgerState/delegateRepresentatives")
            }
            Self::QueryLedgerStateEpoch => write!(f, "queryLedgerState/epoch"),
            Self::QueryLedgerStateEraStart => write!(f, "queryLedgerState/eraStart"),
            Self::QueryLedgerStateEraSummaries => write!(f, "queryLedgerState/eraSummaries"),
            Self::QueryLedgerStateGovernanceProposals => {
                write!(f, "queryLedgerState/governanceProposals")
            }
            Self::QueryLedgerStateLiveStakeDistribution => {
                write!(f, "queryLedgerState/liveStakeDistribution")
            }
            Self::QueryLedgerStateProjectedRewards => {
                write!(f, "queryLedgerState/projectedRewards")
            }
            Self::QueryLedgerStateProtocolParameters => {
                write!(f, "queryLedgerState/protocolParameters")
            }
            Self::QueryLedgerStateProposedProtocolParameters => {
                write!(f, "queryLedgerState/proposedProtocolParameters")
            }
            Self::QueryLedgerStateRewardAccountSummaries => {
                write!(f, "queryLedgerState/rewardAccountSummaries")
            }
            Self::QueryLedgerStateRewardsProvenance => {
                write!(f, "queryLedgerState/rewardsProvenance")
            }
            Self::QueryLedgerStateStakePools => write!(f, "queryLedgerState/stakePools"),
            Self::QueryLedgerStateUtxo => write!(f, "queryLedgerState/utxo"),
            Self::QueryLedgerStateTip => write!(f, "queryLedgerState/tip"),
            Self::QueryLedgerStateTreasuryAndReserves => {
                write!(f, "queryLedgerState/treasuryAndReserves")
            }
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUnavailableInCurrentEraMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/constitution" => Ok(Self::QueryLedgerStateConstitution),
            "queryLedgerState/constitutionalCommittee" => {
                Ok(Self::QueryLedgerStateConstitutionalCommittee)
            }
            "queryLedgerState/delegateRepresentatives" => {
                Ok(Self::QueryLedgerStateDelegateRepresentatives)
            }
            "queryLedgerState/epoch" => Ok(Self::QueryLedgerStateEpoch),
            "queryLedgerState/eraStart" => Ok(Self::QueryLedgerStateEraStart),
            "queryLedgerState/eraSummaries" => Ok(Self::QueryLedgerStateEraSummaries),
            "queryLedgerState/governanceProposals" => Ok(Self::QueryLedgerStateGovernanceProposals),
            "queryLedgerState/liveStakeDistribution" => {
                Ok(Self::QueryLedgerStateLiveStakeDistribution)
            }
            "queryLedgerState/projectedRewards" => Ok(Self::QueryLedgerStateProjectedRewards),
            "queryLedgerState/protocolParameters" => Ok(Self::QueryLedgerStateProtocolParameters),
            "queryLedgerState/proposedProtocolParameters" => {
                Ok(Self::QueryLedgerStateProposedProtocolParameters)
            }
            "queryLedgerState/rewardAccountSummaries" => {
                Ok(Self::QueryLedgerStateRewardAccountSummaries)
            }
            "queryLedgerState/rewardsProvenance" => Ok(Self::QueryLedgerStateRewardsProvenance),
            "queryLedgerState/stakePools" => Ok(Self::QueryLedgerStateStakePools),
            "queryLedgerState/utxo" => Ok(Self::QueryLedgerStateUtxo),
            "queryLedgerState/tip" => Ok(Self::QueryLedgerStateTip),
            "queryLedgerState/treasuryAndReserves" => Ok(Self::QueryLedgerStateTreasuryAndReserves),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUnavailableInCurrentEraMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryLedgerStateUnavailableInCurrentEraMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryLedgerStateUnavailableInCurrentEraMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the current Utxo set, restricted to some output references or addresses."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryLedgerStateUtxo\","]
#[doc = "  \"description\": \"Query the current Utxo set, restricted to some output references or addresses.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryLedgerState/utxo\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"UtxoByOutputReferences\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"outputReferences\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"outputReferences\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"UtxoByAddresses\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"addresses\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"addresses\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Address\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"WholeUtxo\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryLedgerStateUtxo {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryLedgerStateUtxoJsonrpc,
    pub method: QueryLedgerStateUtxoMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<QueryLedgerStateUtxoParams>,
}
impl ::std::convert::From<&QueryLedgerStateUtxo> for QueryLedgerStateUtxo {
    fn from(value: &QueryLedgerStateUtxo) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateUtxoJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUtxoJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUtxoJsonrpc {
    fn from(value: &QueryLedgerStateUtxoJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUtxoJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUtxoJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUtxoJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateUtxoJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateUtxoJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateUtxoMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/utxo\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUtxoMethod {
    #[serde(rename = "queryLedgerState/utxo")]
    QueryLedgerStateUtxo,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUtxoMethod {
    fn from(value: &QueryLedgerStateUtxoMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUtxoMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateUtxo => write!(f, "queryLedgerState/utxo"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUtxoMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/utxo" => Ok(Self::QueryLedgerStateUtxo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUtxoMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateUtxoMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateUtxoMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateUtxoParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"UtxoByOutputReferences\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"outputReferences\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"outputReferences\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"UtxoByAddresses\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"addresses\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"addresses\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Address\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"WholeUtxo\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum QueryLedgerStateUtxoParams {
    UtxoByOutputReferences {
        #[serde(rename = "outputReferences")]
        output_references: ::std::vec::Vec<TransactionOutputReference>,
    },
    UtxoByAddresses {
        addresses: ::std::vec::Vec<Address>,
    },
    WholeUtxo {},
}
impl ::std::convert::From<&Self> for QueryLedgerStateUtxoParams {
    fn from(value: &QueryLedgerStateUtxoParams) -> Self {
        value.clone()
    }
}
#[doc = "QueryLedgerStateUtxoResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUtxoResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUtxoResponseJsonrpc {
    fn from(value: &QueryLedgerStateUtxoResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUtxoResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUtxoResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUtxoResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateUtxoResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateUtxoResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryLedgerStateUtxoResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryLedgerState/utxo\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryLedgerStateUtxoResponseMethod {
    #[serde(rename = "queryLedgerState/utxo")]
    QueryLedgerStateUtxo,
}
impl ::std::convert::From<&Self> for QueryLedgerStateUtxoResponseMethod {
    fn from(value: &QueryLedgerStateUtxoResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryLedgerStateUtxoResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryLedgerStateUtxo => write!(f, "queryLedgerState/utxo"),
        }
    }
}
impl ::std::str::FromStr for QueryLedgerStateUtxoResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryLedgerState/utxo" => Ok(Self::QueryLedgerStateUtxo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryLedgerStateUtxoResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryLedgerStateUtxoResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryLedgerStateUtxoResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the networks highest block number."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkBlockHeight\","]
#[doc = "  \"description\": \"Query the networks highest block number.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/blockHeight\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkBlockHeight {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkBlockHeightJsonrpc,
    pub method: QueryNetworkBlockHeightMethod,
}
impl ::std::convert::From<&QueryNetworkBlockHeight> for QueryNetworkBlockHeight {
    fn from(value: &QueryNetworkBlockHeight) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkBlockHeightJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkBlockHeightJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkBlockHeightJsonrpc {
    fn from(value: &QueryNetworkBlockHeightJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkBlockHeightJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkBlockHeightJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkBlockHeightJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkBlockHeightJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkBlockHeightJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkBlockHeightMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/blockHeight\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkBlockHeightMethod {
    #[serde(rename = "queryNetwork/blockHeight")]
    QueryNetworkBlockHeight,
}
impl ::std::convert::From<&Self> for QueryNetworkBlockHeightMethod {
    fn from(value: &QueryNetworkBlockHeightMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkBlockHeightMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkBlockHeight => write!(f, "queryNetwork/blockHeight"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkBlockHeightMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/blockHeight" => Ok(Self::QueryNetworkBlockHeight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkBlockHeightMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkBlockHeightMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkBlockHeightMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkBlockHeightResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkBlockHeightResponse\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/blockHeight\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Origin\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkBlockHeightResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkBlockHeightResponseJsonrpc,
    pub method: QueryNetworkBlockHeightResponseMethod,
    pub result: QueryNetworkBlockHeightResponseResult,
}
impl ::std::convert::From<&QueryNetworkBlockHeightResponse> for QueryNetworkBlockHeightResponse {
    fn from(value: &QueryNetworkBlockHeightResponse) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkBlockHeightResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkBlockHeightResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkBlockHeightResponseJsonrpc {
    fn from(value: &QueryNetworkBlockHeightResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkBlockHeightResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkBlockHeightResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkBlockHeightResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkBlockHeightResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkBlockHeightResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkBlockHeightResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/blockHeight\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkBlockHeightResponseMethod {
    #[serde(rename = "queryNetwork/blockHeight")]
    QueryNetworkBlockHeight,
}
impl ::std::convert::From<&Self> for QueryNetworkBlockHeightResponseMethod {
    fn from(value: &QueryNetworkBlockHeightResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkBlockHeightResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkBlockHeight => write!(f, "queryNetwork/blockHeight"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkBlockHeightResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/blockHeight" => Ok(Self::QueryNetworkBlockHeight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkBlockHeightResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkBlockHeightResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkBlockHeightResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkBlockHeightResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Origin\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QueryNetworkBlockHeightResponseResult {
    BlockHeight(BlockHeight),
    Origin(Origin),
}
impl ::std::convert::From<&Self> for QueryNetworkBlockHeightResponseResult {
    fn from(value: &QueryNetworkBlockHeightResponseResult) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for QueryNetworkBlockHeightResponseResult {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::BlockHeight(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Origin(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkBlockHeightResponseResult {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkBlockHeightResponseResult {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkBlockHeightResponseResult {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for QueryNetworkBlockHeightResponseResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::BlockHeight(x) => x.fmt(f),
            Self::Origin(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<BlockHeight> for QueryNetworkBlockHeightResponseResult {
    fn from(value: BlockHeight) -> Self {
        Self::BlockHeight(value)
    }
}
impl ::std::convert::From<Origin> for QueryNetworkBlockHeightResponseResult {
    fn from(value: Origin) -> Self {
        Self::Origin(value)
    }
}
#[doc = "Query the genesis configuration of a given era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkGenesisConfiguration\","]
#[doc = "  \"description\": \"Query the genesis configuration of a given era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/genesisConfiguration\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"era\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"era\": {"]
#[doc = "          \"$ref\": \"#/definitions/EraWithGenesis\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkGenesisConfiguration {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkGenesisConfigurationJsonrpc,
    pub method: QueryNetworkGenesisConfigurationMethod,
    pub params: QueryNetworkGenesisConfigurationParams,
}
impl ::std::convert::From<&QueryNetworkGenesisConfiguration> for QueryNetworkGenesisConfiguration {
    fn from(value: &QueryNetworkGenesisConfiguration) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkGenesisConfigurationJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkGenesisConfigurationJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationJsonrpc {
    fn from(value: &QueryNetworkGenesisConfigurationJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkGenesisConfigurationJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkGenesisConfigurationJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkGenesisConfigurationJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkGenesisConfigurationJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkGenesisConfigurationJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkGenesisConfigurationMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/genesisConfiguration\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkGenesisConfigurationMethod {
    #[serde(rename = "queryNetwork/genesisConfiguration")]
    QueryNetworkGenesisConfiguration,
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationMethod {
    fn from(value: &QueryNetworkGenesisConfigurationMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkGenesisConfigurationMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkGenesisConfiguration => {
                write!(f, "queryNetwork/genesisConfiguration")
            }
        }
    }
}
impl ::std::str::FromStr for QueryNetworkGenesisConfigurationMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/genesisConfiguration" => Ok(Self::QueryNetworkGenesisConfiguration),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkGenesisConfigurationMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkGenesisConfigurationMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkGenesisConfigurationMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkGenesisConfigurationParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"era\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"era\": {"]
#[doc = "      \"$ref\": \"#/definitions/EraWithGenesis\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkGenesisConfigurationParams {
    pub era: EraWithGenesis,
}
impl ::std::convert::From<&QueryNetworkGenesisConfigurationParams>
    for QueryNetworkGenesisConfigurationParams
{
    fn from(value: &QueryNetworkGenesisConfigurationParams) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkGenesisConfigurationResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkGenesisConfigurationResponse\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/genesisConfiguration\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/QueryNetworkInvalidGenesis\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Genesis<Byron>\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Genesis<Shelley>\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Genesis<Alonzo>\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/Genesis<Conway>\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkGenesisConfigurationResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkGenesisConfigurationResponseJsonrpc,
    pub method: QueryNetworkGenesisConfigurationResponseMethod,
    pub result: QueryNetworkGenesisConfigurationResponseResult,
}
impl ::std::convert::From<&QueryNetworkGenesisConfigurationResponse>
    for QueryNetworkGenesisConfigurationResponse
{
    fn from(value: &QueryNetworkGenesisConfigurationResponse) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkGenesisConfigurationResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkGenesisConfigurationResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationResponseJsonrpc {
    fn from(value: &QueryNetworkGenesisConfigurationResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkGenesisConfigurationResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkGenesisConfigurationResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkGenesisConfigurationResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryNetworkGenesisConfigurationResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryNetworkGenesisConfigurationResponseJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkGenesisConfigurationResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/genesisConfiguration\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkGenesisConfigurationResponseMethod {
    #[serde(rename = "queryNetwork/genesisConfiguration")]
    QueryNetworkGenesisConfiguration,
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationResponseMethod {
    fn from(value: &QueryNetworkGenesisConfigurationResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkGenesisConfigurationResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkGenesisConfiguration => {
                write!(f, "queryNetwork/genesisConfiguration")
            }
        }
    }
}
impl ::std::str::FromStr for QueryNetworkGenesisConfigurationResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/genesisConfiguration" => Ok(Self::QueryNetworkGenesisConfiguration),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkGenesisConfigurationResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for QueryNetworkGenesisConfigurationResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for QueryNetworkGenesisConfigurationResponseMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkGenesisConfigurationResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/QueryNetworkInvalidGenesis\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Genesis<Byron>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Genesis<Shelley>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Genesis<Alonzo>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Genesis<Conway>\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QueryNetworkGenesisConfigurationResponseResult {
    Variant0(QueryNetworkInvalidGenesis),
    Variant1(QueryNetworkGenesisConfigurationResponseResultVariant1),
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationResponseResult {
    fn from(value: &QueryNetworkGenesisConfigurationResponseResult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<QueryNetworkInvalidGenesis>
    for QueryNetworkGenesisConfigurationResponseResult
{
    fn from(value: QueryNetworkInvalidGenesis) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<QueryNetworkGenesisConfigurationResponseResultVariant1>
    for QueryNetworkGenesisConfigurationResponseResult
{
    fn from(value: QueryNetworkGenesisConfigurationResponseResultVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QueryNetworkGenesisConfigurationResponseResultVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Genesis<Byron>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Genesis<Shelley>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Genesis<Alonzo>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Genesis<Conway>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QueryNetworkGenesisConfigurationResponseResultVariant1 {
    Byron(GenesisByron),
    Shelley(GenesisShelley),
    Alonzo(GenesisAlonzo),
    Conway(GenesisConway),
}
impl ::std::convert::From<&Self> for QueryNetworkGenesisConfigurationResponseResultVariant1 {
    fn from(value: &QueryNetworkGenesisConfigurationResponseResultVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<GenesisByron> for QueryNetworkGenesisConfigurationResponseResultVariant1 {
    fn from(value: GenesisByron) -> Self {
        Self::Byron(value)
    }
}
impl ::std::convert::From<GenesisShelley>
    for QueryNetworkGenesisConfigurationResponseResultVariant1
{
    fn from(value: GenesisShelley) -> Self {
        Self::Shelley(value)
    }
}
impl ::std::convert::From<GenesisAlonzo>
    for QueryNetworkGenesisConfigurationResponseResultVariant1
{
    fn from(value: GenesisAlonzo) -> Self {
        Self::Alonzo(value)
    }
}
impl ::std::convert::From<GenesisConway>
    for QueryNetworkGenesisConfigurationResponseResultVariant1
{
    fn from(value: GenesisConway) -> Self {
        Self::Conway(value)
    }
}
#[doc = "QueryNetworkInvalidGenesis"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkInvalidGenesis\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"description\": \"Something went wrong (e.g. misconfiguration) in reading genesis file for the latest era.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            2004"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"A reason for the failure.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/genesisConfiguration\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkInvalidGenesis {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub error: ::std::option::Option<QueryNetworkInvalidGenesisError>,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkInvalidGenesisJsonrpc,
    pub method: QueryNetworkInvalidGenesisMethod,
    pub result: ::serde_json::Value,
}
impl ::std::convert::From<&QueryNetworkInvalidGenesis> for QueryNetworkInvalidGenesis {
    fn from(value: &QueryNetworkInvalidGenesis) -> Self {
        value.clone()
    }
}
#[doc = "Something went wrong (e.g. misconfiguration) in reading genesis file for the latest era."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Something went wrong (e.g. misconfiguration) in reading genesis file for the latest era.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        2004"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"A reason for the failure.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkInvalidGenesisError {
    pub code: QueryNetworkInvalidGenesisErrorCode,
    #[doc = "A reason for the failure."]
    pub data: ::std::string::String,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&QueryNetworkInvalidGenesisError> for QueryNetworkInvalidGenesisError {
    fn from(value: &QueryNetworkInvalidGenesisError) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkInvalidGenesisErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    2004"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct QueryNetworkInvalidGenesisErrorCode(i64);
impl ::std::ops::Deref for QueryNetworkInvalidGenesisErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<QueryNetworkInvalidGenesisErrorCode> for i64 {
    fn from(value: QueryNetworkInvalidGenesisErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&QueryNetworkInvalidGenesisErrorCode>
    for QueryNetworkInvalidGenesisErrorCode
{
    fn from(value: &QueryNetworkInvalidGenesisErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for QueryNetworkInvalidGenesisErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![2004_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for QueryNetworkInvalidGenesisErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "QueryNetworkInvalidGenesisJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkInvalidGenesisJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkInvalidGenesisJsonrpc {
    fn from(value: &QueryNetworkInvalidGenesisJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkInvalidGenesisJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkInvalidGenesisJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkInvalidGenesisJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkInvalidGenesisJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkInvalidGenesisJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkInvalidGenesisMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/genesisConfiguration\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkInvalidGenesisMethod {
    #[serde(rename = "queryNetwork/genesisConfiguration")]
    QueryNetworkGenesisConfiguration,
}
impl ::std::convert::From<&Self> for QueryNetworkInvalidGenesisMethod {
    fn from(value: &QueryNetworkInvalidGenesisMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkInvalidGenesisMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkGenesisConfiguration => {
                write!(f, "queryNetwork/genesisConfiguration")
            }
        }
    }
}
impl ::std::str::FromStr for QueryNetworkInvalidGenesisMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/genesisConfiguration" => Ok(Self::QueryNetworkGenesisConfiguration),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkInvalidGenesisMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkInvalidGenesisMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkInvalidGenesisMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Query the network start time."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkStartTime\","]
#[doc = "  \"description\": \"Query the network start time.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/startTime\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkStartTime {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkStartTimeJsonrpc,
    pub method: QueryNetworkStartTimeMethod,
}
impl ::std::convert::From<&QueryNetworkStartTime> for QueryNetworkStartTime {
    fn from(value: &QueryNetworkStartTime) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkStartTimeJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkStartTimeJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkStartTimeJsonrpc {
    fn from(value: &QueryNetworkStartTimeJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkStartTimeJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkStartTimeJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkStartTimeJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkStartTimeJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkStartTimeJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkStartTimeMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/startTime\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkStartTimeMethod {
    #[serde(rename = "queryNetwork/startTime")]
    QueryNetworkStartTime,
}
impl ::std::convert::From<&Self> for QueryNetworkStartTimeMethod {
    fn from(value: &QueryNetworkStartTimeMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkStartTimeMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkStartTime => write!(f, "queryNetwork/startTime"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkStartTimeMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/startTime" => Ok(Self::QueryNetworkStartTime),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkStartTimeMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkStartTimeMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkStartTimeMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkStartTimeResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkStartTimeResponse\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/startTime\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"$ref\": \"#/definitions/UtcTime\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkStartTimeResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkStartTimeResponseJsonrpc,
    pub method: QueryNetworkStartTimeResponseMethod,
    pub result: UtcTime,
}
impl ::std::convert::From<&QueryNetworkStartTimeResponse> for QueryNetworkStartTimeResponse {
    fn from(value: &QueryNetworkStartTimeResponse) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkStartTimeResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkStartTimeResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkStartTimeResponseJsonrpc {
    fn from(value: &QueryNetworkStartTimeResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkStartTimeResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkStartTimeResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkStartTimeResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkStartTimeResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkStartTimeResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkStartTimeResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/startTime\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkStartTimeResponseMethod {
    #[serde(rename = "queryNetwork/startTime")]
    QueryNetworkStartTime,
}
impl ::std::convert::From<&Self> for QueryNetworkStartTimeResponseMethod {
    fn from(value: &QueryNetworkStartTimeResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkStartTimeResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkStartTime => write!(f, "queryNetwork/startTime"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkStartTimeResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/startTime" => Ok(Self::QueryNetworkStartTime),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkStartTimeResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkStartTimeResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkStartTimeResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkTip\","]
#[doc = "  \"description\": \"Get the current network tip. Said differently, this is the most recent slot and block header hash that the node it aware of.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/tip\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkTip {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkTipJsonrpc,
    pub method: QueryNetworkTipMethod,
}
impl ::std::convert::From<&QueryNetworkTip> for QueryNetworkTip {
    fn from(value: &QueryNetworkTip) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkTipJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkTipJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkTipJsonrpc {
    fn from(value: &QueryNetworkTipJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkTipJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkTipJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkTipJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkTipMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/tip\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkTipMethod {
    #[serde(rename = "queryNetwork/tip")]
    QueryNetworkTip,
}
impl ::std::convert::From<&Self> for QueryNetworkTipMethod {
    fn from(value: &QueryNetworkTipMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkTipMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkTip => write!(f, "queryNetwork/tip"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkTipMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/tip" => Ok(Self::QueryNetworkTip),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkTipMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkTipResponse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"QueryNetworkTipResponse\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"queryNetwork/tip\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"$ref\": \"#/definitions/PointOrOrigin\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QueryNetworkTipResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: QueryNetworkTipResponseJsonrpc,
    pub method: QueryNetworkTipResponseMethod,
    pub result: PointOrOrigin,
}
impl ::std::convert::From<&QueryNetworkTipResponse> for QueryNetworkTipResponse {
    fn from(value: &QueryNetworkTipResponse) -> Self {
        value.clone()
    }
}
#[doc = "QueryNetworkTipResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkTipResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for QueryNetworkTipResponseJsonrpc {
    fn from(value: &QueryNetworkTipResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkTipResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkTipResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkTipResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "QueryNetworkTipResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"queryNetwork/tip\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QueryNetworkTipResponseMethod {
    #[serde(rename = "queryNetwork/tip")]
    QueryNetworkTip,
}
impl ::std::convert::From<&Self> for QueryNetworkTipResponseMethod {
    fn from(value: &QueryNetworkTipResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QueryNetworkTipResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::QueryNetworkTip => write!(f, "queryNetwork/tip"),
        }
    }
}
impl ::std::str::FromStr for QueryNetworkTipResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "queryNetwork/tip" => Ok(Self::QueryNetworkTip),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QueryNetworkTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QueryNetworkTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QueryNetworkTipResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A ratio of two integers, to express exact fractions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Ratio\","]
#[doc = "  \"description\": \"A ratio of two integers, to express exact fractions.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"2/3\","]
#[doc = "    \"7/8\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^-?[0-9]+/[0-9]+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct Ratio(::std::string::String);
impl ::std::ops::Deref for Ratio {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Ratio> for ::std::string::String {
    fn from(value: Ratio) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Ratio> for Ratio {
    fn from(value: &Ratio) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for Ratio {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^-?[0-9]+/[0-9]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^-?[0-9]+/[0-9]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for Ratio {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Ratio {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Ratio {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for Ratio {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Redeemer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Redeemer\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"executionUnits\": {"]
#[doc = "        \"cpu\": 2,"]
#[doc = "        \"memory\": 2"]
#[doc = "      },"]
#[doc = "      \"redeemer\": \"ggRCqSQ=\","]
#[doc = "      \"validator\": {"]
#[doc = "        \"index\": 0,"]
#[doc = "        \"purpose\": \"spend\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"executionUnits\","]
#[doc = "    \"redeemer\","]
#[doc = "    \"validator\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"executionUnits\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"redeemer\": {"]
#[doc = "      \"$ref\": \"#/definitions/RedeemerData\""]
#[doc = "    },"]
#[doc = "    \"validator\": {"]
#[doc = "      \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Redeemer {
    #[serde(rename = "executionUnits")]
    pub execution_units: ExecutionUnits,
    pub redeemer: RedeemerData,
    pub validator: RedeemerPointer,
}
impl ::std::convert::From<&Redeemer> for Redeemer {
    fn from(value: &Redeemer) -> Self {
        value.clone()
    }
}
#[doc = "Plutus data, CBOR-serialised."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RedeemerData\","]
#[doc = "  \"description\": \"Plutus data, CBOR-serialised.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct RedeemerData(pub ::std::string::String);
impl ::std::ops::Deref for RedeemerData {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<RedeemerData> for ::std::string::String {
    fn from(value: RedeemerData) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RedeemerData> for RedeemerData {
    fn from(value: &RedeemerData) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for RedeemerData {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for RedeemerData {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for RedeemerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "RedeemerPointer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RedeemerPointer\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"index\","]
#[doc = "    \"purpose\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"index\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"purpose\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"spend\","]
#[doc = "        \"mint\","]
#[doc = "        \"publish\","]
#[doc = "        \"withdraw\","]
#[doc = "        \"vote\","]
#[doc = "        \"propose\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RedeemerPointer {
    pub index: UInt64,
    pub purpose: RedeemerPointerPurpose,
}
impl ::std::convert::From<&RedeemerPointer> for RedeemerPointer {
    fn from(value: &RedeemerPointer) -> Self {
        value.clone()
    }
}
#[doc = "RedeemerPointerPurpose"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"spend\","]
#[doc = "    \"mint\","]
#[doc = "    \"publish\","]
#[doc = "    \"withdraw\","]
#[doc = "    \"vote\","]
#[doc = "    \"propose\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RedeemerPointerPurpose {
    #[serde(rename = "spend")]
    Spend,
    #[serde(rename = "mint")]
    Mint,
    #[serde(rename = "publish")]
    Publish,
    #[serde(rename = "withdraw")]
    Withdraw,
    #[serde(rename = "vote")]
    Vote,
    #[serde(rename = "propose")]
    Propose,
}
impl ::std::convert::From<&Self> for RedeemerPointerPurpose {
    fn from(value: &RedeemerPointerPurpose) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RedeemerPointerPurpose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Spend => write!(f, "spend"),
            Self::Mint => write!(f, "mint"),
            Self::Publish => write!(f, "publish"),
            Self::Withdraw => write!(f, "withdraw"),
            Self::Vote => write!(f, "vote"),
            Self::Propose => write!(f, "propose"),
        }
    }
}
impl ::std::str::FromStr for RedeemerPointerPurpose {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "spend" => Ok(Self::Spend),
            "mint" => Ok(Self::Mint),
            "publish" => Ok(Self::Publish),
            "withdraw" => Ok(Self::Withdraw),
            "vote" => Ok(Self::Vote),
            "propose" => Ok(Self::Propose),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RedeemerPointerPurpose {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RedeemerPointerPurpose {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RedeemerPointerPurpose {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A time in seconds relative to another one (typically, system start or era start)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RelativeTime\","]
#[doc = "  \"description\": \"A time in seconds relative to another one (typically, system start or era start).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"seconds\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"seconds\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RelativeTime {
    pub seconds: i64,
}
impl ::std::convert::From<&RelativeTime> for RelativeTime {
    fn from(value: &RelativeTime) -> Self {
        value.clone()
    }
}
#[doc = "Relay"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Relay\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Relay<ByAddress>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ipv4\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"ipv6\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"port\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"maximum\": 65535.0,"]
#[doc = "          \"minimum\": 0.0"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"ipAddress\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Relay<ByName>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hostname\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hostname\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"port\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"maximum\": 65535.0,"]
#[doc = "          \"minimum\": 0.0"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"hostname\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", deny_unknown_fields)]
pub enum Relay {
    #[doc = "Relay<ByAddress>"]
    #[serde(rename = "ipAddress")]
    IpAddress {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ipv4: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        ipv6: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        port: ::std::option::Option<u16>,
    },
    #[doc = "Relay<ByName>"]
    #[serde(rename = "hostname")]
    Hostname {
        hostname: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        port: ::std::option::Option<u16>,
    },
}
impl ::std::convert::From<&Self> for Relay {
    fn from(value: &Relay) -> Self {
        value.clone()
    }
}
#[doc = "Release a previously acquired ledger state."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ReleaseLedgerState\","]
#[doc = "  \"description\": \"Release a previously acquired ledger state.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"releaseLedgerState\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseLedgerState {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: ReleaseLedgerStateJsonrpc,
    pub method: ReleaseLedgerStateMethod,
}
impl ::std::convert::From<&ReleaseLedgerState> for ReleaseLedgerState {
    fn from(value: &ReleaseLedgerState) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseLedgerStateJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseLedgerStateJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for ReleaseLedgerStateJsonrpc {
    fn from(value: &ReleaseLedgerStateJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseLedgerStateJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for ReleaseLedgerStateJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseLedgerStateJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseLedgerStateMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"releaseLedgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseLedgerStateMethod {
    #[serde(rename = "releaseLedgerState")]
    ReleaseLedgerState,
}
impl ::std::convert::From<&Self> for ReleaseLedgerStateMethod {
    fn from(value: &ReleaseLedgerStateMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseLedgerStateMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReleaseLedgerState => write!(f, "releaseLedgerState"),
        }
    }
}
impl ::std::str::FromStr for ReleaseLedgerStateMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "releaseLedgerState" => Ok(Self::ReleaseLedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseLedgerStateMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Response to a 'releaseLedgerState' request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ReleaseLedgerStateResponse\","]
#[doc = "  \"description\": \"Response to a 'releaseLedgerState' request.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"releaseLedgerState\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"released\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"released\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"ledgerState\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseLedgerStateResponse {
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: ReleaseLedgerStateResponseJsonrpc,
    pub method: ReleaseLedgerStateResponseMethod,
    pub result: ReleaseLedgerStateResponseResult,
}
impl ::std::convert::From<&ReleaseLedgerStateResponse> for ReleaseLedgerStateResponse {
    fn from(value: &ReleaseLedgerStateResponse) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseLedgerStateResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseLedgerStateResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for ReleaseLedgerStateResponseJsonrpc {
    fn from(value: &ReleaseLedgerStateResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseLedgerStateResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for ReleaseLedgerStateResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseLedgerStateResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseLedgerStateResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseLedgerStateResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseLedgerStateResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"releaseLedgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseLedgerStateResponseMethod {
    #[serde(rename = "releaseLedgerState")]
    ReleaseLedgerState,
}
impl ::std::convert::From<&Self> for ReleaseLedgerStateResponseMethod {
    fn from(value: &ReleaseLedgerStateResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseLedgerStateResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReleaseLedgerState => write!(f, "releaseLedgerState"),
        }
    }
}
impl ::std::str::FromStr for ReleaseLedgerStateResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "releaseLedgerState" => Ok(Self::ReleaseLedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseLedgerStateResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseLedgerStateResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseLedgerStateResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseLedgerStateResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"released\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"released\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"ledgerState\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseLedgerStateResponseResult {
    pub released: ReleaseLedgerStateResponseResultReleased,
}
impl ::std::convert::From<&ReleaseLedgerStateResponseResult> for ReleaseLedgerStateResponseResult {
    fn from(value: &ReleaseLedgerStateResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseLedgerStateResponseResultReleased"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"ledgerState\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseLedgerStateResponseResultReleased {
    #[serde(rename = "ledgerState")]
    LedgerState,
}
impl ::std::convert::From<&Self> for ReleaseLedgerStateResponseResultReleased {
    fn from(value: &ReleaseLedgerStateResponseResultReleased) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseLedgerStateResponseResultReleased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::LedgerState => write!(f, "ledgerState"),
        }
    }
}
impl ::std::str::FromStr for ReleaseLedgerStateResponseResultReleased {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ledgerState" => Ok(Self::LedgerState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseLedgerStateResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseLedgerStateResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseLedgerStateResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Release a previously acquired mempool snapshot."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ReleaseMempool\","]
#[doc = "  \"description\": \"Release a previously acquired mempool snapshot.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"releaseMempool\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseMempool {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: ReleaseMempoolJsonrpc,
    pub method: ReleaseMempoolMethod,
}
impl ::std::convert::From<&ReleaseMempool> for ReleaseMempool {
    fn from(value: &ReleaseMempool) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseMempoolJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseMempoolJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for ReleaseMempoolJsonrpc {
    fn from(value: &ReleaseMempoolJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseMempoolJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for ReleaseMempoolJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseMempoolMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"releaseMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseMempoolMethod {
    #[serde(rename = "releaseMempool")]
    ReleaseMempool,
}
impl ::std::convert::From<&Self> for ReleaseMempoolMethod {
    fn from(value: &ReleaseMempoolMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseMempoolMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReleaseMempool => write!(f, "releaseMempool"),
        }
    }
}
impl ::std::str::FromStr for ReleaseMempoolMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "releaseMempool" => Ok(Self::ReleaseMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseMempoolResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseMempoolResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for ReleaseMempoolResponseJsonrpc {
    fn from(value: &ReleaseMempoolResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseMempoolResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for ReleaseMempoolResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseMempoolResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"releaseMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseMempoolResponseMethod {
    #[serde(rename = "releaseMempool")]
    ReleaseMempool,
}
impl ::std::convert::From<&Self> for ReleaseMempoolResponseMethod {
    fn from(value: &ReleaseMempoolResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseMempoolResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ReleaseMempool => write!(f, "releaseMempool"),
        }
    }
}
impl ::std::str::FromStr for ReleaseMempoolResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "releaseMempool" => Ok(Self::ReleaseMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ReleaseMempoolResponseResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"released\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"released\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"mempool\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ReleaseMempoolResponseResult {
    pub released: ReleaseMempoolResponseResultReleased,
}
impl ::std::convert::From<&ReleaseMempoolResponseResult> for ReleaseMempoolResponseResult {
    fn from(value: &ReleaseMempoolResponseResult) -> Self {
        value.clone()
    }
}
#[doc = "ReleaseMempoolResponseResultReleased"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"mempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ReleaseMempoolResponseResultReleased {
    #[serde(rename = "mempool")]
    Mempool,
}
impl ::std::convert::From<&Self> for ReleaseMempoolResponseResultReleased {
    fn from(value: &ReleaseMempoolResponseResultReleased) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ReleaseMempoolResponseResultReleased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Mempool => write!(f, "mempool"),
        }
    }
}
impl ::std::str::FromStr for ReleaseMempoolResponseResultReleased {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "mempool" => Ok(Self::Mempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ReleaseMempoolResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReleaseMempoolResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReleaseMempoolResponseResultReleased {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A reward account, also known as 'stake address'."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RewardAccount\","]
#[doc = "  \"description\": \"A reward account, also known as 'stake address'.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"stake1ux7pt9adw8z46tgqn2f8fvurrhk325gcm4mf75mkmmxpx6gae9mzv\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^stake(_test)?1[0-9a-z]+$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct RewardAccount(::std::string::String);
impl ::std::ops::Deref for RewardAccount {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<RewardAccount> for ::std::string::String {
    fn from(value: RewardAccount) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RewardAccount> for RewardAccount {
    fn from(value: &RewardAccount) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RewardAccount {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^stake(_test)?1[0-9a-z]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^stake(_test)?1[0-9a-z]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for RewardAccount {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RewardAccount {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RewardAccount {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for RewardAccount {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "RewardAccountSummary"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"delegate\": \"pool1kchver88u3kygsak8wgll7htr8uxn5v35lfrsyy842nkscrzyvj\","]
#[doc = "      \"deposit\": {"]
#[doc = "        \"ada\": {"]
#[doc = "          \"lovelace\": 2000000"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"rewards\": {"]
#[doc = "        \"ada\": {"]
#[doc = "          \"lovelace\": 219558722"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegate\","]
#[doc = "    \"deposit\","]
#[doc = "    \"rewards\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegate\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"deposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"rewards\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RewardAccountSummary {
    pub delegate: RewardAccountSummaryDelegate,
    pub deposit: ValueAdaOnly,
    pub rewards: ValueAdaOnly,
}
impl ::std::convert::From<&RewardAccountSummary> for RewardAccountSummary {
    fn from(value: &RewardAccountSummary) -> Self {
        value.clone()
    }
}
#[doc = "RewardAccountSummaryDelegate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RewardAccountSummaryDelegate {
    pub id: StakePoolId,
}
impl ::std::convert::From<&RewardAccountSummaryDelegate> for RewardAccountSummaryDelegate {
    fn from(value: &RewardAccountSummaryDelegate) -> Self {
        value.clone()
    }
}
#[doc = "RewardTransfer"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RewardTransfer\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"6d06fe0a5a8cb6d2bcc352581dea626bb5b2f66edf85678b2f2fa7b5\": {"]
#[doc = "        \"ada\": {"]
#[doc = "          \"lovelace\": 123456789"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"$ref\": \"#/definitions/Value<Delta>\""]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"pattern\": \"[0-9a-f]{56}$\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RewardTransfer(pub ::std::collections::HashMap<RewardTransferKey, ValueDelta>);
impl ::std::ops::Deref for RewardTransfer {
    type Target = ::std::collections::HashMap<RewardTransferKey, ValueDelta>;
    fn deref(&self) -> &::std::collections::HashMap<RewardTransferKey, ValueDelta> {
        &self.0
    }
}
impl ::std::convert::From<RewardTransfer>
    for ::std::collections::HashMap<RewardTransferKey, ValueDelta>
{
    fn from(value: RewardTransfer) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RewardTransfer> for RewardTransfer {
    fn from(value: &RewardTransfer) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::collections::HashMap<RewardTransferKey, ValueDelta>>
    for RewardTransfer
{
    fn from(value: ::std::collections::HashMap<RewardTransferKey, ValueDelta>) -> Self {
        Self(value)
    }
}
#[doc = "RewardTransferKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"[0-9a-f]{56}$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct RewardTransferKey(::std::string::String);
impl ::std::ops::Deref for RewardTransferKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<RewardTransferKey> for ::std::string::String {
    fn from(value: RewardTransferKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RewardTransferKey> for RewardTransferKey {
    fn from(value: &RewardTransferKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RewardTransferKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("[0-9a-f]{56}$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"[0-9a-f]{56}$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for RewardTransferKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RewardTransferKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RewardTransferKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for RewardTransferKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Details about how rewards are calculated for the ongoing epoch."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Details about how rewards are calculated for the ongoing epoch.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"activeStakeInEpoch\","]
#[doc = "    \"desiredNumberOfStakePools\","]
#[doc = "    \"stakePoolPledgeInfluence\","]
#[doc = "    \"stakePools\","]
#[doc = "    \"totalRewardsInEpoch\","]
#[doc = "    \"totalStakeInEpoch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"activeStakeInEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"desiredNumberOfStakePools\": {"]
#[doc = "      \"description\": \"Desired number of stake pools.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"maximum\": 1.8446744073709552e19,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"stakePoolPledgeInfluence\": {"]
#[doc = "      \"description\": \"Influence of the pool owner's pledge on rewards, as a ratio of two integers.\","]
#[doc = "      \"examples\": ["]
#[doc = "        \"2/3\","]
#[doc = "        \"7/8\""]
#[doc = "      ],"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^-?[0-9]+/[0-9]+$\""]
#[doc = "    },"]
#[doc = "    \"stakePools\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/StakePoolSummary\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"totalRewardsInEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"totalStakeInEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RewardsProvenance {
    #[serde(rename = "activeStakeInEpoch")]
    pub active_stake_in_epoch: ValueAdaOnly,
    #[doc = "Desired number of stake pools."]
    #[serde(rename = "desiredNumberOfStakePools")]
    pub desired_number_of_stake_pools: u64,
    #[doc = "Influence of the pool owner's pledge on rewards, as a ratio of two integers."]
    #[serde(rename = "stakePoolPledgeInfluence")]
    pub stake_pool_pledge_influence: RewardsProvenanceStakePoolPledgeInfluence,
    #[serde(rename = "stakePools")]
    pub stake_pools: ::std::collections::HashMap<StakePoolId, StakePoolSummary>,
    #[serde(rename = "totalRewardsInEpoch")]
    pub total_rewards_in_epoch: ValueAdaOnly,
    #[serde(rename = "totalStakeInEpoch")]
    pub total_stake_in_epoch: ValueAdaOnly,
}
impl ::std::convert::From<&RewardsProvenance> for RewardsProvenance {
    fn from(value: &RewardsProvenance) -> Self {
        value.clone()
    }
}
#[doc = "Influence of the pool owner's pledge on rewards, as a ratio of two integers."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Influence of the pool owner's pledge on rewards, as a ratio of two integers.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"2/3\","]
#[doc = "    \"7/8\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^-?[0-9]+/[0-9]+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct RewardsProvenanceStakePoolPledgeInfluence(::std::string::String);
impl ::std::ops::Deref for RewardsProvenanceStakePoolPledgeInfluence {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<RewardsProvenanceStakePoolPledgeInfluence> for ::std::string::String {
    fn from(value: RewardsProvenanceStakePoolPledgeInfluence) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RewardsProvenanceStakePoolPledgeInfluence>
    for RewardsProvenanceStakePoolPledgeInfluence
{
    fn from(value: &RewardsProvenanceStakePoolPledgeInfluence) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RewardsProvenanceStakePoolPledgeInfluence {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^-?[0-9]+/[0-9]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^-?[0-9]+/[0-9]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for RewardsProvenanceStakePoolPledgeInfluence {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RewardsProvenanceStakePoolPledgeInfluence {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RewardsProvenanceStakePoolPledgeInfluence {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for RewardsProvenanceStakePoolPledgeInfluence {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcError\","]
#[doc = "  \"description\": \"A generic error in the JSON-RPC protocol. This is returned by the server when a request from clients is deemed invalid or, when the server was unable to reply to a well-formed request.\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"error\": {"]
#[doc = "        \"code\": \"-32601\","]
#[doc = "        \"message\": \"Invalid request: invalid query.\""]
#[doc = "      },"]
#[doc = "      \"jsonrpc\": \"2.0\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"string\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"description\": \"An error code telling about the nature of the error.\","]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"maximum\": -32000.0,"]
#[doc = "          \"minimum\": -32700.0"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"description\": \"Some optional data / context about the error. The exact type of this (optional) field depends on the error.\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"description\": \"A descriptive error message giving hints about the error.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"Any value that was set by a client request in the 'id' field.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RpcError {
    pub error: RpcErrorError,
    #[doc = "Any value that was set by a client request in the 'id' field."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: RpcErrorJsonrpc,
}
impl ::std::convert::From<&RpcError> for RpcError {
    fn from(value: &RpcError) -> Self {
        value.clone()
    }
}
#[doc = "RpcErrorError"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"string\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"description\": \"An error code telling about the nature of the error.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"maximum\": -32000.0,"]
#[doc = "      \"minimum\": -32700.0"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"Some optional data / context about the error. The exact type of this (optional) field depends on the error.\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"A descriptive error message giving hints about the error.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RpcErrorError {
    #[doc = "An error code telling about the nature of the error."]
    pub code: i64,
    #[doc = "Some optional data / context about the error. The exact type of this (optional) field depends on the error."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::serde_json::Value>,
    #[doc = "A descriptive error message giving hints about the error."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    pub string: ::serde_json::Value,
}
impl ::std::convert::From<&RpcErrorError> for RpcErrorError {
    fn from(value: &RpcErrorError) -> Self {
        value.clone()
    }
}
#[doc = "RpcErrorJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcErrorJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for RpcErrorJsonrpc {
    fn from(value: &RpcErrorJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcErrorJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for RpcErrorJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RpcErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RpcErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SafeZone\","]
#[doc = "  \"description\": \"Number of slots from the tip of the ledger in which it is guaranteed that no hard fork can take place. This should be (at least) the number of slots in which we are guaranteed to have k blocks.\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 1.8446744073709552e19,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SafeZone(pub u64);
impl ::std::ops::Deref for SafeZone {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<SafeZone> for u64 {
    fn from(value: SafeZone) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SafeZone> for SafeZone {
    fn from(value: &SafeZone) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for SafeZone {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for SafeZone {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for SafeZone {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for SafeZone {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for SafeZone {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for SafeZone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Script"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Script\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Native\","]
#[doc = "      \"description\": \"A Cardano native script. Use --include-script-cbor to ALWAYS include the 'cbor' field. Omitted otherwise.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"json\","]
#[doc = "        \"language\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cbor\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"contentEncoding\": \"base16\""]
#[doc = "        },"]
#[doc = "        \"json\": {"]
#[doc = "          \"$ref\": \"#/definitions/Script<Native>\""]
#[doc = "        },"]
#[doc = "        \"language\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"native\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Plutus\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cbor\","]
#[doc = "        \"language\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cbor\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"contentEncoding\": \"base16\""]
#[doc = "        },"]
#[doc = "        \"language\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"plutus:v1\","]
#[doc = "            \"plutus:v2\","]
#[doc = "            \"plutus:v3\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Script {
    Native {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        cbor: ::std::option::Option<::std::string::String>,
        json: ScriptNative,
        language: NativeLanguage,
    },
    Plutus {
        cbor: ::std::string::String,
        language: PlutusLanguage,
    },
}
impl ::std::convert::From<&Self> for Script {
    fn from(value: &Script) -> Self {
        value.clone()
    }
}
#[doc = "ScriptExecutionFailure"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptExecutionFailure<InvalidRedeemerPointers>\","]
#[doc = "      \"description\": \"Some script witnesses are missing. Indeed, any script used in a transaction (when spending, minting, etc...) must be provided in full with the transaction. Scripts must therefore be added either to the witness set or provided as a reference input should you use plutus:v2 or higher and a format from Babbage and beyond. The field 'data.missingScripts' contain hash digests of required but missing script.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3011"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"missingScripts\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"missingScripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptExecutionFailure<ValidationFailure>\","]
#[doc = "      \"description\": \"Some of the scripts failed to evaluate to a positive outcome. The field 'data.validationError' informs about the nature of the error, and 'data.traces' lists all the execution traces collected during the script execution.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3012"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"traces\","]
#[doc = "            \"validationError\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"traces\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"validationError\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptExecutionFailure<UnsuitableOutputReference>\","]
#[doc = "      \"description\": \"A redeemer points to an input that isn't locked by a Plutus script. Double-check your redeemer pointers and note that, inputs are ordered lexicographically by the ledger (using their transaction id and output index). This order may differ from the one you originally defined in your transaction and may be the cause of misalignment of your redeemer pointers. The field 'data.unsuitableOutputReference' indicates which input was wrongly targeted by a redeemer.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3013"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unsuitableOutputReference\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unsuitableOutputReference\": {"]
#[doc = "              \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<ExtraneousRedeemers>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<MissingDatums>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<UnknownOutputReference>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<MissingCostModels>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<ExecutionBudgetOutOfBounds>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScriptExecutionFailure {
    ScriptExecutionFailureInvalidRedeemerPointers {
        code: ScriptExecutionFailureInvalidRedeemerPointersCode,
        data: ScriptExecutionFailureInvalidRedeemerPointersData,
        message: ::std::string::String,
    },
    ScriptExecutionFailureValidationFailure {
        code: ScriptExecutionFailureValidationFailureCode,
        data: ScriptExecutionFailureValidationFailureData,
        message: ::std::string::String,
    },
    ScriptExecutionFailureUnsuitableOutputReference {
        code: ScriptExecutionFailureUnsuitableOutputReferenceCode,
        data: ScriptExecutionFailureUnsuitableOutputReferenceData,
        message: ::std::string::String,
    },
    SubmitTransactionFailureExtraneousRedeemers(SubmitTransactionFailureExtraneousRedeemers),
    SubmitTransactionFailureMissingDatums(SubmitTransactionFailureMissingDatums),
    SubmitTransactionFailureUnknownOutputReference(SubmitTransactionFailureUnknownOutputReference),
    SubmitTransactionFailureMissingCostModels(SubmitTransactionFailureMissingCostModels),
    SubmitTransactionFailureExecutionBudgetOutOfBounds(
        SubmitTransactionFailureExecutionBudgetOutOfBounds,
    ),
}
impl ::std::convert::From<&Self> for ScriptExecutionFailure {
    fn from(value: &ScriptExecutionFailure) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SubmitTransactionFailureExtraneousRedeemers> for ScriptExecutionFailure {
    fn from(value: SubmitTransactionFailureExtraneousRedeemers) -> Self {
        Self::SubmitTransactionFailureExtraneousRedeemers(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingDatums> for ScriptExecutionFailure {
    fn from(value: SubmitTransactionFailureMissingDatums) -> Self {
        Self::SubmitTransactionFailureMissingDatums(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownOutputReference>
    for ScriptExecutionFailure
{
    fn from(value: SubmitTransactionFailureUnknownOutputReference) -> Self {
        Self::SubmitTransactionFailureUnknownOutputReference(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingCostModels> for ScriptExecutionFailure {
    fn from(value: SubmitTransactionFailureMissingCostModels) -> Self {
        Self::SubmitTransactionFailureMissingCostModels(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureExecutionBudgetOutOfBounds>
    for ScriptExecutionFailure
{
    fn from(value: SubmitTransactionFailureExecutionBudgetOutOfBounds) -> Self {
        Self::SubmitTransactionFailureExecutionBudgetOutOfBounds(value)
    }
}
#[doc = "ScriptExecutionFailureInvalidRedeemerPointersCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3011"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ScriptExecutionFailureInvalidRedeemerPointersCode(i64);
impl ::std::ops::Deref for ScriptExecutionFailureInvalidRedeemerPointersCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<ScriptExecutionFailureInvalidRedeemerPointersCode> for i64 {
    fn from(value: ScriptExecutionFailureInvalidRedeemerPointersCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ScriptExecutionFailureInvalidRedeemerPointersCode>
    for ScriptExecutionFailureInvalidRedeemerPointersCode
{
    fn from(value: &ScriptExecutionFailureInvalidRedeemerPointersCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for ScriptExecutionFailureInvalidRedeemerPointersCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3011_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for ScriptExecutionFailureInvalidRedeemerPointersCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "ScriptExecutionFailureInvalidRedeemerPointersData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingScripts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ScriptExecutionFailureInvalidRedeemerPointersData {
    #[serde(rename = "missingScripts")]
    pub missing_scripts: ::std::vec::Vec<RedeemerPointer>,
}
impl ::std::convert::From<&ScriptExecutionFailureInvalidRedeemerPointersData>
    for ScriptExecutionFailureInvalidRedeemerPointersData
{
    fn from(value: &ScriptExecutionFailureInvalidRedeemerPointersData) -> Self {
        value.clone()
    }
}
#[doc = "ScriptExecutionFailureUnsuitableOutputReferenceCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3013"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ScriptExecutionFailureUnsuitableOutputReferenceCode(i64);
impl ::std::ops::Deref for ScriptExecutionFailureUnsuitableOutputReferenceCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<ScriptExecutionFailureUnsuitableOutputReferenceCode> for i64 {
    fn from(value: ScriptExecutionFailureUnsuitableOutputReferenceCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ScriptExecutionFailureUnsuitableOutputReferenceCode>
    for ScriptExecutionFailureUnsuitableOutputReferenceCode
{
    fn from(value: &ScriptExecutionFailureUnsuitableOutputReferenceCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for ScriptExecutionFailureUnsuitableOutputReferenceCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3013_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for ScriptExecutionFailureUnsuitableOutputReferenceCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "ScriptExecutionFailureUnsuitableOutputReferenceData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unsuitableOutputReference\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unsuitableOutputReference\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ScriptExecutionFailureUnsuitableOutputReferenceData {
    #[serde(rename = "unsuitableOutputReference")]
    pub unsuitable_output_reference: TransactionOutputReference,
}
impl ::std::convert::From<&ScriptExecutionFailureUnsuitableOutputReferenceData>
    for ScriptExecutionFailureUnsuitableOutputReferenceData
{
    fn from(value: &ScriptExecutionFailureUnsuitableOutputReferenceData) -> Self {
        value.clone()
    }
}
#[doc = "ScriptExecutionFailureValidationFailureCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3012"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ScriptExecutionFailureValidationFailureCode(i64);
impl ::std::ops::Deref for ScriptExecutionFailureValidationFailureCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<ScriptExecutionFailureValidationFailureCode> for i64 {
    fn from(value: ScriptExecutionFailureValidationFailureCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ScriptExecutionFailureValidationFailureCode>
    for ScriptExecutionFailureValidationFailureCode
{
    fn from(value: &ScriptExecutionFailureValidationFailureCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for ScriptExecutionFailureValidationFailureCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3012_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for ScriptExecutionFailureValidationFailureCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "ScriptExecutionFailureValidationFailureData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"traces\","]
#[doc = "    \"validationError\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"traces\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"validationError\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ScriptExecutionFailureValidationFailureData {
    pub traces: ::std::vec::Vec<::std::string::String>,
    #[serde(rename = "validationError")]
    pub validation_error: ::std::string::String,
}
impl ::std::convert::From<&ScriptExecutionFailureValidationFailureData>
    for ScriptExecutionFailureValidationFailureData
{
    fn from(value: &ScriptExecutionFailureValidationFailureData) -> Self {
        value.clone()
    }
}
#[doc = "ScriptExecutionPrices"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ScriptExecutionPrices\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cpu\","]
#[doc = "    \"memory\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cpu\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"memory\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ScriptExecutionPrices {
    pub cpu: Ratio,
    pub memory: Ratio,
}
impl ::std::convert::From<&ScriptExecutionPrices> for ScriptExecutionPrices {
    fn from(value: &ScriptExecutionPrices) -> Self {
        value.clone()
    }
}
#[doc = "A phase-1 monetary script. Timelocks constraints are only supported since Allegra."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Script<Native>\","]
#[doc = "  \"description\": \"A phase-1 monetary script. Timelocks constraints are only supported since Allegra.\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"clause\": \"signature\","]
#[doc = "      \"from\": \"3c07030e36bfff7cd2f004356ef320f3fe3c07030e7cd2f004356437\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"clause\": \"all\","]
#[doc = "      \"from\": ["]
#[doc = "        {"]
#[doc = "          \"clause\": \"signature\","]
#[doc = "          \"from\": \"ec09e5293d384637cd2f004356ef320f3fe3c07030e36bfffe67e2e2\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"clause\": \"signature\","]
#[doc = "          \"from\": \"3c07030e36bfff7cd2f004356ef320f3fe3c07030e7cd2f004356437\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"atLeast\": 2,"]
#[doc = "      \"clause\": \"some\","]
#[doc = "      \"from\": ["]
#[doc = "        {"]
#[doc = "          \"clause\": \"signature\","]
#[doc = "          \"from\": \"ec09e5293d384637cd2f004356ef320f3fe3c07030e36bfffe67e2e2\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"clause\": \"signature\","]
#[doc = "          \"from\": \"3c07030e36bfff7cd2f004356ef320f3fe3c07030e7cd2f004356437\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"clause\": \"after\","]
#[doc = "          \"slot\": 42"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<Signature>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"clause\","]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"signature\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<Any>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"clause\","]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"any\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Script<Native>\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<All>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"clause\","]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"all\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Script<Native>\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<Some>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"atLeast\","]
#[doc = "        \"clause\","]
#[doc = "        \"from\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"atLeast\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"some\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Script<Native>\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<Before>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"clause\","]
#[doc = "        \"slot\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"before\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"slot\": {"]
#[doc = "          \"$ref\": \"#/definitions/Slot\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"Clause<After>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"clause\","]
#[doc = "        \"slot\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"clause\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"after\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"slot\": {"]
#[doc = "          \"$ref\": \"#/definitions/Slot\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "clause", deny_unknown_fields)]
pub enum ScriptNative {
    #[doc = "Clause<Signature>"]
    #[serde(rename = "signature")]
    Signature { from: DigestBlake2b224 },
    #[doc = "Clause<Any>"]
    #[serde(rename = "any")]
    Any { from: ::std::vec::Vec<ScriptNative> },
    #[doc = "Clause<All>"]
    #[serde(rename = "all")]
    All { from: ::std::vec::Vec<ScriptNative> },
    #[doc = "Clause<Some>"]
    #[serde(rename = "some")]
    Some {
        #[serde(rename = "atLeast")]
        at_least: i64,
        from: ::std::vec::Vec<ScriptNative>,
    },
    #[doc = "Clause<Before>"]
    #[serde(rename = "before")]
    Before { slot: Slot },
    #[doc = "Clause<After>"]
    #[serde(rename = "after")]
    After { slot: Slot },
}
impl ::std::convert::From<&Self> for ScriptNative {
    fn from(value: &ScriptNative) -> Self {
        value.clone()
    }
}
#[doc = "ScriptPurpose"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ScriptPurpose\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Spend>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"outputReference\","]
#[doc = "        \"purpose\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"outputReference\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "        },"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"spend\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Mint>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"policy\","]
#[doc = "        \"purpose\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"policy\": {"]
#[doc = "          \"$ref\": \"#/definitions/PolicyId\""]
#[doc = "        },"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"mint\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Publish>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"certificate\","]
#[doc = "        \"purpose\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"certificate\": {"]
#[doc = "          \"$ref\": \"#/definitions/Certificate\""]
#[doc = "        },"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"publish\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Withdraw>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"purpose\","]
#[doc = "        \"rewardAccount\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"withdraw\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"rewardAccount\": {"]
#[doc = "          \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Propose>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"proposal\","]
#[doc = "        \"purpose\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"proposal\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceProposal\""]
#[doc = "        },"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"propose\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ScriptPurpose<Vote>\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"issuer\","]
#[doc = "        \"purpose\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"issuer\": {"]
#[doc = "          \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "        },"]
#[doc = "        \"purpose\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"vote\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "purpose", deny_unknown_fields)]
pub enum ScriptPurpose {
    #[doc = "ScriptPurpose<Spend>"]
    #[serde(rename = "spend")]
    Spend {
        #[serde(rename = "outputReference")]
        output_reference: TransactionOutputReference,
    },
    #[doc = "ScriptPurpose<Mint>"]
    #[serde(rename = "mint")]
    Mint { policy: PolicyId },
    #[doc = "ScriptPurpose<Publish>"]
    #[serde(rename = "publish")]
    Publish { certificate: Certificate },
    #[doc = "ScriptPurpose<Withdraw>"]
    #[serde(rename = "withdraw")]
    Withdraw {
        #[serde(rename = "rewardAccount")]
        reward_account: RewardAccount,
    },
    #[doc = "ScriptPurpose<Propose>"]
    #[serde(rename = "propose")]
    Propose { proposal: GovernanceProposal },
    #[doc = "ScriptPurpose<Vote>"]
    #[serde(rename = "vote")]
    Vote { issuer: GovernanceVoter },
}
impl ::std::convert::From<&Self> for ScriptPurpose {
    fn from(value: &ScriptPurpose) -> Self {
        value.clone()
    }
}
#[doc = "A signatory (EdDSA) for the transaction. The fields 'chainCode' and 'addressAttributes' are only present on bootstrap signatures (when spending from a Byron/Bootstrap address)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Signatory\","]
#[doc = "  \"description\": \"A signatory (EdDSA) for the transaction. The fields 'chainCode' and 'addressAttributes' are only present on bootstrap signatures (when spending from a Byron/Bootstrap address).\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"addressAttributes\": \"cA==\","]
#[doc = "      \"chainCode\": \"b6dbf0b03c93afe5696f10d49e8a8304ebfac01deeb8f82f2af5836ebbc1b450\","]
#[doc = "      \"key\": \"deeb8f82f2af5836ebbc1b450b6dbf0b03c93afe5696f10d49e8a8304ebfac01\","]
#[doc = "      \"signature\": \"deeb8f82f2af5836ebbc1b450b6dbf0b03c93afe5696f10d49e8a8304ebfac01deeb8f82f2af5836ebbc1b4ffffffff\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"key\": \"0c02af01eaacc939b3d0d817f4eb57d323ea5686cb1fecb8de821df1296b84a7\","]
#[doc = "      \"signature\": \"deeb8f82f2af5836ebbc1b450b6dbf0b03c93afe5696f10d49e8a8304ebfac01deeb8f82f2af5836ebbc1b4ffffffff\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"key\","]
#[doc = "    \"signature\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"addressAttributes\": {"]
#[doc = "      \"$ref\": \"#/definitions/AddressAttributes\""]
#[doc = "    },"]
#[doc = "    \"chainCode\": {"]
#[doc = "      \"$ref\": \"#/definitions/ChainCode\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"$ref\": \"#/definitions/Signature\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Signatory {
    #[serde(
        rename = "addressAttributes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub address_attributes: ::std::option::Option<AddressAttributes>,
    #[serde(
        rename = "chainCode",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub chain_code: ::std::option::Option<ChainCode>,
    pub key: VerificationKey,
    pub signature: Signature,
}
impl ::std::convert::From<&Signatory> for Signatory {
    fn from(value: &Signatory) -> Self {
        value.clone()
    }
}
#[doc = "An EdDSA signature."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Signature\","]
#[doc = "  \"description\": \"An EdDSA signature.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 128,"]
#[doc = "  \"minLength\": 128,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct Signature(::std::string::String);
impl ::std::ops::Deref for Signature {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Signature> for ::std::string::String {
    fn from(value: Signature) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Signature> for Signature {
    fn from(value: &Signature) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for Signature {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 128usize {
            return Err("longer than 128 characters".into());
        }
        if value.len() < 128usize {
            return Err("shorter than 128 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for Signature {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Signature {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Signature {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for Signature {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Get size and capacities of the mempool (acquired snapshot)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SizeOfMempool\","]
#[doc = "  \"description\": \"Get size and capacities of the mempool (acquired snapshot).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"sizeOfMempool\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SizeOfMempool {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: SizeOfMempoolJsonrpc,
    pub method: SizeOfMempoolMethod,
}
impl ::std::convert::From<&SizeOfMempool> for SizeOfMempool {
    fn from(value: &SizeOfMempool) -> Self {
        value.clone()
    }
}
#[doc = "SizeOfMempoolJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SizeOfMempoolJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SizeOfMempoolJsonrpc {
    fn from(value: &SizeOfMempoolJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SizeOfMempoolJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SizeOfMempoolJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SizeOfMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SizeOfMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SizeOfMempoolJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SizeOfMempoolMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"sizeOfMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SizeOfMempoolMethod {
    #[serde(rename = "sizeOfMempool")]
    SizeOfMempool,
}
impl ::std::convert::From<&Self> for SizeOfMempoolMethod {
    fn from(value: &SizeOfMempoolMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SizeOfMempoolMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SizeOfMempool => write!(f, "sizeOfMempool"),
        }
    }
}
impl ::std::str::FromStr for SizeOfMempoolMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "sizeOfMempool" => Ok(Self::SizeOfMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SizeOfMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SizeOfMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SizeOfMempoolMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SizeOfMempoolResponseJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SizeOfMempoolResponseJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SizeOfMempoolResponseJsonrpc {
    fn from(value: &SizeOfMempoolResponseJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SizeOfMempoolResponseJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SizeOfMempoolResponseJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SizeOfMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SizeOfMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SizeOfMempoolResponseJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SizeOfMempoolResponseMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"sizeOfMempool\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SizeOfMempoolResponseMethod {
    #[serde(rename = "sizeOfMempool")]
    SizeOfMempool,
}
impl ::std::convert::From<&Self> for SizeOfMempoolResponseMethod {
    fn from(value: &SizeOfMempoolResponseMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SizeOfMempoolResponseMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SizeOfMempool => write!(f, "sizeOfMempool"),
        }
    }
}
impl ::std::str::FromStr for SizeOfMempoolResponseMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "sizeOfMempool" => Ok(Self::SizeOfMempool),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SizeOfMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SizeOfMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SizeOfMempoolResponseMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "An absolute slot number."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Slot\","]
#[doc = "  \"description\": \"An absolute slot number.\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 1.8446744073709552e19,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Slot(pub u64);
impl ::std::ops::Deref for Slot {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<Slot> for u64 {
    fn from(value: Slot) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Slot> for Slot {
    fn from(value: &Slot) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for Slot {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Slot {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for Slot {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for Slot {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for Slot {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for Slot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "A slot length in milliseconds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SlotLength\","]
#[doc = "  \"description\": \"A slot length in milliseconds\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"milliseconds\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"milliseconds\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SlotLength {
    pub milliseconds: i64,
}
impl ::std::convert::From<&SlotLength> for SlotLength {
    fn from(value: &SlotLength) -> Self {
        value.clone()
    }
}
#[doc = "SoftwareVersion"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SoftwareVersion\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"appName\","]
#[doc = "    \"number\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"appName\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"number\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SoftwareVersion {
    #[serde(rename = "appName")]
    pub app_name: ::std::string::String,
    pub number: UInt32,
}
impl ::std::convert::From<&SoftwareVersion> for SoftwareVersion {
    fn from(value: &SoftwareVersion) -> Self {
        value.clone()
    }
}
#[doc = "A stake address (a.k.a reward account)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"StakeAddress\","]
#[doc = "  \"description\": \"A stake address (a.k.a reward account)\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"stake179kzq4qulejydh045yzxwk4ksx780khkl4gdve9kzwd9vjcek9u8h\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(stake|stake_test)1[0-9a-z]*$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct StakeAddress(::std::string::String);
impl ::std::ops::Deref for StakeAddress {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<StakeAddress> for ::std::string::String {
    fn from(value: StakeAddress) -> Self {
        value.0
    }
}
impl ::std::convert::From<&StakeAddress> for StakeAddress {
    fn from(value: &StakeAddress) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StakeAddress {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(stake|stake_test)1[0-9a-z]*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(stake|stake_test)1[0-9a-z]*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for StakeAddress {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StakeAddress {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StakeAddress {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for StakeAddress {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The field 'stake' is only present when explicitly requested (see related state-queries)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"StakePool\","]
#[doc = "  \"description\": \"The field 'stake' is only present when explicitly requested (see related state-queries).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cost\","]
#[doc = "    \"id\","]
#[doc = "    \"margin\","]
#[doc = "    \"owners\","]
#[doc = "    \"pledge\","]
#[doc = "    \"relays\","]
#[doc = "    \"rewardAccount\","]
#[doc = "    \"vrfVerificationKeyHash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    },"]
#[doc = "    \"margin\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    },"]
#[doc = "    \"owners\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"pledge\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"relays\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Relay\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"rewardAccount\": {"]
#[doc = "      \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"vrfVerificationKeyHash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePool {
    pub cost: ValueAdaOnly,
    pub id: StakePoolId,
    pub margin: Ratio,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub metadata: ::std::option::Option<Anchor>,
    pub owners: ::std::vec::Vec<DigestBlake2b224>,
    pub pledge: ValueAdaOnly,
    pub relays: ::std::vec::Vec<Relay>,
    #[serde(rename = "rewardAccount")]
    pub reward_account: RewardAccount,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stake: ::std::option::Option<ValueAdaOnly>,
    #[serde(rename = "vrfVerificationKeyHash")]
    pub vrf_verification_key_hash: DigestBlake2b256,
}
impl ::std::convert::From<&StakePool> for StakePool {
    fn from(value: &StakePool) -> Self {
        value.clone()
    }
}
#[doc = "A Blake2b 28-byte hash digest of a pool's verification key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"StakePoolId\","]
#[doc = "  \"description\": \"A Blake2b 28-byte hash digest of a pool's verification key.\","]
#[doc = "  \"examples\": ["]
#[doc = "    \"pool1qqqqpanw9zc0rzh0yp247nzf2s35uvnsm7aaesfl2nnejaev0uc\","]
#[doc = "    \"pool1qqqqqdk4zhsjuxxd8jyvwncf5eucfskz0xjjj64fdmlgj735lr9\""]
#[doc = "  ],"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^pool1[0-9a-z]*$\","]
#[doc = "  \"contentEncoding\": \"bech32\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct StakePoolId(::std::string::String);
impl ::std::ops::Deref for StakePoolId {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<StakePoolId> for ::std::string::String {
    fn from(value: StakePoolId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&StakePoolId> for StakePoolId {
    fn from(value: &StakePoolId) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StakePoolId {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^pool1[0-9a-z]*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^pool1[0-9a-z]*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for StakePoolId {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StakePoolId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StakePoolId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for StakePoolId {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "StakePoolSummary"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"approximatePerformance\","]
#[doc = "    \"id\","]
#[doc = "    \"ownerStake\","]
#[doc = "    \"parameters\","]
#[doc = "    \"stake\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"approximatePerformance\": {"]
#[doc = "      \"description\": \"Number of blocks produced divided by expected number of blocks (based on stake and epoch progress). Can be larger than 1.0 for pools that get lucky.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    },"]
#[doc = "    \"ownerStake\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"parameters\": {"]
#[doc = "      \"description\": \"Some of the pool parameters relevant for the reward calculation.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cost\","]
#[doc = "        \"margin\","]
#[doc = "        \"pledge\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cost\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"margin\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"pledge\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePoolSummary {
    #[serde(rename = "approximatePerformance")]
    pub approximate_performance: f64,
    pub id: StakePoolId,
    #[serde(rename = "ownerStake")]
    pub owner_stake: ValueAdaOnly,
    pub parameters: StakePoolSummaryParameters,
    pub stake: ValueAdaOnly,
}
impl ::std::convert::From<&StakePoolSummary> for StakePoolSummary {
    fn from(value: &StakePoolSummary) -> Self {
        value.clone()
    }
}
#[doc = "Some of the pool parameters relevant for the reward calculation."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Some of the pool parameters relevant for the reward calculation.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cost\","]
#[doc = "    \"margin\","]
#[doc = "    \"pledge\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"margin\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"pledge\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePoolSummaryParameters {
    pub cost: ValueAdaOnly,
    pub margin: Ratio,
    pub pledge: ValueAdaOnly,
}
impl ::std::convert::From<&StakePoolSummaryParameters> for StakePoolSummaryParameters {
    fn from(value: &StakePoolSummaryParameters) -> Self {
        value.clone()
    }
}
#[doc = "StakePoolVotingThresholds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"StakePoolVotingThresholds\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"constitutionalCommittee\","]
#[doc = "    \"hardForkInitiation\","]
#[doc = "    \"noConfidence\","]
#[doc = "    \"protocolParametersUpdate\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"constitutionalCommittee\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"default\","]
#[doc = "        \"stateOfNoConfidence\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"default\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        },"]
#[doc = "        \"stateOfNoConfidence\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"hardForkInitiation\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"noConfidence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"protocolParametersUpdate\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"security\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"security\": {"]
#[doc = "          \"$ref\": \"#/definitions/Ratio\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePoolVotingThresholds {
    #[serde(rename = "constitutionalCommittee")]
    pub constitutional_committee: StakePoolVotingThresholdsConstitutionalCommittee,
    #[serde(rename = "hardForkInitiation")]
    pub hard_fork_initiation: Ratio,
    #[serde(rename = "noConfidence")]
    pub no_confidence: Ratio,
    #[serde(rename = "protocolParametersUpdate")]
    pub protocol_parameters_update: StakePoolVotingThresholdsProtocolParametersUpdate,
}
impl ::std::convert::From<&StakePoolVotingThresholds> for StakePoolVotingThresholds {
    fn from(value: &StakePoolVotingThresholds) -> Self {
        value.clone()
    }
}
#[doc = "StakePoolVotingThresholdsConstitutionalCommittee"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"default\","]
#[doc = "    \"stateOfNoConfidence\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"default\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    },"]
#[doc = "    \"stateOfNoConfidence\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePoolVotingThresholdsConstitutionalCommittee {
    pub default: Ratio,
    #[serde(rename = "stateOfNoConfidence")]
    pub state_of_no_confidence: Ratio,
}
impl ::std::convert::From<&StakePoolVotingThresholdsConstitutionalCommittee>
    for StakePoolVotingThresholdsConstitutionalCommittee
{
    fn from(value: &StakePoolVotingThresholdsConstitutionalCommittee) -> Self {
        value.clone()
    }
}
#[doc = "StakePoolVotingThresholdsProtocolParametersUpdate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"security\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"security\": {"]
#[doc = "      \"$ref\": \"#/definitions/Ratio\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StakePoolVotingThresholdsProtocolParametersUpdate {
    pub security: Ratio,
}
impl ::std::convert::From<&StakePoolVotingThresholdsProtocolParametersUpdate>
    for StakePoolVotingThresholdsProtocolParametersUpdate
{
    fn from(value: &StakePoolVotingThresholdsProtocolParametersUpdate) -> Self {
        value.clone()
    }
}
#[doc = "Submit a signed and serialized transaction to the network."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransaction\","]
#[doc = "  \"description\": \"Submit a signed and serialized transaction to the network.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"description\": \"An arbitrary JSON value that will be mirrored back in the response.\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"2.0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"submitTransaction\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"transaction\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"transaction\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"cbor\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"cbor\": {"]
#[doc = "              \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "              \"contentEncoding\": \"base16\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransaction {
    #[doc = "An arbitrary JSON value that will be mirrored back in the response."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::serde_json::Value>,
    pub jsonrpc: SubmitTransactionJsonrpc,
    pub method: SubmitTransactionMethod,
    pub params: SubmitTransactionParams,
}
impl ::std::convert::From<&SubmitTransaction> for SubmitTransaction {
    fn from(value: &SubmitTransaction) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionDeserialisationErrorJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionDeserialisationErrorJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SubmitTransactionDeserialisationErrorJsonrpc {
    fn from(value: &SubmitTransactionDeserialisationErrorJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionDeserialisationErrorJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionDeserialisationErrorJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionDeserialisationErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SubmitTransactionDeserialisationErrorJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for SubmitTransactionDeserialisationErrorJsonrpc
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionDeserialisationErrorMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"submitTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionDeserialisationErrorMethod {
    #[serde(rename = "submitTransaction")]
    SubmitTransaction,
}
impl ::std::convert::From<&Self> for SubmitTransactionDeserialisationErrorMethod {
    fn from(value: &SubmitTransactionDeserialisationErrorMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionDeserialisationErrorMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SubmitTransaction => write!(f, "submitTransaction"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionDeserialisationErrorMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "submitTransaction" => Ok(Self::SubmitTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionDeserialisationErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SubmitTransactionDeserialisationErrorMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for SubmitTransactionDeserialisationErrorMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionErrorJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionErrorJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SubmitTransactionErrorJsonrpc {
    fn from(value: &SubmitTransactionErrorJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionErrorJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionErrorJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionErrorJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionErrorMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"submitTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionErrorMethod {
    #[serde(rename = "submitTransaction")]
    SubmitTransaction,
}
impl ::std::convert::From<&Self> for SubmitTransactionErrorMethod {
    fn from(value: &SubmitTransactionErrorMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionErrorMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SubmitTransaction => write!(f, "submitTransaction"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionErrorMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "submitTransaction" => Ok(Self::SubmitTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionErrorMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionFailure"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<EraMismatch>\","]
#[doc = "      \"description\": \"Failed to submit the transaction in the current era. This may happen when trying to submit a transaction near an era boundary (i.e. at the moment of a hard-fork).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3005"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"$ref\": \"#/definitions/EraMismatch\""]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidSignatories>\","]
#[doc = "      \"description\": \"Some signatures are invalid. Only the serialised transaction *body*, without metadata or witnesses, must be signed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3100"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"invalidSignatories\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"invalidSignatories\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingSignatories>\","]
#[doc = "      \"description\": \"Some signatures are missing. A signed transaction must carry signatures for all inputs locked by verification keys or a native script. Transaction may also need signatures for each required extra signatories often required by Plutus Scripts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3101"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"missingSignatories\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"missingSignatories\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingScripts>\","]
#[doc = "      \"description\": \"Some script witnesses are missing. Indeed, any script used in a transaction (when spending, minting, withdrawing or publishing certificates) must be provided in full with the transaction. Scripts must therefore be added either to the witness set or provided as a reference inputs should you use Plutus V2+ and a format from Babbage and beyond.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3102"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"missingScripts\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"missingScripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<FailingNativeScript>\","]
#[doc = "      \"description\": \"The transaction contains failing phase-1 monetary scripts (a.k.a. native scripts). This can be due to either a missing or invalid signature, or because of a time validity issue. The field 'data.failingNativeScripts' contains a list of hash digests of all failing native scripts found in the transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3103"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"failingNativeScripts\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"failingNativeScripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ExtraneousScripts>\","]
#[doc = "      \"description\": \"Extraneous (i.e. non-required) scripts found in the transaction. A transaction must not contain scripts that aren't strictly needed for validation, that are present in metadata or that are published in an output. Perhaps you have used provided a wrong script for a validator? Anyway, the 'data.extraneousScripts' field lists hash digests of scripts found to be extraneous.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3104"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"extraneousScripts\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"extraneousScripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingMetadataHash>\","]
#[doc = "      \"description\": \"Missing required metadata hash in the transaction body. If the transaction includes metadata, then it must also include a hash digest of these serialised metadata in its body to prevent malicious actors from tempering with the data. The field 'data.metadata.hash' contains the expected missing hash digest of the metadata found in the transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3105"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"metadata\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"metadata\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingMetadata>\","]
#[doc = "      \"description\": \"No metadata corresponding to a specified metadata hash. It appears that you might have forgotten to attach metadata to a transaction, yet included a hash digest of them in the transaction body? The field 'data.metadata.hash' contains the orphan hash found in the body.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3106"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"metadata\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"metadata\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MetadataHashMismatch>\","]
#[doc = "      \"description\": \"There's a mismatch between the provided metadata hash digest and the one computed from the actual metadata. The two must match exactly. The field 'data.provided.hash' references the provided hash as found in the transaction body, whereas 'data.computed.hash' contains the one the ledger computed from the actual metadata.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3107"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"computed\","]
#[doc = "            \"provided\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"computed\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"provided\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"hash\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"hash\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidMetadata>\","]
#[doc = "      \"description\": \"Invalid metadatum found in transaction metadata. Metadata byte strings must be no longer than 64-bytes and text strings must be no longer than 64 bytes once UTF-8-encoded. Some metadatum in the transaction infringe this rule.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3108"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingRedeemers>\","]
#[doc = "      \"description\": \"Missing required redeemer(s) for Plutus scripts. There are validators needed for the transaction that do not have an associated redeemer. Redeemer are provided when trying to execute the validation logic of a script (e.g. when spending from an input locked by a script, or minting assets from a Plutus monetary policy. The field 'data.missingRedeemers' lists the different purposes for which a redeemer hasn't been provided.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3109"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"missingRedeemers\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"missingRedeemers\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/ScriptPurpose\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<ExtraneousRedeemers>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<MissingDatums>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ExtraneousDatums>\","]
#[doc = "      \"description\": \"The transaction failed because it contains datums not associated with any script or output. This could be because you've left some orphan datum behind, because you've listed the wrong inputs in the transaction or because you've just forgotten to include a datum associated with an input. Either way, the field 'data.extraneousDatums' contains a set of data hashes for these extraneous datums.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3112"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"extraneousDatums\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"extraneousDatums\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ScriptIntegrityHashMismatch>\","]
#[doc = "      \"description\": \"The transaction failed because the provided script integrity hash doesn't match the computed one. This is crucial for ensuring the integrity of cost models and Plutus version used during script execution. The field 'data.providedScriptIntegrity' correspond to what was given, if any, and 'data.computedScriptIntegrity' is what was expected. If the latter is null, this means you shouldn't have included a script integrity hash to begin with.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3113"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"computedScriptIntegrity\","]
#[doc = "            \"providedScriptIntegrity\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"computedScriptIntegrity\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"providedScriptIntegrity\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<OrphanScriptInputs>\","]
#[doc = "      \"description\": \"This is bad, you're trying to spend inputs that are locked by Plutus scripts, but have no associated datums. Those inputs are so-to-speak unspendable (at least with the current ledger rules). There's nothing you can do apart from re-creating these UTxOs but with a corresponding datum this time. The field 'data.orphanScriptInputs' lists all such inputs found in the transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3114"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"orphanScriptInputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"orphanScriptInputs\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<MissingCostModels>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MalformedScripts>\","]
#[doc = "      \"description\": \"Some Plutus scripts in the witness set or in an output are invalid. Scripts must be well-formed flat-encoded Plutus scripts, CBOR-encoded. Yes, there's a double binary encoding. The outer-most encoding is therefore just a plain CBOR bytestring. Note that some tools such as the cardano-cli triple encode scripts for some reasons, resulting in a double outer-most CBOR encoding. Make sure that your script are correctly encoded. The field 'data.malformedScripts' lists the hash digests of all the problematic scripts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3116"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"malformedScripts\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"malformedScripts\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<UnknownOutputReference>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<OutsideOfValidityInterval>\","]
#[doc = "      \"description\": \"The transaction is outside of its validity interval. It was either submitted too early or too late. A transaction that has a lower validity bound can only be accepted by the ledger (and make it to the mempool) if the ledger's current slot is greater than the specified bound. The upper bound works similarly, as a time to live. The field 'data.currentSlot' contains the current slot as known of the ledger (this may be different from the current network slot if the ledger is still catching up). The field 'data.validityInterval' is a reminder of the validity interval provided with the transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3118"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"currentSlot\","]
#[doc = "            \"validityInterval\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"currentSlot\": {"]
#[doc = "              \"$ref\": \"#/definitions/Slot\""]
#[doc = "            },"]
#[doc = "            \"validityInterval\": {"]
#[doc = "              \"$ref\": \"#/definitions/ValidityInterval\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<TransactionTooLarge>\","]
#[doc = "      \"description\": \"The transaction exceeds the maximum size allowed by the protocol. Indeed, once serialized, transactions must be under a bytes limit specified by a protocol parameter. The field 'data.measuredTransactionSize' indicates the actual measured size of your serialized transaction, whereas 'data.maximumTransactionSize' indicates the current maximum size enforced by the ledger.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3119"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"maximumTransactionSize\","]
#[doc = "            \"measuredTransactionSize\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"maximumTransactionSize\": {"]
#[doc = "              \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "            },"]
#[doc = "            \"measuredTransactionSize\": {"]
#[doc = "              \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ValueTooLarge>\","]
#[doc = "      \"description\": \"Some output values in the transaction are too large. Once serialized, values must be below a certain threshold. That threshold sits around 4 KB during the Mary era, and was then made configurable as a protocol parameter in later era. The field 'data.excessivelyLargeOutputs' lists all transaction outputs with values that are above the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3120"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"excessivelyLargeOutputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"excessivelyLargeOutputs\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<EmptyInputSet>\","]
#[doc = "      \"description\": \"Transaction must have at least one input, but this one has an empty input set. One input is necessary to prevent replayability of transactions, as it piggybacks on the unique spendable property of UTxO.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3121"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<TransactionFeeTooSmall>\","]
#[doc = "      \"description\": \"Insufficient fee! The transaction doesn't not contain enough fee to cover the minimum required by the protocol. Note that fee depends on (a) a flat cost fixed by the protocol, (b) the size of the serialized transaction, (c) the budget allocated for Plutus script execution. The field 'data.minimumRequiredFee' indicates the minimum required fee whereas 'data.providedFee' refers to the fee currently supplied with the transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3122"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"minimumRequiredFee\","]
#[doc = "            \"providedFee\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"minimumRequiredFee\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"providedFee\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ValueNotConserved>\","]
#[doc = "      \"description\": \"In and out value not conserved. The transaction must *exactly* balance: every input must be accounted for. There are various things counting as 'in balance': (a) the total value locked by inputs (or collateral inputs in case of a failing script), (b) rewards coming from withdrawals and (c) return deposits from stake credential or pool de-registration. In a similar fashion, various things count towards the 'out balance': (a) the total value assigned to each transaction output, (b) the fee and (c) any deposit for stake credential or pool registration. The field 'data.valueConsumed' contains the total 'in balance', and 'data.valueProduced' indicates the total amount counting as 'out balance'.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3123"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"valueConsumed\","]
#[doc = "            \"valueProduced\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"valueConsumed\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value\""]
#[doc = "            },"]
#[doc = "            \"valueProduced\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<NetworkMismatch>\","]
#[doc = "      \"description\": \"Some discriminated entities in the transaction are configured for another network. In fact, payment addresses, stake addresses and stake pool registration certificates are bound to a specific network identifier. This identifier must match the network you're trying to submit them to. Since the Alonzo era, transactions themselves may also contain a network identifier. The field 'data.expectedNetwork' indicates what is the currrently expected network. The field 'data.discriminatedType' indicates what type of entity is causing an issue here. And 'data.invalidEntities' lists all the culprits found in the transaction. The latter isn't present when the transaction's network identifier itself is wrong.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3124"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"discriminatedType\","]
#[doc = "                \"expectedNetwork\","]
#[doc = "                \"invalidEntities\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"discriminatedType\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"address\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"expectedNetwork\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Network\""]
#[doc = "                },"]
#[doc = "                \"invalidEntities\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Address\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"discriminatedType\","]
#[doc = "                \"expectedNetwork\","]
#[doc = "                \"invalidEntities\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"discriminatedType\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"rewardAccount\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"expectedNetwork\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Network\""]
#[doc = "                },"]
#[doc = "                \"invalidEntities\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"discriminatedType\","]
#[doc = "                \"expectedNetwork\","]
#[doc = "                \"invalidEntities\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"discriminatedType\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"stakePoolCertificate\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"expectedNetwork\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Network\""]
#[doc = "                },"]
#[doc = "                \"invalidEntities\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"discriminatedType\","]
#[doc = "                \"expectedNetwork\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"discriminatedType\": {"]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"transaction\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"expectedNetwork\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Network\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InsufficientlyFundedOutputs>\","]
#[doc = "      \"description\": \"Some outputs have an insufficient amount of Ada attached to them. In fact, any new output created in a system must pay for the resources it occupies. Because user-created assets are worthless (from the point of view of the protocol), those resources must be paid in the form of a Ada deposit. The exact depends on the size of the serialized output: the more assets, the higher the amount. The field 'data.insufficientlyFundedOutputs.[].output' contains a list of all transaction outputs that are insufficiently funded. Starting from the Babbage era, the field 'data.insufficientlyFundedOutputs.[].minimumRequiredValue' indicates the required amount of Lovelace (1e6 Lovelace = 1 Ada) needed for each output.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3125"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"insufficientlyFundedOutputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"insufficientlyFundedOutputs\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"output\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"minimumRequiredValue\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "                  },"]
#[doc = "                  \"output\": {"]
#[doc = "                    \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<BootstrapAttributesTooLarge>\","]
#[doc = "      \"description\": \"Some output associated with legacy / bootstrap (a.k.a. Byron) addresses have attributes that are too large. The field 'data.bootstrapOutputs' lists all affected outputs.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3126"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"bootstrapOutputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"bootstrapOutputs\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MintingOrBurningAda>\","]
#[doc = "      \"description\": \"The transaction is attempting to mint or burn Ada tokens. That is, fortunately, not allowed by the ledger.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3127"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InsufficientCollateral>\","]
#[doc = "      \"description\": \"Insufficient collateral value for Plutus scripts in the transaction. Indeed, when executing scripts, you must provide a collateral amount which minimum is a percentage of the total execution budget for the transaction. The exact percentage is given by a protocol parameter. The field 'data.providedCollateral' indicates the amount currently provided as collateral in the transaction, whereas 'data.minimumRequiredCollateral' indicates the minimum amount expected by the ledger\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3128"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"minimumRequiredCollateral\","]
#[doc = "            \"providedCollateral\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"minimumRequiredCollateral\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"providedCollateral\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<Delta>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<CollateralLockedByScript>\","]
#[doc = "      \"description\": \"Invalid choice of collateral: an input provided for collateral is locked by script. Collateral inputs must be spendable, and the ledger must be able to assert their validity during the first phase of validations (a.k.a phase-1). This discards any input locked by a Plutus script to be used as collateral. Note that for some reason inputs locked by native scripts are also excluded from candidates collateral. The field 'data.unsuitableCollateralInputs' lists all the problematic output references.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3129"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unsuitableCollateralInputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unsuitableCollateralInputs\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnforeseeableSlot>\","]
#[doc = "      \"description\": \"One of the transaction validity bound is outside any foreseeable future. The vision of the ledger in the future when evaluating Plutus scripts is limited because the ledger cannot guarantee that the chain will not hard-fork into a version of the protocol working with a different set of parameters (or even, working with the same consensus protocol). However, the protocol cannot fork in less than `k` blocks, where `k` is the security parameter of the chain. Plus, Ouroboros Praos ensures that there are at least `k` blocks produced in a window of 3 * k / f slots, where `f` is the density parameter, also known as the active slot coefficient. Short story short, you can only set validity interval in a short timespan, which is around ~36h in the future on Mainnet at the moment of writing this error message. The field 'data.unforeseeableSlot' indicates the slot which couldn't be converted to a POSIX time due to hard fork uncertainty.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3130"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unforeseeableSlot\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unforeseeableSlot\": {"]
#[doc = "              \"$ref\": \"#/definitions/Slot\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<TooManyCollateralInputs>\","]
#[doc = "      \"description\": \"The transaction contains too many collateral inputs. The maximum number of collateral inputs is constrained by a protocol parameter. The field 'data.maximumCollateralInputs' contains the current value of that parameter, and 'data.countedCollateralInputs' indicates how many inputs were actually found in your transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3131"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"countedCollateralInputs\","]
#[doc = "            \"maximumCollateralInputs\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"countedCollateralInputs\": {"]
#[doc = "              \"$ref\": \"#/definitions/UInt32\""]
#[doc = "            },"]
#[doc = "            \"maximumCollateralInputs\": {"]
#[doc = "              \"$ref\": \"#/definitions/UInt32\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MissingCollateralInputs>\","]
#[doc = "      \"description\": \"The transaction doesn't provide any collateral inputs but it must. Indeed, when executing scripts, you must provide a collateral amount which is collected by the ledger in case of script execution failure. That collateral serves as a compensation for nodes that aren't thus able to collect normal fees set on the transaction. Note that ledger validations are split in two phases. The first phase regards pretty much every validation outside of script executions. Anything from the first phase doesn't require a collateral and will not consume the collateral in case of failure because they require little computing resources. Besides, in principle, any client application or wallet will prevent you from submitting an invalid transaction to begin with.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3132"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<NonAdaCollateral>\","]
#[doc = "      \"description\": \"One of the input provided as collateral carries something else than Ada tokens. Only Ada can be used as collateral. Since the Babbage era, you also have the option to set a 'collateral return' or 'collateral change' output in order to send the surplus non-Ada tokens to it. Regardless, the field 'data.unsuitableCollateralValue' indicates the actual collateral value found by the ledger\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3133"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unsuitableCollateralValue\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unsuitableCollateralValue\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ExecutionUnitsTooLarge>\","]
#[doc = "      \"description\": \"The transaction execution budget for scripts execution is above the allowed limit. The protocol limits the amount of execution that a single transaction can do. This limit is set by a protocol parameter. The field 'data.maximumExecutionUnits' indicates the current limit and the field 'data.providedExecutionUnits' indicates how much the transaction requires.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3134"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"maximumExecutionUnits\","]
#[doc = "            \"providedExecutionUnits\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"maximumExecutionUnits\": {"]
#[doc = "              \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "            },"]
#[doc = "            \"providedExecutionUnits\": {"]
#[doc = "              \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<TotalCollateralMismatch>\","]
#[doc = "      \"description\": \"There's a mismatch between the declared total collateral amount, and the value computed from the inputs and outputs. These must match exactly. The field 'data.declaredTotalCollateral' reports the amount declared in the transaction whereas 'data.computedTotalCollateral' refers to the amount actually computed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3135"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"computedTotalCollateral\","]
#[doc = "            \"declaredTotalCollateral\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"computedTotalCollateral\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<Delta>\""]
#[doc = "            },"]
#[doc = "            \"declaredTotalCollateral\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<SpendsMismatch>\","]
#[doc = "      \"description\": \"Invalid transaction submitted as valid, or vice-versa. Since Alonzo, the ledger may allow invalid transactions to be submitted and included on-chain, provided that they leave a collateral value as compensation. This prevent certain class of attacks. As a consequence, transactions now have a validity tag with them. Your transaction did not match what that validity tag is stating. The field 'data.declaredSpending' indicates what the transaction is supposed to consume (collaterals or inputs) and the field 'data.mismatchReason' provides more information about the mismatch.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3136"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"declaredSpending\","]
#[doc = "            \"mismatchReason\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"declaredSpending\": {"]
#[doc = "              \"$ref\": \"#/definitions/InputSource\""]
#[doc = "            },"]
#[doc = "            \"mismatchReason\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnauthorizedVotes>\","]
#[doc = "      \"description\": \"The transaction contains votes from unauthorized voters. The field 'data.unauthorizedVotes' indicates the faulty voters and the action they attempted to incorrectly vote for.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3137"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unauthorizedVotes\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unauthorizedVotes\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"proposal\","]
#[doc = "                  \"voter\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"proposal\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "                  },"]
#[doc = "                  \"voter\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnknownGovernanceProposals>\","]
#[doc = "      \"description\": \"Reference(s) to unknown governance proposals found in transaction. This may be because you've indicated a wrong identifier or because the proposal hasn't yet been submitted on-chain. Note that the order in which transactions are submitted matters. The field 'data.unknownProposals' tells you about the unknown references.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3138"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unknownProposals\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unknownProposals\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidProtocolParametersUpdate>\","]
#[doc = "      \"description\": \"The transaction contains an invalid or unauthorized protocol parameters update. This operation is reserved to genesis key holders.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3139"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnknownStakePool>\","]
#[doc = "      \"description\": \"The transaction references an unknown stake pool as a target for delegation or update. Double-check the pool id mentioned in 'data.unknownStakePool'. Note also that order in which transactions are submitted matters; if you're trying to register a pool and delegate to it in one go, make sure to submit transactions in the right order.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3140"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unknownStakePool\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unknownStakePool\": {"]
#[doc = "              \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<IncompleteWithdrawals>\","]
#[doc = "      \"description\": \"The transaction contains incomplete or invalid rewards withdrawals. When present, rewards withdrawals must consume rewards in full, there cannot be any leftover. The field 'data.incompleteWithdrawals' contains a map of withdrawals and their current rewards balance.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3141"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"incompleteWithdrawals\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"incompleteWithdrawals\": {"]
#[doc = "              \"$ref\": \"#/definitions/Withdrawals\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<RetirementTooLate>\","]
#[doc = "      \"description\": \"A stake pool retirement certificate is trying to retire too late in the future. Indeed, there's a maximum delay for stake pool retirement, controlled by a protocol parameter. The field 'data.currentEpoch' indicates the current epoch known of the ledger, 'data.declaredEpoch' refers to the epoch declared in the retirement certificate and 'data.firstInvalidEpoch' is the first epoch considered invalid (too far) for retirement\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3142"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"currentEpoch\","]
#[doc = "            \"declaredEpoch\","]
#[doc = "            \"firstInvalidEpoch\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"currentEpoch\": {"]
#[doc = "              \"$ref\": \"#/definitions/Epoch\""]
#[doc = "            },"]
#[doc = "            \"declaredEpoch\": {"]
#[doc = "              \"$ref\": \"#/definitions/Epoch\""]
#[doc = "            },"]
#[doc = "            \"firstInvalidEpoch\": {"]
#[doc = "              \"$ref\": \"#/definitions/Epoch\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<StakePoolCostTooLow>\","]
#[doc = "      \"description\": \"Stake pool cost declared in a registration or update certificate are below the allowed minimum. The minimum cost of a stake pool is fixed by a protocol parameter. The 'data.minimumStakePoolCost' field holds the current value of that parameter whereas 'data.declaredStakePoolCost' indicates which amount was declared.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3143"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"declaredStakePoolCost\","]
#[doc = "            \"minimumStakePoolCost\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"declaredStakePoolCost\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"minimumStakePoolCost\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<MetadataHashTooLarge>\","]
#[doc = "      \"description\": \"Some hash digest of (optional) stake pool metadata is too long. When registering, stake pools can supply an external metadata file and a hash digest of the content. The hashing algorithm is left open but the output digest must be smaller than 32 bytes. The field 'data.infringingStakePool' indicates which stake pool has an invalid metadata hash and 'data.computedMetadataHashSize' documents the computed hash size.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3144"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"computedMetadataHashSize\","]
#[doc = "            \"infringingStakePool\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"computedMetadataHashSize\": {"]
#[doc = "              \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "            },"]
#[doc = "            \"infringingStakePool\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"id\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"id\": {"]
#[doc = "                  \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<CredentialAlreadyRegistered>\","]
#[doc = "      \"description\": \"Trying to re-register some already known credentials. Stake credentials can only be registered once. This is true for both keys and scripts. The field 'data.knownCredential' points to an already known credential that's being re-registered by this transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3145"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\","]
#[doc = "            \"knownCredential\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "            },"]
#[doc = "            \"knownCredential\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnknownCredential>\","]
#[doc = "      \"description\": \"The transaction references an unknown stake credential. For example, to delegate to a stake pool, you must first register the stake key or script used for delegation. This may be done in the same transaction or in an earlier transaction but cannot happen retro-actively. The field 'data.unknownCredential' indicates what credential is used without being registered.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3146"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"from\","]
#[doc = "            \"unknownCredential\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"from\": {"]
#[doc = "              \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "            },"]
#[doc = "            \"unknownCredential\": {"]
#[doc = "              \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<NonEmptyRewardAccount>\","]
#[doc = "      \"description\": \"Trying to unregister stake credentials associated to a non empty reward account. You must empty the reward account first (or do it as part of the same transaction) to proceed. The field 'data.nonEmptyRewardAccountBalance' indicates how much Lovelace is left in the account.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3147"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"nonEmptyRewardAccountBalance\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"nonEmptyRewardAccountBalance\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidGenesisDelegation>\","]
#[doc = "      \"description\": \"Invalid or unauthorized genesis delegation. The genesis delegate is unknown, invalid or already in use.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3148"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidMIRTransfer>\","]
#[doc = "      \"description\": \"Invalid MIR transfer. The resulting delta is likely negative.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3149"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ForbiddenWithdrawal>\","]
#[doc = "      \"description\": \"The transaction is attempting to withdraw rewards from stake credentials that do not engage in on-chain governance. Credentials must be associated with a delegate representative (registered, abstain or noConfidence) before associated rewards can be withdrawn. The field 'data.marginalizedCredentials' lists all the affected credentials.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3150"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"marginalizedCredentials\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"marginalizedCredentials\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<CredentialDepositMismatch>\","]
#[doc = "      \"description\": \"The deposit specified in a stake credential registration (for delegation or governance) does not match the current value set by protocol parameters. The field 'data.expectedDeposit', when present, indicates the deposit amount as currently expected by ledger.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3151"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"providedDeposit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expectedDeposit\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"providedDeposit\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<DRepAlreadyRegistered>\","]
#[doc = "      \"description\": \"Trying to re-register some already known delegate representative. Delegate representatives can only be registered once. The field 'data.knownDelegateRepresentatives' points to an already known credential that's being re-registered by this transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3152"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"knownDelegateRepresentative\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"knownDelegateRepresentative\": {"]
#[doc = "              \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<DRepNotRegistered>\","]
#[doc = "      \"description\": \"The transaction references an unknown delegate representative. To delegate to a representative, it must first register as such. This may be done in the same transaction or in an earlier transaction but cannot happen retro-actively. The field 'data.unknownDelegateRepresentative' indicates what credential is used without being registered.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3153"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unknownDelegateRepresentative\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unknownDelegateRepresentative\": {"]
#[doc = "              \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnknownConstitutionalCommitteeMember>\","]
#[doc = "      \"description\": \"The transaction references an unknown constitutional committee member. This can be either because that member does not actually exist or because it was registered but has resigned. The field 'data.unknownConstitutionalCommitteeMember' indicates what credential is unknown.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3154"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unknownConstitutionalCommitteeMember\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unknownConstitutionalCommitteeMember\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"from\","]
#[doc = "                \"id\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"from\": {"]
#[doc = "                  \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "                },"]
#[doc = "                \"id\": {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<GovernanceProposalDepositMismatch>\","]
#[doc = "      \"description\": \"There's a mismatch between the proposal deposit amount declared in the transaction and the one expected by the ledger. The deposit is actually configured by a protocol parameter. The field 'data.expectedDeposit' indicates the current configuration and amount expected by the ledger. The field 'data.providedDeposit' is a reminder of the what was set in the submitted transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3155"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"expectedDeposit\","]
#[doc = "            \"providedDeposit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expectedDeposit\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"providedDeposit\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ConflictingCommitteeUpdate>\","]
#[doc = "      \"description\": \"The transaction contains an invalid governance action: it tries to both add members to the committee and remove some of those same members. The field 'data.conflictingMembers' indicates which members are found on both sides.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3156"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"conflictingMembers\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"conflictingMembers\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"from\","]
#[doc = "                  \"id\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"from\": {"]
#[doc = "                    \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "                  },"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidCommitteeUpdate>\","]
#[doc = "      \"description\": \"The transaction contains an invalid governance action: it tries to add new members to the constitutional committee with a retirement epoch in the past. The field 'data.alreadyRetiredMembers' indicates the faulty members that would otherwise be already retired.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3157"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"alreadyRetiredMembers\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"alreadyRetiredMembers\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"from\","]
#[doc = "                  \"id\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"from\": {"]
#[doc = "                    \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "                  },"]
#[doc = "                  \"id\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<TreasuryWithdrawalMismatch>\","]
#[doc = "      \"description\": \"The transaction is trying to withdraw more funds than specified in a governance action! The field 'data.providedWithdrawal' indicates the amount specified in the transaction, whereas 'data.computedWithdrawal' is the actual amount as computed by the ledger.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3158"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"computedWithdrawal\","]
#[doc = "            \"providedWithdrawal\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"computedWithdrawal\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            },"]
#[doc = "            \"providedWithdrawal\": {"]
#[doc = "              \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidOrMissingPreviousProposals>\","]
#[doc = "      \"description\": \"The transaction contains invalid or missing reference to previous (ratified) governance proposals. Indeed, some governance proposals such as protocol parameters update or consitutional committee change must point to last action of the same purpose that was ratified. The field 'data.invalidOrMissingPreviousProposals' contains a list of submitted actions that are missing details. For each item, we provide the anchor of the corresponding proposal, the type of previous proposal that is expected and the invalid proposal reference if relevant.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3159"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"invalidOrMissingPreviousProposals\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"invalidOrMissingPreviousProposals\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"metadata\","]
#[doc = "                  \"type\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"invalidPreviousProposal\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "                  },"]
#[doc = "                  \"metadata\": {"]
#[doc = "                    \"$ref\": \"#/definitions/Anchor\""]
#[doc = "                  },"]
#[doc = "                  \"type\": {"]
#[doc = "                    \"type\": \"string\","]
#[doc = "                    \"enum\": ["]
#[doc = "                      \"hardForkInitiation\","]
#[doc = "                      \"protocolParametersUpdate\","]
#[doc = "                      \"constitutionalCommittee\","]
#[doc = "                      \"constitution\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<VotingOnExpiredActions>\","]
#[doc = "      \"description\": \"The transaction contains votes for an expired proposal. The field 'data.invalidVotes' indicates the faulty voters and the proposal they attempted to vote for.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3160"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"invalidVotes\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"invalidVotes\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"proposal\","]
#[doc = "                  \"voter\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"proposal\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "                  },"]
#[doc = "                  \"voter\": {"]
#[doc = "                    \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/SubmitTransactionFailure<ExecutionBudgetOutOfBounds>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<InvalidHardForkVersionBump>\","]
#[doc = "      \"description\": \"The new proposed version for a hard-fork isn't a valid version bump. The version (major, minor, patch) follows strict rules which can be summarized as follow: (1) the new triplet must be greater than the current one in the usual order of priorities (i.e. 'major' -> 'minor' -> 'patch'), (2) 'minor' must be 0 if 'major' is bumped, (3) 'minor' can only be bumped in increments of 1 and only if 'major' isn't bumped and (4) 'major' can only be bumped in increments of 1. The field 'data.proposedVersion' indicates the (invalid) version in the submitted proposal whereas 'data.currentVersion' indicates the current protocol version.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3162"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"currentVersion\","]
#[doc = "            \"proposedVersion\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"currentVersion\": {"]
#[doc = "              \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "            },"]
#[doc = "            \"proposedVersion\": {"]
#[doc = "              \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ConstitutionGuardrailsHashMismatch>\","]
#[doc = "      \"description\": \"The provided constitution guardrails hash doesn't match the expected on defined in the constitution. Some governance actions such as treasury withdrawals or protocol parameters updates must correctly refer to the constitution guardrails hash digest. The latter can be 'null'. The field 'data.providedHash' indicates the hash provided in the proposal, and the field 'data.expectedHash' the one specified in the constitution\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3163"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"expectedHash\","]
#[doc = "            \"providedHash\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expectedHash\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Null\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"providedHash\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Null\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ConflictingInputsAndReferences>\","]
#[doc = "      \"description\": \"Identical UTxO references were found in both the transaction inputs and references. This is redundant and no longer allowed by the ledger. Indeed, if the a UTxO is present in the inputs set, it is already in the transaction context. The field 'data.conflictingReferences' contains the culprit references present in both sets.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3164"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"conflictingReferences\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"conflictingReferences\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnauthorizedGovernanceAction>\","]
#[doc = "      \"description\": \"The ledger is still in a bootstrapping phase. During that phase, only protocol parameters changes, hard fork initiations and info actions are authorized. The transaction contains other types of governance action and was therefore rejected\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3165"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<ReferenceScriptsTooLarge>\","]
#[doc = "      \"description\": \"\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3166"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"maximumReferenceScriptsSize\","]
#[doc = "            \"measuredReferenceScriptsSize\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"maximumReferenceScriptsSize\": {"]
#[doc = "              \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "            },"]
#[doc = "            \"measuredReferenceScriptsSize\": {"]
#[doc = "              \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnknownVoters>\","]
#[doc = "      \"description\": \"Some voters in the transaction are unknown. Voters must correspond to registered credentials present in the ledger. They can possibly be registered in the same block, but it must imperatively happens before they are used for voting. The field 'data.unknownVoters' indicates the credentials that couldn't be mapped to any known voter.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3167"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"unknownVoters\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"unknownVoters\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<EmptyTreasuryWithdrawal>\","]
#[doc = "      \"description\": \"Some proposals contain empty treasury withdrawals, which is pointless and a waste of resources.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3168"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnexpectedMempoolError>\","]
#[doc = "      \"description\": \"A transaction was rejected due to custom rules that prevented it from entering the mempool. A justification is given as 'data.error'.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"data\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3997"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"error\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SubmitTransactionFailure<UnrecognizedCertificateType>\","]
#[doc = "      \"description\": \"Unrecognized certificate type. This error is a placeholder due to how internal data-types are modeled. If you ever run into this, please report the issue as you've likely discoverd a critical bug...\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\","]
#[doc = "        \"message\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"enum\": ["]
#[doc = "            3998"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"message\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum SubmitTransactionFailure {
    EraMismatch {
        code: SubmitTransactionFailureEraMismatchCode,
        data: EraMismatch,
        message: ::std::string::String,
    },
    InvalidSignatories {
        code: SubmitTransactionFailureInvalidSignatoriesCode,
        data: SubmitTransactionFailureInvalidSignatoriesData,
        message: ::std::string::String,
    },
    MissingSignatories {
        code: SubmitTransactionFailureMissingSignatoriesCode,
        data: SubmitTransactionFailureMissingSignatoriesData,
        message: ::std::string::String,
    },
    MissingScripts {
        code: SubmitTransactionFailureMissingScriptsCode,
        data: SubmitTransactionFailureMissingScriptsData,
        message: ::std::string::String,
    },
    FailingNativeScript {
        code: SubmitTransactionFailureFailingNativeScriptCode,
        data: SubmitTransactionFailureFailingNativeScriptData,
        message: ::std::string::String,
    },
    ExtraneousScripts {
        code: SubmitTransactionFailureExtraneousScriptsCode,
        data: SubmitTransactionFailureExtraneousScriptsData,
        message: ::std::string::String,
    },
    MissingMetadataHash {
        code: SubmitTransactionFailureMissingMetadataHashCode,
        data: SubmitTransactionFailureMissingMetadataHashData,
        message: ::std::string::String,
    },
    MissingMetadata {
        code: SubmitTransactionFailureMissingMetadataCode,
        data: SubmitTransactionFailureMissingMetadataData,
        message: ::std::string::String,
    },
    MetadataHashMismatch {
        code: SubmitTransactionFailureMetadataHashMismatchCode,
        data: SubmitTransactionFailureMetadataHashMismatchData,
        message: ::std::string::String,
    },
    InvalidMetadata {
        code: SubmitTransactionFailureInvalidMetadataCode,
        message: ::std::string::String,
    },
    MissingRedeemers {
        code: SubmitTransactionFailureMissingRedeemersCode,
        data: SubmitTransactionFailureMissingRedeemersData,
        message: ::std::string::String,
    },
    ExtraneousRedeemers(SubmitTransactionFailureExtraneousRedeemers),
    MissingDatums(SubmitTransactionFailureMissingDatums),
    ExtraneousDatums {
        code: SubmitTransactionFailureExtraneousDatumsCode,
        data: SubmitTransactionFailureExtraneousDatumsData,
        message: ::std::string::String,
    },
    ScriptIntegrityHashMismatch {
        code: SubmitTransactionFailureScriptIntegrityHashMismatchCode,
        data: SubmitTransactionFailureScriptIntegrityHashMismatchData,
        message: ::std::string::String,
    },
    OrphanScriptInputs {
        code: SubmitTransactionFailureOrphanScriptInputsCode,
        data: SubmitTransactionFailureOrphanScriptInputsData,
        message: ::std::string::String,
    },
    MissingCostModels(SubmitTransactionFailureMissingCostModels),
    MalformedScripts {
        code: SubmitTransactionFailureMalformedScriptsCode,
        data: SubmitTransactionFailureMalformedScriptsData,
        message: ::std::string::String,
    },
    UnknownOutputReference(SubmitTransactionFailureUnknownOutputReference),
    OutsideOfValidityInterval {
        code: SubmitTransactionFailureOutsideOfValidityIntervalCode,
        data: SubmitTransactionFailureOutsideOfValidityIntervalData,
        message: ::std::string::String,
    },
    TransactionTooLarge {
        code: SubmitTransactionFailureTransactionTooLargeCode,
        data: SubmitTransactionFailureTransactionTooLargeData,
        message: ::std::string::String,
    },
    ValueTooLarge {
        code: SubmitTransactionFailureValueTooLargeCode,
        data: SubmitTransactionFailureValueTooLargeData,
        message: ::std::string::String,
    },
    EmptyInputSet {
        code: SubmitTransactionFailureEmptyInputSetCode,
        message: ::std::string::String,
    },
    TransactionFeeTooSmall {
        code: SubmitTransactionFailureTransactionFeeTooSmallCode,
        data: SubmitTransactionFailureTransactionFeeTooSmallData,
        message: ::std::string::String,
    },
    ValueNotConserved {
        code: SubmitTransactionFailureValueNotConservedCode,
        data: SubmitTransactionFailureValueNotConservedData,
        message: ::std::string::String,
    },
    NetworkMismatch {
        code: SubmitTransactionFailureNetworkMismatchCode,
        data: SubmitTransactionFailureNetworkMismatchData,
        message: ::std::string::String,
    },
    InsufficientlyFundedOutputs {
        code: SubmitTransactionFailureInsufficientlyFundedOutputsCode,
        data: SubmitTransactionFailureInsufficientlyFundedOutputsData,
        message: ::std::string::String,
    },
    BootstrapAttributesTooLarge {
        code: SubmitTransactionFailureBootstrapAttributesTooLargeCode,
        data: SubmitTransactionFailureBootstrapAttributesTooLargeData,
        message: ::std::string::String,
    },
    MintingOrBurningAda {
        code: SubmitTransactionFailureMintingOrBurningAdaCode,
        message: ::std::string::String,
    },
    InsufficientCollateral {
        code: SubmitTransactionFailureInsufficientCollateralCode,
        data: SubmitTransactionFailureInsufficientCollateralData,
        message: ::std::string::String,
    },
    CollateralLockedByScript {
        code: SubmitTransactionFailureCollateralLockedByScriptCode,
        data: SubmitTransactionFailureCollateralLockedByScriptData,
        message: ::std::string::String,
    },
    UnforeseeableSlot {
        code: SubmitTransactionFailureUnforeseeableSlotCode,
        data: SubmitTransactionFailureUnforeseeableSlotData,
        message: ::std::string::String,
    },
    TooManyCollateralInputs {
        code: SubmitTransactionFailureTooManyCollateralInputsCode,
        data: SubmitTransactionFailureTooManyCollateralInputsData,
        message: ::std::string::String,
    },
    MissingCollateralInputs {
        code: SubmitTransactionFailureMissingCollateralInputsCode,
        message: ::std::string::String,
    },
    NonAdaCollateral {
        code: SubmitTransactionFailureNonAdaCollateralCode,
        data: SubmitTransactionFailureNonAdaCollateralData,
        message: ::std::string::String,
    },
    ExecutionUnitsTooLarge {
        code: SubmitTransactionFailureExecutionUnitsTooLargeCode,
        data: SubmitTransactionFailureExecutionUnitsTooLargeData,
        message: ::std::string::String,
    },
    TotalCollateralMismatch {
        code: SubmitTransactionFailureTotalCollateralMismatchCode,
        data: SubmitTransactionFailureTotalCollateralMismatchData,
        message: ::std::string::String,
    },
    SpendsMismatch {
        code: SubmitTransactionFailureSpendsMismatchCode,
        data: SubmitTransactionFailureSpendsMismatchData,
        message: ::std::string::String,
    },
    UnauthorizedVotes {
        code: SubmitTransactionFailureUnauthorizedVotesCode,
        data: SubmitTransactionFailureUnauthorizedVotesData,
        message: ::std::string::String,
    },
    UnknownGovernanceProposals {
        code: SubmitTransactionFailureUnknownGovernanceProposalsCode,
        data: SubmitTransactionFailureUnknownGovernanceProposalsData,
        message: ::std::string::String,
    },
    InvalidProtocolParametersUpdate {
        code: SubmitTransactionFailureInvalidProtocolParametersUpdateCode,
        message: ::std::string::String,
    },
    UnknownStakePool {
        code: SubmitTransactionFailureUnknownStakePoolCode,
        data: SubmitTransactionFailureUnknownStakePoolData,
        message: ::std::string::String,
    },
    IncompleteWithdrawals {
        code: SubmitTransactionFailureIncompleteWithdrawalsCode,
        data: SubmitTransactionFailureIncompleteWithdrawalsData,
        message: ::std::string::String,
    },
    RetirementTooLate {
        code: SubmitTransactionFailureRetirementTooLateCode,
        data: SubmitTransactionFailureRetirementTooLateData,
        message: ::std::string::String,
    },
    StakePoolCostTooLow {
        code: SubmitTransactionFailureStakePoolCostTooLowCode,
        data: SubmitTransactionFailureStakePoolCostTooLowData,
        message: ::std::string::String,
    },
    MetadataHashTooLarge {
        code: SubmitTransactionFailureMetadataHashTooLargeCode,
        data: SubmitTransactionFailureMetadataHashTooLargeData,
        message: ::std::string::String,
    },
    CredentialAlreadyRegistered {
        code: SubmitTransactionFailureCredentialAlreadyRegisteredCode,
        data: SubmitTransactionFailureCredentialAlreadyRegisteredData,
        message: ::std::string::String,
    },
    UnknownCredential {
        code: SubmitTransactionFailureUnknownCredentialCode,
        data: SubmitTransactionFailureUnknownCredentialData,
        message: ::std::string::String,
    },
    NonEmptyRewardAccount {
        code: SubmitTransactionFailureNonEmptyRewardAccountCode,
        data: SubmitTransactionFailureNonEmptyRewardAccountData,
        message: ::std::string::String,
    },
    InvalidGenesisDelegation {
        code: SubmitTransactionFailureInvalidGenesisDelegationCode,
        message: ::std::string::String,
    },
    InvalidMirTransfer {
        code: SubmitTransactionFailureInvalidMirTransferCode,
        message: ::std::string::String,
    },
    ForbiddenWithdrawal {
        code: SubmitTransactionFailureForbiddenWithdrawalCode,
        data: SubmitTransactionFailureForbiddenWithdrawalData,
        message: ::std::string::String,
    },
    CredentialDepositMismatch {
        code: SubmitTransactionFailureCredentialDepositMismatchCode,
        data: SubmitTransactionFailureCredentialDepositMismatchData,
        message: ::std::string::String,
    },
    DRepAlreadyRegistered {
        code: SubmitTransactionFailureDRepAlreadyRegisteredCode,
        data: SubmitTransactionFailureDRepAlreadyRegisteredData,
        message: ::std::string::String,
    },
    DRepNotRegistered {
        code: SubmitTransactionFailureDRepNotRegisteredCode,
        data: SubmitTransactionFailureDRepNotRegisteredData,
        message: ::std::string::String,
    },
    UnknownConstitutionalCommitteeMember {
        code: SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode,
        data: SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData,
        message: ::std::string::String,
    },
    GovernanceProposalDepositMismatch {
        code: SubmitTransactionFailureGovernanceProposalDepositMismatchCode,
        data: SubmitTransactionFailureGovernanceProposalDepositMismatchData,
        message: ::std::string::String,
    },
    ConflictingCommitteeUpdate {
        code: SubmitTransactionFailureConflictingCommitteeUpdateCode,
        data: SubmitTransactionFailureConflictingCommitteeUpdateData,
        message: ::std::string::String,
    },
    InvalidCommitteeUpdate {
        code: SubmitTransactionFailureInvalidCommitteeUpdateCode,
        data: SubmitTransactionFailureInvalidCommitteeUpdateData,
        message: ::std::string::String,
    },
    TreasuryWithdrawalMismatch {
        code: SubmitTransactionFailureTreasuryWithdrawalMismatchCode,
        data: SubmitTransactionFailureTreasuryWithdrawalMismatchData,
        message: ::std::string::String,
    },
    InvalidOrMissingPreviousProposals {
        code: SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode,
        data: SubmitTransactionFailureInvalidOrMissingPreviousProposalsData,
        message: ::std::string::String,
    },
    VotingOnExpiredActions {
        code: SubmitTransactionFailureVotingOnExpiredActionsCode,
        data: SubmitTransactionFailureVotingOnExpiredActionsData,
        message: ::std::string::String,
    },
    ExecutionBudgetOutOfBounds(SubmitTransactionFailureExecutionBudgetOutOfBounds),
    InvalidHardForkVersionBump {
        code: SubmitTransactionFailureInvalidHardForkVersionBumpCode,
        data: SubmitTransactionFailureInvalidHardForkVersionBumpData,
        message: ::std::string::String,
    },
    ConstitutionGuardrailsHashMismatch {
        code: SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode,
        data: SubmitTransactionFailureConstitutionGuardrailsHashMismatchData,
        message: ::std::string::String,
    },
    ConflictingInputsAndReferences {
        code: SubmitTransactionFailureConflictingInputsAndReferencesCode,
        data: SubmitTransactionFailureConflictingInputsAndReferencesData,
        message: ::std::string::String,
    },
    UnauthorizedGovernanceAction {
        code: SubmitTransactionFailureUnauthorizedGovernanceActionCode,
        message: ::std::string::String,
    },
    ReferenceScriptsTooLarge {
        code: SubmitTransactionFailureReferenceScriptsTooLargeCode,
        data: SubmitTransactionFailureReferenceScriptsTooLargeData,
        message: ::std::string::String,
    },
    UnknownVoters {
        code: SubmitTransactionFailureUnknownVotersCode,
        data: SubmitTransactionFailureUnknownVotersData,
        message: ::std::string::String,
    },
    EmptyTreasuryWithdrawal {
        code: SubmitTransactionFailureEmptyTreasuryWithdrawalCode,
        message: ::std::string::String,
    },
    UnexpectedMempoolError {
        code: SubmitTransactionFailureUnexpectedMempoolErrorCode,
        data: ::serde_json::Value,
        message: ::std::string::String,
    },
    UnrecognizedCertificateType {
        code: SubmitTransactionFailureUnrecognizedCertificateTypeCode,
        message: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for SubmitTransactionFailure {
    fn from(value: &SubmitTransactionFailure) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SubmitTransactionFailureExtraneousRedeemers>
    for SubmitTransactionFailure
{
    fn from(value: SubmitTransactionFailureExtraneousRedeemers) -> Self {
        Self::ExtraneousRedeemers(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingDatums> for SubmitTransactionFailure {
    fn from(value: SubmitTransactionFailureMissingDatums) -> Self {
        Self::MissingDatums(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingCostModels> for SubmitTransactionFailure {
    fn from(value: SubmitTransactionFailureMissingCostModels) -> Self {
        Self::MissingCostModels(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownOutputReference>
    for SubmitTransactionFailure
{
    fn from(value: SubmitTransactionFailureUnknownOutputReference) -> Self {
        Self::UnknownOutputReference(value)
    }
}
impl ::std::convert::From<SubmitTransactionFailureExecutionBudgetOutOfBounds>
    for SubmitTransactionFailure
{
    fn from(value: SubmitTransactionFailureExecutionBudgetOutOfBounds) -> Self {
        Self::ExecutionBudgetOutOfBounds(value)
    }
}
#[doc = "SubmitTransactionFailureBootstrapAttributesTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3126"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureBootstrapAttributesTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureBootstrapAttributesTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureBootstrapAttributesTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureBootstrapAttributesTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureBootstrapAttributesTooLargeCode>
    for SubmitTransactionFailureBootstrapAttributesTooLargeCode
{
    fn from(value: &SubmitTransactionFailureBootstrapAttributesTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureBootstrapAttributesTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3126_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureBootstrapAttributesTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureBootstrapAttributesTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"bootstrapOutputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bootstrapOutputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureBootstrapAttributesTooLargeData {
    #[serde(rename = "bootstrapOutputs")]
    pub bootstrap_outputs: ::std::vec::Vec<TransactionOutput>,
}
impl ::std::convert::From<&SubmitTransactionFailureBootstrapAttributesTooLargeData>
    for SubmitTransactionFailureBootstrapAttributesTooLargeData
{
    fn from(value: &SubmitTransactionFailureBootstrapAttributesTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureCollateralLockedByScriptCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3129"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureCollateralLockedByScriptCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureCollateralLockedByScriptCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureCollateralLockedByScriptCode> for i64 {
    fn from(value: SubmitTransactionFailureCollateralLockedByScriptCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureCollateralLockedByScriptCode>
    for SubmitTransactionFailureCollateralLockedByScriptCode
{
    fn from(value: &SubmitTransactionFailureCollateralLockedByScriptCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureCollateralLockedByScriptCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3129_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureCollateralLockedByScriptCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureCollateralLockedByScriptData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unsuitableCollateralInputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unsuitableCollateralInputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureCollateralLockedByScriptData {
    #[serde(rename = "unsuitableCollateralInputs")]
    pub unsuitable_collateral_inputs: ::std::vec::Vec<TransactionOutputReference>,
}
impl ::std::convert::From<&SubmitTransactionFailureCollateralLockedByScriptData>
    for SubmitTransactionFailureCollateralLockedByScriptData
{
    fn from(value: &SubmitTransactionFailureCollateralLockedByScriptData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureConflictingCommitteeUpdateCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3156"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureConflictingCommitteeUpdateCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureConflictingCommitteeUpdateCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureConflictingCommitteeUpdateCode> for i64 {
    fn from(value: SubmitTransactionFailureConflictingCommitteeUpdateCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureConflictingCommitteeUpdateCode>
    for SubmitTransactionFailureConflictingCommitteeUpdateCode
{
    fn from(value: &SubmitTransactionFailureConflictingCommitteeUpdateCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureConflictingCommitteeUpdateCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3156_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureConflictingCommitteeUpdateCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureConflictingCommitteeUpdateData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"conflictingMembers\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"conflictingMembers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"from\","]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"from\": {"]
#[doc = "            \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureConflictingCommitteeUpdateData {
    #[serde(rename = "conflictingMembers")]
    pub conflicting_members: ::std::vec::Vec<
        SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem,
    >,
}
impl ::std::convert::From<&SubmitTransactionFailureConflictingCommitteeUpdateData>
    for SubmitTransactionFailureConflictingCommitteeUpdateData
{
    fn from(value: &SubmitTransactionFailureConflictingCommitteeUpdateData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem {
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
}
impl
    ::std::convert::From<
        &SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem,
    > for SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem
{
    fn from(
        value: &SubmitTransactionFailureConflictingCommitteeUpdateDataConflictingMembersItem,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureConflictingInputsAndReferencesCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3164"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureConflictingInputsAndReferencesCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureConflictingInputsAndReferencesCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureConflictingInputsAndReferencesCode> for i64 {
    fn from(value: SubmitTransactionFailureConflictingInputsAndReferencesCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureConflictingInputsAndReferencesCode>
    for SubmitTransactionFailureConflictingInputsAndReferencesCode
{
    fn from(value: &SubmitTransactionFailureConflictingInputsAndReferencesCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureConflictingInputsAndReferencesCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3164_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureConflictingInputsAndReferencesCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureConflictingInputsAndReferencesData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"conflictingReferences\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"conflictingReferences\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureConflictingInputsAndReferencesData {
    #[serde(rename = "conflictingReferences")]
    pub conflicting_references: ::std::vec::Vec<TransactionOutputReference>,
}
impl ::std::convert::From<&SubmitTransactionFailureConflictingInputsAndReferencesData>
    for SubmitTransactionFailureConflictingInputsAndReferencesData
{
    fn from(value: &SubmitTransactionFailureConflictingInputsAndReferencesData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3163"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode
{
    fn from(value: &SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode
{
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3163_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureConstitutionGuardrailsHashMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expectedHash\","]
#[doc = "    \"providedHash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expectedHash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"providedHash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureConstitutionGuardrailsHashMismatchData {
    #[serde(rename = "expectedHash")]
    pub expected_hash: SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash,
    #[serde(rename = "providedHash")]
    pub provided_hash: SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash,
}
impl ::std::convert::From<&SubmitTransactionFailureConstitutionGuardrailsHashMismatchData>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchData
{
    fn from(value: &SubmitTransactionFailureConstitutionGuardrailsHashMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash {
    Null(Null),
    DigestBlake2b224(DigestBlake2b224),
}
impl ::std::convert::From<&Self>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash
{
    fn from(
        value: &SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash,
    ) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Null>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash
{
    fn from(value: Null) -> Self {
        Self::Null(value)
    }
}
impl ::std::convert::From<DigestBlake2b224>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataExpectedHash
{
    fn from(value: DigestBlake2b224) -> Self {
        Self::DigestBlake2b224(value)
    }
}
#[doc = "SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash {
    Null(Null),
    DigestBlake2b224(DigestBlake2b224),
}
impl ::std::convert::From<&Self>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash
{
    fn from(
        value: &SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash,
    ) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Null>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash
{
    fn from(value: Null) -> Self {
        Self::Null(value)
    }
}
impl ::std::convert::From<DigestBlake2b224>
    for SubmitTransactionFailureConstitutionGuardrailsHashMismatchDataProvidedHash
{
    fn from(value: DigestBlake2b224) -> Self {
        Self::DigestBlake2b224(value)
    }
}
#[doc = "SubmitTransactionFailureCredentialAlreadyRegisteredCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3145"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureCredentialAlreadyRegisteredCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureCredentialAlreadyRegisteredCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureCredentialAlreadyRegisteredCode> for i64 {
    fn from(value: SubmitTransactionFailureCredentialAlreadyRegisteredCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureCredentialAlreadyRegisteredCode>
    for SubmitTransactionFailureCredentialAlreadyRegisteredCode
{
    fn from(value: &SubmitTransactionFailureCredentialAlreadyRegisteredCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureCredentialAlreadyRegisteredCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3145_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureCredentialAlreadyRegisteredCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureCredentialAlreadyRegisteredData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"knownCredential\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"knownCredential\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureCredentialAlreadyRegisteredData {
    pub from: CredentialOrigin,
    #[serde(rename = "knownCredential")]
    pub known_credential: DigestBlake2b224,
}
impl ::std::convert::From<&SubmitTransactionFailureCredentialAlreadyRegisteredData>
    for SubmitTransactionFailureCredentialAlreadyRegisteredData
{
    fn from(value: &SubmitTransactionFailureCredentialAlreadyRegisteredData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureCredentialDepositMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3151"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureCredentialDepositMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureCredentialDepositMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureCredentialDepositMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureCredentialDepositMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureCredentialDepositMismatchCode>
    for SubmitTransactionFailureCredentialDepositMismatchCode
{
    fn from(value: &SubmitTransactionFailureCredentialDepositMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureCredentialDepositMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3151_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureCredentialDepositMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureCredentialDepositMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"providedDeposit\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expectedDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"providedDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureCredentialDepositMismatchData {
    #[serde(
        rename = "expectedDeposit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub expected_deposit: ::std::option::Option<ValueAdaOnly>,
    #[serde(rename = "providedDeposit")]
    pub provided_deposit: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureCredentialDepositMismatchData>
    for SubmitTransactionFailureCredentialDepositMismatchData
{
    fn from(value: &SubmitTransactionFailureCredentialDepositMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureDRepAlreadyRegisteredCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3152"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureDRepAlreadyRegisteredCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureDRepAlreadyRegisteredCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureDRepAlreadyRegisteredCode> for i64 {
    fn from(value: SubmitTransactionFailureDRepAlreadyRegisteredCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureDRepAlreadyRegisteredCode>
    for SubmitTransactionFailureDRepAlreadyRegisteredCode
{
    fn from(value: &SubmitTransactionFailureDRepAlreadyRegisteredCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureDRepAlreadyRegisteredCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3152_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureDRepAlreadyRegisteredCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureDRepAlreadyRegisteredData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"knownDelegateRepresentative\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"knownDelegateRepresentative\": {"]
#[doc = "      \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureDRepAlreadyRegisteredData {
    #[serde(rename = "knownDelegateRepresentative")]
    pub known_delegate_representative: DelegateRepresentative,
}
impl ::std::convert::From<&SubmitTransactionFailureDRepAlreadyRegisteredData>
    for SubmitTransactionFailureDRepAlreadyRegisteredData
{
    fn from(value: &SubmitTransactionFailureDRepAlreadyRegisteredData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureDRepNotRegisteredCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3153"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureDRepNotRegisteredCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureDRepNotRegisteredCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureDRepNotRegisteredCode> for i64 {
    fn from(value: SubmitTransactionFailureDRepNotRegisteredCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureDRepNotRegisteredCode>
    for SubmitTransactionFailureDRepNotRegisteredCode
{
    fn from(value: &SubmitTransactionFailureDRepNotRegisteredCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureDRepNotRegisteredCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3153_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureDRepNotRegisteredCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureDRepNotRegisteredData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownDelegateRepresentative\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownDelegateRepresentative\": {"]
#[doc = "      \"$ref\": \"#/definitions/DelegateRepresentative\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureDRepNotRegisteredData {
    #[serde(rename = "unknownDelegateRepresentative")]
    pub unknown_delegate_representative: DelegateRepresentative,
}
impl ::std::convert::From<&SubmitTransactionFailureDRepNotRegisteredData>
    for SubmitTransactionFailureDRepNotRegisteredData
{
    fn from(value: &SubmitTransactionFailureDRepNotRegisteredData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureEmptyInputSetCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3121"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureEmptyInputSetCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureEmptyInputSetCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureEmptyInputSetCode> for i64 {
    fn from(value: SubmitTransactionFailureEmptyInputSetCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureEmptyInputSetCode>
    for SubmitTransactionFailureEmptyInputSetCode
{
    fn from(value: &SubmitTransactionFailureEmptyInputSetCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureEmptyInputSetCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3121_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureEmptyInputSetCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureEmptyTreasuryWithdrawalCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3168"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureEmptyTreasuryWithdrawalCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureEmptyTreasuryWithdrawalCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureEmptyTreasuryWithdrawalCode> for i64 {
    fn from(value: SubmitTransactionFailureEmptyTreasuryWithdrawalCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureEmptyTreasuryWithdrawalCode>
    for SubmitTransactionFailureEmptyTreasuryWithdrawalCode
{
    fn from(value: &SubmitTransactionFailureEmptyTreasuryWithdrawalCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureEmptyTreasuryWithdrawalCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3168_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureEmptyTreasuryWithdrawalCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureEraMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3005"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureEraMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureEraMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureEraMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureEraMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureEraMismatchCode>
    for SubmitTransactionFailureEraMismatchCode
{
    fn from(value: &SubmitTransactionFailureEraMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureEraMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3005_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureEraMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "The transaction ran out of execution budget! This means that the budget granted for the execution of a particular script was too small or exceeding the maximum value allowed by the protocol. The field 'data.budgetUsed' indicates the actual execution units used by the validator before it was interrupted."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransactionFailure<ExecutionBudgetOutOfBounds>\","]
#[doc = "  \"description\": \"The transaction ran out of execution budget! This means that the budget granted for the execution of a particular script was too small or exceeding the maximum value allowed by the protocol. The field 'data.budgetUsed' indicates the actual execution units used by the validator before it was interrupted.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        3161"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"budgetUsed\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"budgetUsed\": {"]
#[doc = "          \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExecutionBudgetOutOfBounds {
    pub code: SubmitTransactionFailureExecutionBudgetOutOfBoundsCode,
    pub data: SubmitTransactionFailureExecutionBudgetOutOfBoundsData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureExecutionBudgetOutOfBounds>
    for SubmitTransactionFailureExecutionBudgetOutOfBounds
{
    fn from(value: &SubmitTransactionFailureExecutionBudgetOutOfBounds) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureExecutionBudgetOutOfBoundsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3161"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureExecutionBudgetOutOfBoundsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureExecutionBudgetOutOfBoundsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureExecutionBudgetOutOfBoundsCode> for i64 {
    fn from(value: SubmitTransactionFailureExecutionBudgetOutOfBoundsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureExecutionBudgetOutOfBoundsCode>
    for SubmitTransactionFailureExecutionBudgetOutOfBoundsCode
{
    fn from(value: &SubmitTransactionFailureExecutionBudgetOutOfBoundsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureExecutionBudgetOutOfBoundsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3161_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureExecutionBudgetOutOfBoundsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureExecutionBudgetOutOfBoundsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"budgetUsed\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"budgetUsed\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExecutionBudgetOutOfBoundsData {
    #[serde(rename = "budgetUsed")]
    pub budget_used: ExecutionUnits,
}
impl ::std::convert::From<&SubmitTransactionFailureExecutionBudgetOutOfBoundsData>
    for SubmitTransactionFailureExecutionBudgetOutOfBoundsData
{
    fn from(value: &SubmitTransactionFailureExecutionBudgetOutOfBoundsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureExecutionUnitsTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3134"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureExecutionUnitsTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureExecutionUnitsTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureExecutionUnitsTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureExecutionUnitsTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureExecutionUnitsTooLargeCode>
    for SubmitTransactionFailureExecutionUnitsTooLargeCode
{
    fn from(value: &SubmitTransactionFailureExecutionUnitsTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureExecutionUnitsTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3134_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureExecutionUnitsTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureExecutionUnitsTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"maximumExecutionUnits\","]
#[doc = "    \"providedExecutionUnits\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"maximumExecutionUnits\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    },"]
#[doc = "    \"providedExecutionUnits\": {"]
#[doc = "      \"$ref\": \"#/definitions/ExecutionUnits\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExecutionUnitsTooLargeData {
    #[serde(rename = "maximumExecutionUnits")]
    pub maximum_execution_units: ExecutionUnits,
    #[serde(rename = "providedExecutionUnits")]
    pub provided_execution_units: ExecutionUnits,
}
impl ::std::convert::From<&SubmitTransactionFailureExecutionUnitsTooLargeData>
    for SubmitTransactionFailureExecutionUnitsTooLargeData
{
    fn from(value: &SubmitTransactionFailureExecutionUnitsTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureExtraneousDatumsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3112"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureExtraneousDatumsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureExtraneousDatumsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureExtraneousDatumsCode> for i64 {
    fn from(value: SubmitTransactionFailureExtraneousDatumsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousDatumsCode>
    for SubmitTransactionFailureExtraneousDatumsCode
{
    fn from(value: &SubmitTransactionFailureExtraneousDatumsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureExtraneousDatumsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3112_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureExtraneousDatumsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureExtraneousDatumsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extraneousDatums\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"extraneousDatums\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExtraneousDatumsData {
    #[serde(rename = "extraneousDatums")]
    pub extraneous_datums: ::std::vec::Vec<DigestBlake2b256>,
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousDatumsData>
    for SubmitTransactionFailureExtraneousDatumsData
{
    fn from(value: &SubmitTransactionFailureExtraneousDatumsData) -> Self {
        value.clone()
    }
}
#[doc = "Extraneous (non-required) redeemers found in the transaction. There are some redeemers that aren't pointing to any script. This could be because you've left some orphan redeemer behind, because they are pointing at the wrong thing or because you forgot to include their associated validator. Either way, the field 'data.extraneousRedeemers' lists the different orphan redeemer pointers."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransactionFailure<ExtraneousRedeemers>\","]
#[doc = "  \"description\": \"Extraneous (non-required) redeemers found in the transaction. There are some redeemers that aren't pointing to any script. This could be because you've left some orphan redeemer behind, because they are pointing at the wrong thing or because you forgot to include their associated validator. Either way, the field 'data.extraneousRedeemers' lists the different orphan redeemer pointers.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        3110"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"extraneousRedeemers\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"extraneousRedeemers\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExtraneousRedeemers {
    pub code: SubmitTransactionFailureExtraneousRedeemersCode,
    pub data: SubmitTransactionFailureExtraneousRedeemersData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousRedeemers>
    for SubmitTransactionFailureExtraneousRedeemers
{
    fn from(value: &SubmitTransactionFailureExtraneousRedeemers) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureExtraneousRedeemersCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3110"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureExtraneousRedeemersCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureExtraneousRedeemersCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureExtraneousRedeemersCode> for i64 {
    fn from(value: SubmitTransactionFailureExtraneousRedeemersCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousRedeemersCode>
    for SubmitTransactionFailureExtraneousRedeemersCode
{
    fn from(value: &SubmitTransactionFailureExtraneousRedeemersCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureExtraneousRedeemersCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3110_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureExtraneousRedeemersCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureExtraneousRedeemersData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extraneousRedeemers\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"extraneousRedeemers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/RedeemerPointer\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExtraneousRedeemersData {
    #[serde(rename = "extraneousRedeemers")]
    pub extraneous_redeemers: ::std::vec::Vec<RedeemerPointer>,
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousRedeemersData>
    for SubmitTransactionFailureExtraneousRedeemersData
{
    fn from(value: &SubmitTransactionFailureExtraneousRedeemersData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureExtraneousScriptsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3104"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureExtraneousScriptsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureExtraneousScriptsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureExtraneousScriptsCode> for i64 {
    fn from(value: SubmitTransactionFailureExtraneousScriptsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousScriptsCode>
    for SubmitTransactionFailureExtraneousScriptsCode
{
    fn from(value: &SubmitTransactionFailureExtraneousScriptsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureExtraneousScriptsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3104_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureExtraneousScriptsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureExtraneousScriptsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extraneousScripts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"extraneousScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureExtraneousScriptsData {
    #[serde(rename = "extraneousScripts")]
    pub extraneous_scripts: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureExtraneousScriptsData>
    for SubmitTransactionFailureExtraneousScriptsData
{
    fn from(value: &SubmitTransactionFailureExtraneousScriptsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureFailingNativeScriptCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3103"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureFailingNativeScriptCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureFailingNativeScriptCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureFailingNativeScriptCode> for i64 {
    fn from(value: SubmitTransactionFailureFailingNativeScriptCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureFailingNativeScriptCode>
    for SubmitTransactionFailureFailingNativeScriptCode
{
    fn from(value: &SubmitTransactionFailureFailingNativeScriptCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureFailingNativeScriptCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3103_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureFailingNativeScriptCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureFailingNativeScriptData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"failingNativeScripts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"failingNativeScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureFailingNativeScriptData {
    #[serde(rename = "failingNativeScripts")]
    pub failing_native_scripts: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureFailingNativeScriptData>
    for SubmitTransactionFailureFailingNativeScriptData
{
    fn from(value: &SubmitTransactionFailureFailingNativeScriptData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureForbiddenWithdrawalCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3150"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureForbiddenWithdrawalCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureForbiddenWithdrawalCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureForbiddenWithdrawalCode> for i64 {
    fn from(value: SubmitTransactionFailureForbiddenWithdrawalCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureForbiddenWithdrawalCode>
    for SubmitTransactionFailureForbiddenWithdrawalCode
{
    fn from(value: &SubmitTransactionFailureForbiddenWithdrawalCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureForbiddenWithdrawalCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3150_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureForbiddenWithdrawalCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureForbiddenWithdrawalData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"marginalizedCredentials\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"marginalizedCredentials\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureForbiddenWithdrawalData {
    #[serde(rename = "marginalizedCredentials")]
    pub marginalized_credentials: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureForbiddenWithdrawalData>
    for SubmitTransactionFailureForbiddenWithdrawalData
{
    fn from(value: &SubmitTransactionFailureForbiddenWithdrawalData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureGovernanceProposalDepositMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3155"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureGovernanceProposalDepositMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureGovernanceProposalDepositMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureGovernanceProposalDepositMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureGovernanceProposalDepositMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureGovernanceProposalDepositMismatchCode>
    for SubmitTransactionFailureGovernanceProposalDepositMismatchCode
{
    fn from(value: &SubmitTransactionFailureGovernanceProposalDepositMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64>
    for SubmitTransactionFailureGovernanceProposalDepositMismatchCode
{
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3155_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for SubmitTransactionFailureGovernanceProposalDepositMismatchCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureGovernanceProposalDepositMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expectedDeposit\","]
#[doc = "    \"providedDeposit\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expectedDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"providedDeposit\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureGovernanceProposalDepositMismatchData {
    #[serde(rename = "expectedDeposit")]
    pub expected_deposit: ValueAdaOnly,
    #[serde(rename = "providedDeposit")]
    pub provided_deposit: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureGovernanceProposalDepositMismatchData>
    for SubmitTransactionFailureGovernanceProposalDepositMismatchData
{
    fn from(value: &SubmitTransactionFailureGovernanceProposalDepositMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureIncompleteWithdrawalsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3141"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureIncompleteWithdrawalsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureIncompleteWithdrawalsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureIncompleteWithdrawalsCode> for i64 {
    fn from(value: SubmitTransactionFailureIncompleteWithdrawalsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureIncompleteWithdrawalsCode>
    for SubmitTransactionFailureIncompleteWithdrawalsCode
{
    fn from(value: &SubmitTransactionFailureIncompleteWithdrawalsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureIncompleteWithdrawalsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3141_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureIncompleteWithdrawalsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureIncompleteWithdrawalsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"incompleteWithdrawals\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"incompleteWithdrawals\": {"]
#[doc = "      \"$ref\": \"#/definitions/Withdrawals\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureIncompleteWithdrawalsData {
    #[serde(rename = "incompleteWithdrawals")]
    pub incomplete_withdrawals: Withdrawals,
}
impl ::std::convert::From<&SubmitTransactionFailureIncompleteWithdrawalsData>
    for SubmitTransactionFailureIncompleteWithdrawalsData
{
    fn from(value: &SubmitTransactionFailureIncompleteWithdrawalsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInsufficientCollateralCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3128"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInsufficientCollateralCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInsufficientCollateralCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInsufficientCollateralCode> for i64 {
    fn from(value: SubmitTransactionFailureInsufficientCollateralCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInsufficientCollateralCode>
    for SubmitTransactionFailureInsufficientCollateralCode
{
    fn from(value: &SubmitTransactionFailureInsufficientCollateralCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInsufficientCollateralCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3128_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInsufficientCollateralCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInsufficientCollateralData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"minimumRequiredCollateral\","]
#[doc = "    \"providedCollateral\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"minimumRequiredCollateral\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"providedCollateral\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<Delta>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInsufficientCollateralData {
    #[serde(rename = "minimumRequiredCollateral")]
    pub minimum_required_collateral: ValueAdaOnly,
    #[serde(rename = "providedCollateral")]
    pub provided_collateral: ValueDelta,
}
impl ::std::convert::From<&SubmitTransactionFailureInsufficientCollateralData>
    for SubmitTransactionFailureInsufficientCollateralData
{
    fn from(value: &SubmitTransactionFailureInsufficientCollateralData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInsufficientlyFundedOutputsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3125"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInsufficientlyFundedOutputsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInsufficientlyFundedOutputsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInsufficientlyFundedOutputsCode> for i64 {
    fn from(value: SubmitTransactionFailureInsufficientlyFundedOutputsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInsufficientlyFundedOutputsCode>
    for SubmitTransactionFailureInsufficientlyFundedOutputsCode
{
    fn from(value: &SubmitTransactionFailureInsufficientlyFundedOutputsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInsufficientlyFundedOutputsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3125_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInsufficientlyFundedOutputsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInsufficientlyFundedOutputsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"insufficientlyFundedOutputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"insufficientlyFundedOutputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"output\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"minimumRequiredValue\": {"]
#[doc = "            \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "          },"]
#[doc = "          \"output\": {"]
#[doc = "            \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInsufficientlyFundedOutputsData {
    #[serde(rename = "insufficientlyFundedOutputs")]
    pub insufficiently_funded_outputs: ::std::vec::Vec<
        SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem,
    >,
}
impl ::std::convert::From<&SubmitTransactionFailureInsufficientlyFundedOutputsData>
    for SubmitTransactionFailureInsufficientlyFundedOutputsData
{
    fn from(value: &SubmitTransactionFailureInsufficientlyFundedOutputsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"output\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"minimumRequiredValue\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem {
    #[serde(
        rename = "minimumRequiredValue",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub minimum_required_value: ::std::option::Option<ValueAdaOnly>,
    pub output: TransactionOutput,
}
impl
    ::std::convert::From<
        &SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem,
    > for SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem
{
    fn from(
        value : & SubmitTransactionFailureInsufficientlyFundedOutputsDataInsufficientlyFundedOutputsItem,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInvalidCommitteeUpdateCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3157"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidCommitteeUpdateCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidCommitteeUpdateCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidCommitteeUpdateCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidCommitteeUpdateCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidCommitteeUpdateCode>
    for SubmitTransactionFailureInvalidCommitteeUpdateCode
{
    fn from(value: &SubmitTransactionFailureInvalidCommitteeUpdateCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidCommitteeUpdateCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3157_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidCommitteeUpdateCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidCommitteeUpdateData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"alreadyRetiredMembers\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"alreadyRetiredMembers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"from\","]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"from\": {"]
#[doc = "            \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "          },"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidCommitteeUpdateData {
    #[serde(rename = "alreadyRetiredMembers")]
    pub already_retired_members: ::std::vec::Vec<
        SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem,
    >,
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidCommitteeUpdateData>
    for SubmitTransactionFailureInvalidCommitteeUpdateData
{
    fn from(value: &SubmitTransactionFailureInvalidCommitteeUpdateData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem {
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
}
impl
    ::std::convert::From<
        &SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem,
    > for SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem
{
    fn from(
        value: &SubmitTransactionFailureInvalidCommitteeUpdateDataAlreadyRetiredMembersItem,
    ) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInvalidGenesisDelegationCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3148"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidGenesisDelegationCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidGenesisDelegationCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidGenesisDelegationCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidGenesisDelegationCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidGenesisDelegationCode>
    for SubmitTransactionFailureInvalidGenesisDelegationCode
{
    fn from(value: &SubmitTransactionFailureInvalidGenesisDelegationCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidGenesisDelegationCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3148_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidGenesisDelegationCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidHardForkVersionBumpCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3162"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidHardForkVersionBumpCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidHardForkVersionBumpCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidHardForkVersionBumpCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidHardForkVersionBumpCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidHardForkVersionBumpCode>
    for SubmitTransactionFailureInvalidHardForkVersionBumpCode
{
    fn from(value: &SubmitTransactionFailureInvalidHardForkVersionBumpCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidHardForkVersionBumpCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3162_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidHardForkVersionBumpCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidHardForkVersionBumpData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"currentVersion\","]
#[doc = "    \"proposedVersion\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"currentVersion\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    },"]
#[doc = "    \"proposedVersion\": {"]
#[doc = "      \"$ref\": \"#/definitions/ProtocolVersion\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidHardForkVersionBumpData {
    #[serde(rename = "currentVersion")]
    pub current_version: ProtocolVersion,
    #[serde(rename = "proposedVersion")]
    pub proposed_version: ProtocolVersion,
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidHardForkVersionBumpData>
    for SubmitTransactionFailureInvalidHardForkVersionBumpData
{
    fn from(value: &SubmitTransactionFailureInvalidHardForkVersionBumpData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInvalidMetadataCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3108"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidMetadataCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidMetadataCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidMetadataCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidMetadataCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidMetadataCode>
    for SubmitTransactionFailureInvalidMetadataCode
{
    fn from(value: &SubmitTransactionFailureInvalidMetadataCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidMetadataCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3108_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidMetadataCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidMirTransferCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3149"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidMirTransferCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidMirTransferCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidMirTransferCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidMirTransferCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidMirTransferCode>
    for SubmitTransactionFailureInvalidMirTransferCode
{
    fn from(value: &SubmitTransactionFailureInvalidMirTransferCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidMirTransferCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3149_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidMirTransferCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3159"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode>
    for SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode
{
    fn from(value: &SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64>
    for SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode
{
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3159_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for SubmitTransactionFailureInvalidOrMissingPreviousProposalsCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidOrMissingPreviousProposalsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"invalidOrMissingPreviousProposals\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"invalidOrMissingPreviousProposals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"metadata\","]
#[doc = "          \"type\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"invalidPreviousProposal\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "          },"]
#[doc = "          \"metadata\": {"]
#[doc = "            \"$ref\": \"#/definitions/Anchor\""]
#[doc = "          },"]
#[doc = "          \"type\": {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"enum\": ["]
#[doc = "              \"hardForkInitiation\","]
#[doc = "              \"protocolParametersUpdate\","]
#[doc = "              \"constitutionalCommittee\","]
#[doc = "              \"constitution\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidOrMissingPreviousProposalsData { # [serde (rename = "invalidOrMissingPreviousProposals")] pub invalid_or_missing_previous_proposals : :: std :: vec :: Vec < SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem > , }
impl ::std::convert::From<&SubmitTransactionFailureInvalidOrMissingPreviousProposalsData>
    for SubmitTransactionFailureInvalidOrMissingPreviousProposalsData
{
    fn from(value: &SubmitTransactionFailureInvalidOrMissingPreviousProposalsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"metadata\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"invalidPreviousProposal\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"$ref\": \"#/definitions/Anchor\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"hardForkInitiation\","]
#[doc = "        \"protocolParametersUpdate\","]
#[doc = "        \"constitutionalCommittee\","]
#[doc = "        \"constitution\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem { # [serde (rename = "invalidPreviousProposal" , default , skip_serializing_if = "::std::option::Option::is_none")] pub invalid_previous_proposal : :: std :: option :: Option < GovernanceProposalReference > , pub metadata : Anchor , # [serde (rename = "type")] pub type_ : SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType , }
impl :: std :: convert :: From < & SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem > for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem { fn from (value : & SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItem) -> Self { value . clone () } }
#[doc = "SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"hardForkInitiation\","]
#[doc = "    \"protocolParametersUpdate\","]
#[doc = "    \"constitutionalCommittee\","]
#[doc = "    \"constitution\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType
{
    #[serde(rename = "hardForkInitiation")]
    HardForkInitiation,
    #[serde(rename = "protocolParametersUpdate")]
    ProtocolParametersUpdate,
    #[serde(rename = "constitutionalCommittee")]
    ConstitutionalCommittee,
    #[serde(rename = "constitution")]
    Constitution,
}
impl :: std :: convert :: From < & Self > for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { fn from (value : & SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType) -> Self { value . clone () } }
impl :: std :: fmt :: Display for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: HardForkInitiation => write ! (f , "hardForkInitiation") , Self :: ProtocolParametersUpdate => write ! (f , "protocolParametersUpdate") , Self :: ConstitutionalCommittee => write ! (f , "constitutionalCommittee") , Self :: Constitution => write ! (f , "constitution") , } } }
impl :: std :: str :: FromStr for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "hardForkInitiation" => Ok (Self :: HardForkInitiation) , "protocolParametersUpdate" => Ok (Self :: ProtocolParametersUpdate) , "constitutionalCommittee" => Ok (Self :: ConstitutionalCommittee) , "constitution" => Ok (Self :: Constitution) , _ => Err ("invalid value" . into ()) , } } }
impl :: std :: convert :: TryFrom < & str > for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } }
impl :: std :: convert :: TryFrom < & :: std :: string :: String > for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } }
impl :: std :: convert :: TryFrom < :: std :: string :: String > for SubmitTransactionFailureInvalidOrMissingPreviousProposalsDataInvalidOrMissingPreviousProposalsItemType { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } }
#[doc = "SubmitTransactionFailureInvalidProtocolParametersUpdateCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3139"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidProtocolParametersUpdateCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidProtocolParametersUpdateCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidProtocolParametersUpdateCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidProtocolParametersUpdateCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidProtocolParametersUpdateCode>
    for SubmitTransactionFailureInvalidProtocolParametersUpdateCode
{
    fn from(value: &SubmitTransactionFailureInvalidProtocolParametersUpdateCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidProtocolParametersUpdateCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3139_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for SubmitTransactionFailureInvalidProtocolParametersUpdateCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidSignatoriesCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3100"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureInvalidSignatoriesCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureInvalidSignatoriesCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureInvalidSignatoriesCode> for i64 {
    fn from(value: SubmitTransactionFailureInvalidSignatoriesCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidSignatoriesCode>
    for SubmitTransactionFailureInvalidSignatoriesCode
{
    fn from(value: &SubmitTransactionFailureInvalidSignatoriesCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureInvalidSignatoriesCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3100_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureInvalidSignatoriesCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureInvalidSignatoriesData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"invalidSignatories\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"invalidSignatories\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/VerificationKey\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureInvalidSignatoriesData {
    #[serde(rename = "invalidSignatories")]
    pub invalid_signatories: ::std::vec::Vec<VerificationKey>,
}
impl ::std::convert::From<&SubmitTransactionFailureInvalidSignatoriesData>
    for SubmitTransactionFailureInvalidSignatoriesData
{
    fn from(value: &SubmitTransactionFailureInvalidSignatoriesData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMalformedScriptsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3116"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMalformedScriptsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMalformedScriptsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMalformedScriptsCode> for i64 {
    fn from(value: SubmitTransactionFailureMalformedScriptsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMalformedScriptsCode>
    for SubmitTransactionFailureMalformedScriptsCode
{
    fn from(value: &SubmitTransactionFailureMalformedScriptsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMalformedScriptsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3116_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMalformedScriptsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMalformedScriptsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"malformedScripts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"malformedScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMalformedScriptsData {
    #[serde(rename = "malformedScripts")]
    pub malformed_scripts: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureMalformedScriptsData>
    for SubmitTransactionFailureMalformedScriptsData
{
    fn from(value: &SubmitTransactionFailureMalformedScriptsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMetadataHashMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3107"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMetadataHashMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMetadataHashMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMetadataHashMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureMetadataHashMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashMismatchCode>
    for SubmitTransactionFailureMetadataHashMismatchCode
{
    fn from(value: &SubmitTransactionFailureMetadataHashMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMetadataHashMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3107_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMetadataHashMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMetadataHashMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"computed\","]
#[doc = "    \"provided\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"computed\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"provided\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMetadataHashMismatchData {
    pub computed: SubmitTransactionFailureMetadataHashMismatchDataComputed,
    pub provided: SubmitTransactionFailureMetadataHashMismatchDataProvided,
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashMismatchData>
    for SubmitTransactionFailureMetadataHashMismatchData
{
    fn from(value: &SubmitTransactionFailureMetadataHashMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMetadataHashMismatchDataComputed"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMetadataHashMismatchDataComputed {
    pub hash: DigestBlake2b256,
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashMismatchDataComputed>
    for SubmitTransactionFailureMetadataHashMismatchDataComputed
{
    fn from(value: &SubmitTransactionFailureMetadataHashMismatchDataComputed) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMetadataHashMismatchDataProvided"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMetadataHashMismatchDataProvided {
    pub hash: DigestBlake2b256,
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashMismatchDataProvided>
    for SubmitTransactionFailureMetadataHashMismatchDataProvided
{
    fn from(value: &SubmitTransactionFailureMetadataHashMismatchDataProvided) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMetadataHashTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3144"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMetadataHashTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMetadataHashTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMetadataHashTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureMetadataHashTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashTooLargeCode>
    for SubmitTransactionFailureMetadataHashTooLargeCode
{
    fn from(value: &SubmitTransactionFailureMetadataHashTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMetadataHashTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3144_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMetadataHashTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMetadataHashTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"computedMetadataHashSize\","]
#[doc = "    \"infringingStakePool\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"computedMetadataHashSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"infringingStakePool\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMetadataHashTooLargeData {
    #[serde(rename = "computedMetadataHashSize")]
    pub computed_metadata_hash_size: NumberOfBytes,
    #[serde(rename = "infringingStakePool")]
    pub infringing_stake_pool: SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool,
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashTooLargeData>
    for SubmitTransactionFailureMetadataHashTooLargeData
{
    fn from(value: &SubmitTransactionFailureMetadataHashTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool {
    pub id: StakePoolId,
}
impl ::std::convert::From<&SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool>
    for SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool
{
    fn from(value: &SubmitTransactionFailureMetadataHashTooLargeDataInfringingStakePool) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMintingOrBurningAdaCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3127"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMintingOrBurningAdaCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMintingOrBurningAdaCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMintingOrBurningAdaCode> for i64 {
    fn from(value: SubmitTransactionFailureMintingOrBurningAdaCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMintingOrBurningAdaCode>
    for SubmitTransactionFailureMintingOrBurningAdaCode
{
    fn from(value: &SubmitTransactionFailureMintingOrBurningAdaCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMintingOrBurningAdaCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3127_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMintingOrBurningAdaCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingCollateralInputsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3132"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingCollateralInputsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingCollateralInputsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingCollateralInputsCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingCollateralInputsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingCollateralInputsCode>
    for SubmitTransactionFailureMissingCollateralInputsCode
{
    fn from(value: &SubmitTransactionFailureMissingCollateralInputsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingCollateralInputsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3132_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingCollateralInputsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "It seems like the transaction is using a Plutus version for which there's no available cost model yet. This could be because that language version is known of the ledger but hasn't yet been enabled through hard-fork. The field 'data.missingCostModels' lists all the languages for which a cost model is missing."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransactionFailure<MissingCostModels>\","]
#[doc = "  \"description\": \"It seems like the transaction is using a Plutus version for which there's no available cost model yet. This could be because that language version is known of the ledger but hasn't yet been enabled through hard-fork. The field 'data.missingCostModels' lists all the languages for which a cost model is missing.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        3115"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"missingCostModels\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"missingCostModels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Language\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingCostModels {
    pub code: SubmitTransactionFailureMissingCostModelsCode,
    pub data: SubmitTransactionFailureMissingCostModelsData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingCostModels>
    for SubmitTransactionFailureMissingCostModels
{
    fn from(value: &SubmitTransactionFailureMissingCostModels) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingCostModelsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3115"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingCostModelsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingCostModelsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingCostModelsCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingCostModelsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingCostModelsCode>
    for SubmitTransactionFailureMissingCostModelsCode
{
    fn from(value: &SubmitTransactionFailureMissingCostModelsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingCostModelsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3115_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingCostModelsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingCostModelsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingCostModels\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingCostModels\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Language\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingCostModelsData {
    #[serde(rename = "missingCostModels")]
    pub missing_cost_models: ::std::vec::Vec<Language>,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingCostModelsData>
    for SubmitTransactionFailureMissingCostModelsData
{
    fn from(value: &SubmitTransactionFailureMissingCostModelsData) -> Self {
        value.clone()
    }
}
#[doc = "Transaction failed because some Plutus scripts are missing their associated datums. 'data.missingDatums' contains a set of data hashes for the missing datums. Ensure all Plutus scripts have an associated datum in the transaction's witness set or, are provided through inline datums in reference inputs."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransactionFailure<MissingDatums>\","]
#[doc = "  \"description\": \"Transaction failed because some Plutus scripts are missing their associated datums. 'data.missingDatums' contains a set of data hashes for the missing datums. Ensure all Plutus scripts have an associated datum in the transaction's witness set or, are provided through inline datums in reference inputs.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        3111"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"missingDatums\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"missingDatums\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingDatums {
    pub code: SubmitTransactionFailureMissingDatumsCode,
    pub data: SubmitTransactionFailureMissingDatumsData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingDatums>
    for SubmitTransactionFailureMissingDatums
{
    fn from(value: &SubmitTransactionFailureMissingDatums) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingDatumsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3111"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingDatumsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingDatumsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingDatumsCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingDatumsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingDatumsCode>
    for SubmitTransactionFailureMissingDatumsCode
{
    fn from(value: &SubmitTransactionFailureMissingDatumsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingDatumsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3111_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingDatumsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingDatumsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingDatums\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingDatums\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingDatumsData {
    #[serde(rename = "missingDatums")]
    pub missing_datums: ::std::vec::Vec<DigestBlake2b256>,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingDatumsData>
    for SubmitTransactionFailureMissingDatumsData
{
    fn from(value: &SubmitTransactionFailureMissingDatumsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3106"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingMetadataCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingMetadataCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingMetadataCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingMetadataCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataCode>
    for SubmitTransactionFailureMissingMetadataCode
{
    fn from(value: &SubmitTransactionFailureMissingMetadataCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingMetadataCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3106_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingMetadataCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"metadata\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingMetadataData {
    pub metadata: SubmitTransactionFailureMissingMetadataDataMetadata,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataData>
    for SubmitTransactionFailureMissingMetadataData
{
    fn from(value: &SubmitTransactionFailureMissingMetadataData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataDataMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingMetadataDataMetadata {
    pub hash: DigestBlake2b256,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataDataMetadata>
    for SubmitTransactionFailureMissingMetadataDataMetadata
{
    fn from(value: &SubmitTransactionFailureMissingMetadataDataMetadata) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataHashCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3105"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingMetadataHashCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingMetadataHashCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingMetadataHashCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingMetadataHashCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataHashCode>
    for SubmitTransactionFailureMissingMetadataHashCode
{
    fn from(value: &SubmitTransactionFailureMissingMetadataHashCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingMetadataHashCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3105_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingMetadataHashCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataHashData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"metadata\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"hash\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingMetadataHashData {
    pub metadata: SubmitTransactionFailureMissingMetadataHashDataMetadata,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataHashData>
    for SubmitTransactionFailureMissingMetadataHashData
{
    fn from(value: &SubmitTransactionFailureMissingMetadataHashData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingMetadataHashDataMetadata"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingMetadataHashDataMetadata {
    pub hash: DigestBlake2b256,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingMetadataHashDataMetadata>
    for SubmitTransactionFailureMissingMetadataHashDataMetadata
{
    fn from(value: &SubmitTransactionFailureMissingMetadataHashDataMetadata) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingRedeemersCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3109"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingRedeemersCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingRedeemersCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingRedeemersCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingRedeemersCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingRedeemersCode>
    for SubmitTransactionFailureMissingRedeemersCode
{
    fn from(value: &SubmitTransactionFailureMissingRedeemersCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingRedeemersCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3109_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingRedeemersCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingRedeemersData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingRedeemers\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingRedeemers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/ScriptPurpose\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingRedeemersData {
    #[serde(rename = "missingRedeemers")]
    pub missing_redeemers: ::std::vec::Vec<ScriptPurpose>,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingRedeemersData>
    for SubmitTransactionFailureMissingRedeemersData
{
    fn from(value: &SubmitTransactionFailureMissingRedeemersData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingScriptsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3102"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingScriptsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingScriptsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingScriptsCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingScriptsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingScriptsCode>
    for SubmitTransactionFailureMissingScriptsCode
{
    fn from(value: &SubmitTransactionFailureMissingScriptsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingScriptsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3102_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingScriptsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingScriptsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingScripts\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingScriptsData {
    #[serde(rename = "missingScripts")]
    pub missing_scripts: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingScriptsData>
    for SubmitTransactionFailureMissingScriptsData
{
    fn from(value: &SubmitTransactionFailureMissingScriptsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureMissingSignatoriesCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3101"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureMissingSignatoriesCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureMissingSignatoriesCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureMissingSignatoriesCode> for i64 {
    fn from(value: SubmitTransactionFailureMissingSignatoriesCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureMissingSignatoriesCode>
    for SubmitTransactionFailureMissingSignatoriesCode
{
    fn from(value: &SubmitTransactionFailureMissingSignatoriesCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureMissingSignatoriesCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3101_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureMissingSignatoriesCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureMissingSignatoriesData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"missingSignatories\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"missingSignatories\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureMissingSignatoriesData {
    #[serde(rename = "missingSignatories")]
    pub missing_signatories: ::std::vec::Vec<DigestBlake2b224>,
}
impl ::std::convert::From<&SubmitTransactionFailureMissingSignatoriesData>
    for SubmitTransactionFailureMissingSignatoriesData
{
    fn from(value: &SubmitTransactionFailureMissingSignatoriesData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureNetworkMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3124"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureNetworkMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureNetworkMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureNetworkMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureNetworkMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureNetworkMismatchCode>
    for SubmitTransactionFailureNetworkMismatchCode
{
    fn from(value: &SubmitTransactionFailureNetworkMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureNetworkMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3124_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureNetworkMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureNetworkMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"discriminatedType\","]
#[doc = "        \"expectedNetwork\","]
#[doc = "        \"invalidEntities\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"discriminatedType\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"address\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"expectedNetwork\": {"]
#[doc = "          \"$ref\": \"#/definitions/Network\""]
#[doc = "        },"]
#[doc = "        \"invalidEntities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/Address\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"discriminatedType\","]
#[doc = "        \"expectedNetwork\","]
#[doc = "        \"invalidEntities\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"discriminatedType\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"rewardAccount\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"expectedNetwork\": {"]
#[doc = "          \"$ref\": \"#/definitions/Network\""]
#[doc = "        },"]
#[doc = "        \"invalidEntities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/RewardAccount\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"discriminatedType\","]
#[doc = "        \"expectedNetwork\","]
#[doc = "        \"invalidEntities\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"discriminatedType\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"stakePoolCertificate\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"expectedNetwork\": {"]
#[doc = "          \"$ref\": \"#/definitions/Network\""]
#[doc = "        },"]
#[doc = "        \"invalidEntities\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"discriminatedType\","]
#[doc = "        \"expectedNetwork\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"discriminatedType\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"expectedNetwork\": {"]
#[doc = "          \"$ref\": \"#/definitions/Network\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "discriminatedType", deny_unknown_fields)]
pub enum SubmitTransactionFailureNetworkMismatchData {
    #[serde(rename = "address")]
    Address {
        #[serde(rename = "expectedNetwork")]
        expected_network: Network,
        #[serde(rename = "invalidEntities")]
        invalid_entities: ::std::vec::Vec<Address>,
    },
    #[serde(rename = "rewardAccount")]
    RewardAccount {
        #[serde(rename = "expectedNetwork")]
        expected_network: Network,
        #[serde(rename = "invalidEntities")]
        invalid_entities: ::std::vec::Vec<RewardAccount>,
    },
    #[serde(rename = "stakePoolCertificate")]
    StakePoolCertificate {
        #[serde(rename = "expectedNetwork")]
        expected_network: Network,
        #[serde(rename = "invalidEntities")]
        invalid_entities: ::std::vec::Vec<StakePoolId>,
    },
    #[serde(rename = "transaction")]
    Transaction {
        #[serde(rename = "expectedNetwork")]
        expected_network: Network,
    },
}
impl ::std::convert::From<&Self> for SubmitTransactionFailureNetworkMismatchData {
    fn from(value: &SubmitTransactionFailureNetworkMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureNonAdaCollateralCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3133"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureNonAdaCollateralCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureNonAdaCollateralCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureNonAdaCollateralCode> for i64 {
    fn from(value: SubmitTransactionFailureNonAdaCollateralCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureNonAdaCollateralCode>
    for SubmitTransactionFailureNonAdaCollateralCode
{
    fn from(value: &SubmitTransactionFailureNonAdaCollateralCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureNonAdaCollateralCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3133_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureNonAdaCollateralCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureNonAdaCollateralData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unsuitableCollateralValue\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unsuitableCollateralValue\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureNonAdaCollateralData {
    #[serde(rename = "unsuitableCollateralValue")]
    pub unsuitable_collateral_value: Value,
}
impl ::std::convert::From<&SubmitTransactionFailureNonAdaCollateralData>
    for SubmitTransactionFailureNonAdaCollateralData
{
    fn from(value: &SubmitTransactionFailureNonAdaCollateralData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureNonEmptyRewardAccountCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3147"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureNonEmptyRewardAccountCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureNonEmptyRewardAccountCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureNonEmptyRewardAccountCode> for i64 {
    fn from(value: SubmitTransactionFailureNonEmptyRewardAccountCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureNonEmptyRewardAccountCode>
    for SubmitTransactionFailureNonEmptyRewardAccountCode
{
    fn from(value: &SubmitTransactionFailureNonEmptyRewardAccountCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureNonEmptyRewardAccountCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3147_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureNonEmptyRewardAccountCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureNonEmptyRewardAccountData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"nonEmptyRewardAccountBalance\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"nonEmptyRewardAccountBalance\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureNonEmptyRewardAccountData {
    #[serde(rename = "nonEmptyRewardAccountBalance")]
    pub non_empty_reward_account_balance: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureNonEmptyRewardAccountData>
    for SubmitTransactionFailureNonEmptyRewardAccountData
{
    fn from(value: &SubmitTransactionFailureNonEmptyRewardAccountData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureOrphanScriptInputsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3114"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureOrphanScriptInputsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureOrphanScriptInputsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureOrphanScriptInputsCode> for i64 {
    fn from(value: SubmitTransactionFailureOrphanScriptInputsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureOrphanScriptInputsCode>
    for SubmitTransactionFailureOrphanScriptInputsCode
{
    fn from(value: &SubmitTransactionFailureOrphanScriptInputsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureOrphanScriptInputsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3114_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureOrphanScriptInputsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureOrphanScriptInputsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"orphanScriptInputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"orphanScriptInputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureOrphanScriptInputsData {
    #[serde(rename = "orphanScriptInputs")]
    pub orphan_script_inputs: ::std::vec::Vec<TransactionOutputReference>,
}
impl ::std::convert::From<&SubmitTransactionFailureOrphanScriptInputsData>
    for SubmitTransactionFailureOrphanScriptInputsData
{
    fn from(value: &SubmitTransactionFailureOrphanScriptInputsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureOutsideOfValidityIntervalCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3118"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureOutsideOfValidityIntervalCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureOutsideOfValidityIntervalCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureOutsideOfValidityIntervalCode> for i64 {
    fn from(value: SubmitTransactionFailureOutsideOfValidityIntervalCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureOutsideOfValidityIntervalCode>
    for SubmitTransactionFailureOutsideOfValidityIntervalCode
{
    fn from(value: &SubmitTransactionFailureOutsideOfValidityIntervalCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureOutsideOfValidityIntervalCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3118_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureOutsideOfValidityIntervalCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureOutsideOfValidityIntervalData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"currentSlot\","]
#[doc = "    \"validityInterval\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"currentSlot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    },"]
#[doc = "    \"validityInterval\": {"]
#[doc = "      \"$ref\": \"#/definitions/ValidityInterval\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureOutsideOfValidityIntervalData {
    #[serde(rename = "currentSlot")]
    pub current_slot: Slot,
    #[serde(rename = "validityInterval")]
    pub validity_interval: ValidityInterval,
}
impl ::std::convert::From<&SubmitTransactionFailureOutsideOfValidityIntervalData>
    for SubmitTransactionFailureOutsideOfValidityIntervalData
{
    fn from(value: &SubmitTransactionFailureOutsideOfValidityIntervalData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureReferenceScriptsTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3166"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureReferenceScriptsTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureReferenceScriptsTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureReferenceScriptsTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureReferenceScriptsTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureReferenceScriptsTooLargeCode>
    for SubmitTransactionFailureReferenceScriptsTooLargeCode
{
    fn from(value: &SubmitTransactionFailureReferenceScriptsTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureReferenceScriptsTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3166_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureReferenceScriptsTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureReferenceScriptsTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"maximumReferenceScriptsSize\","]
#[doc = "    \"measuredReferenceScriptsSize\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"maximumReferenceScriptsSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"measuredReferenceScriptsSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureReferenceScriptsTooLargeData {
    #[serde(rename = "maximumReferenceScriptsSize")]
    pub maximum_reference_scripts_size: NumberOfBytes,
    #[serde(rename = "measuredReferenceScriptsSize")]
    pub measured_reference_scripts_size: NumberOfBytes,
}
impl ::std::convert::From<&SubmitTransactionFailureReferenceScriptsTooLargeData>
    for SubmitTransactionFailureReferenceScriptsTooLargeData
{
    fn from(value: &SubmitTransactionFailureReferenceScriptsTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureRetirementTooLateCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3142"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureRetirementTooLateCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureRetirementTooLateCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureRetirementTooLateCode> for i64 {
    fn from(value: SubmitTransactionFailureRetirementTooLateCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureRetirementTooLateCode>
    for SubmitTransactionFailureRetirementTooLateCode
{
    fn from(value: &SubmitTransactionFailureRetirementTooLateCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureRetirementTooLateCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3142_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureRetirementTooLateCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureRetirementTooLateData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"currentEpoch\","]
#[doc = "    \"declaredEpoch\","]
#[doc = "    \"firstInvalidEpoch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"currentEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"declaredEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    },"]
#[doc = "    \"firstInvalidEpoch\": {"]
#[doc = "      \"$ref\": \"#/definitions/Epoch\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureRetirementTooLateData {
    #[serde(rename = "currentEpoch")]
    pub current_epoch: Epoch,
    #[serde(rename = "declaredEpoch")]
    pub declared_epoch: Epoch,
    #[serde(rename = "firstInvalidEpoch")]
    pub first_invalid_epoch: Epoch,
}
impl ::std::convert::From<&SubmitTransactionFailureRetirementTooLateData>
    for SubmitTransactionFailureRetirementTooLateData
{
    fn from(value: &SubmitTransactionFailureRetirementTooLateData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureScriptIntegrityHashMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3113"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureScriptIntegrityHashMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureScriptIntegrityHashMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureScriptIntegrityHashMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureScriptIntegrityHashMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureScriptIntegrityHashMismatchCode>
    for SubmitTransactionFailureScriptIntegrityHashMismatchCode
{
    fn from(value: &SubmitTransactionFailureScriptIntegrityHashMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureScriptIntegrityHashMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3113_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureScriptIntegrityHashMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureScriptIntegrityHashMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"computedScriptIntegrity\","]
#[doc = "    \"providedScriptIntegrity\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"computedScriptIntegrity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"providedScriptIntegrity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/Null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureScriptIntegrityHashMismatchData {
    #[serde(rename = "computedScriptIntegrity")]
    pub computed_script_integrity:
        SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity,
    #[serde(rename = "providedScriptIntegrity")]
    pub provided_script_integrity:
        SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity,
}
impl ::std::convert::From<&SubmitTransactionFailureScriptIntegrityHashMismatchData>
    for SubmitTransactionFailureScriptIntegrityHashMismatchData
{
    fn from(value: &SubmitTransactionFailureScriptIntegrityHashMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity {
    DigestBlake2b256(DigestBlake2b256),
    Null(Null),
}
impl ::std::convert::From<&Self>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity
{
    fn from(
        value: &SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity,
    ) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DigestBlake2b256>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity
{
    fn from(value: DigestBlake2b256) -> Self {
        Self::DigestBlake2b256(value)
    }
}
impl ::std::convert::From<Null>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataComputedScriptIntegrity
{
    fn from(value: Null) -> Self {
        Self::Null(value)
    }
}
#[doc = "SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity {
    DigestBlake2b256(DigestBlake2b256),
    Null(Null),
}
impl ::std::convert::From<&Self>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity
{
    fn from(
        value: &SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity,
    ) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DigestBlake2b256>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity
{
    fn from(value: DigestBlake2b256) -> Self {
        Self::DigestBlake2b256(value)
    }
}
impl ::std::convert::From<Null>
    for SubmitTransactionFailureScriptIntegrityHashMismatchDataProvidedScriptIntegrity
{
    fn from(value: Null) -> Self {
        Self::Null(value)
    }
}
#[doc = "SubmitTransactionFailureSpendsMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3136"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureSpendsMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureSpendsMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureSpendsMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureSpendsMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureSpendsMismatchCode>
    for SubmitTransactionFailureSpendsMismatchCode
{
    fn from(value: &SubmitTransactionFailureSpendsMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureSpendsMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3136_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureSpendsMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureSpendsMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"declaredSpending\","]
#[doc = "    \"mismatchReason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"declaredSpending\": {"]
#[doc = "      \"$ref\": \"#/definitions/InputSource\""]
#[doc = "    },"]
#[doc = "    \"mismatchReason\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureSpendsMismatchData {
    #[serde(rename = "declaredSpending")]
    pub declared_spending: InputSource,
    #[serde(rename = "mismatchReason")]
    pub mismatch_reason: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureSpendsMismatchData>
    for SubmitTransactionFailureSpendsMismatchData
{
    fn from(value: &SubmitTransactionFailureSpendsMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureStakePoolCostTooLowCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3143"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureStakePoolCostTooLowCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureStakePoolCostTooLowCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureStakePoolCostTooLowCode> for i64 {
    fn from(value: SubmitTransactionFailureStakePoolCostTooLowCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureStakePoolCostTooLowCode>
    for SubmitTransactionFailureStakePoolCostTooLowCode
{
    fn from(value: &SubmitTransactionFailureStakePoolCostTooLowCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureStakePoolCostTooLowCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3143_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureStakePoolCostTooLowCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureStakePoolCostTooLowData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"declaredStakePoolCost\","]
#[doc = "    \"minimumStakePoolCost\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"declaredStakePoolCost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"minimumStakePoolCost\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureStakePoolCostTooLowData {
    #[serde(rename = "declaredStakePoolCost")]
    pub declared_stake_pool_cost: ValueAdaOnly,
    #[serde(rename = "minimumStakePoolCost")]
    pub minimum_stake_pool_cost: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureStakePoolCostTooLowData>
    for SubmitTransactionFailureStakePoolCostTooLowData
{
    fn from(value: &SubmitTransactionFailureStakePoolCostTooLowData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureTooManyCollateralInputsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3131"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureTooManyCollateralInputsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureTooManyCollateralInputsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureTooManyCollateralInputsCode> for i64 {
    fn from(value: SubmitTransactionFailureTooManyCollateralInputsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureTooManyCollateralInputsCode>
    for SubmitTransactionFailureTooManyCollateralInputsCode
{
    fn from(value: &SubmitTransactionFailureTooManyCollateralInputsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureTooManyCollateralInputsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3131_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureTooManyCollateralInputsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureTooManyCollateralInputsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"countedCollateralInputs\","]
#[doc = "    \"maximumCollateralInputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"countedCollateralInputs\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    },"]
#[doc = "    \"maximumCollateralInputs\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureTooManyCollateralInputsData {
    #[serde(rename = "countedCollateralInputs")]
    pub counted_collateral_inputs: UInt32,
    #[serde(rename = "maximumCollateralInputs")]
    pub maximum_collateral_inputs: UInt32,
}
impl ::std::convert::From<&SubmitTransactionFailureTooManyCollateralInputsData>
    for SubmitTransactionFailureTooManyCollateralInputsData
{
    fn from(value: &SubmitTransactionFailureTooManyCollateralInputsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureTotalCollateralMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3135"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureTotalCollateralMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureTotalCollateralMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureTotalCollateralMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureTotalCollateralMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureTotalCollateralMismatchCode>
    for SubmitTransactionFailureTotalCollateralMismatchCode
{
    fn from(value: &SubmitTransactionFailureTotalCollateralMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureTotalCollateralMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3135_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureTotalCollateralMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureTotalCollateralMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"computedTotalCollateral\","]
#[doc = "    \"declaredTotalCollateral\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"computedTotalCollateral\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<Delta>\""]
#[doc = "    },"]
#[doc = "    \"declaredTotalCollateral\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureTotalCollateralMismatchData {
    #[serde(rename = "computedTotalCollateral")]
    pub computed_total_collateral: ValueDelta,
    #[serde(rename = "declaredTotalCollateral")]
    pub declared_total_collateral: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureTotalCollateralMismatchData>
    for SubmitTransactionFailureTotalCollateralMismatchData
{
    fn from(value: &SubmitTransactionFailureTotalCollateralMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureTransactionFeeTooSmallCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3122"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureTransactionFeeTooSmallCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureTransactionFeeTooSmallCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureTransactionFeeTooSmallCode> for i64 {
    fn from(value: SubmitTransactionFailureTransactionFeeTooSmallCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureTransactionFeeTooSmallCode>
    for SubmitTransactionFailureTransactionFeeTooSmallCode
{
    fn from(value: &SubmitTransactionFailureTransactionFeeTooSmallCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureTransactionFeeTooSmallCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3122_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureTransactionFeeTooSmallCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureTransactionFeeTooSmallData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"minimumRequiredFee\","]
#[doc = "    \"providedFee\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"minimumRequiredFee\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"providedFee\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureTransactionFeeTooSmallData {
    #[serde(rename = "minimumRequiredFee")]
    pub minimum_required_fee: ValueAdaOnly,
    #[serde(rename = "providedFee")]
    pub provided_fee: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureTransactionFeeTooSmallData>
    for SubmitTransactionFailureTransactionFeeTooSmallData
{
    fn from(value: &SubmitTransactionFailureTransactionFeeTooSmallData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureTransactionTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3119"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureTransactionTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureTransactionTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureTransactionTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureTransactionTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureTransactionTooLargeCode>
    for SubmitTransactionFailureTransactionTooLargeCode
{
    fn from(value: &SubmitTransactionFailureTransactionTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureTransactionTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3119_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureTransactionTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureTransactionTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"maximumTransactionSize\","]
#[doc = "    \"measuredTransactionSize\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"maximumTransactionSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    },"]
#[doc = "    \"measuredTransactionSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/NumberOfBytes\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureTransactionTooLargeData {
    #[serde(rename = "maximumTransactionSize")]
    pub maximum_transaction_size: NumberOfBytes,
    #[serde(rename = "measuredTransactionSize")]
    pub measured_transaction_size: NumberOfBytes,
}
impl ::std::convert::From<&SubmitTransactionFailureTransactionTooLargeData>
    for SubmitTransactionFailureTransactionTooLargeData
{
    fn from(value: &SubmitTransactionFailureTransactionTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureTreasuryWithdrawalMismatchCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3158"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureTreasuryWithdrawalMismatchCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureTreasuryWithdrawalMismatchCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureTreasuryWithdrawalMismatchCode> for i64 {
    fn from(value: SubmitTransactionFailureTreasuryWithdrawalMismatchCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureTreasuryWithdrawalMismatchCode>
    for SubmitTransactionFailureTreasuryWithdrawalMismatchCode
{
    fn from(value: &SubmitTransactionFailureTreasuryWithdrawalMismatchCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureTreasuryWithdrawalMismatchCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3158_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureTreasuryWithdrawalMismatchCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureTreasuryWithdrawalMismatchData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"computedWithdrawal\","]
#[doc = "    \"providedWithdrawal\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"computedWithdrawal\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"providedWithdrawal\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureTreasuryWithdrawalMismatchData {
    #[serde(rename = "computedWithdrawal")]
    pub computed_withdrawal: ValueAdaOnly,
    #[serde(rename = "providedWithdrawal")]
    pub provided_withdrawal: ValueAdaOnly,
}
impl ::std::convert::From<&SubmitTransactionFailureTreasuryWithdrawalMismatchData>
    for SubmitTransactionFailureTreasuryWithdrawalMismatchData
{
    fn from(value: &SubmitTransactionFailureTreasuryWithdrawalMismatchData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnauthorizedGovernanceActionCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3165"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnauthorizedGovernanceActionCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnauthorizedGovernanceActionCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnauthorizedGovernanceActionCode> for i64 {
    fn from(value: SubmitTransactionFailureUnauthorizedGovernanceActionCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnauthorizedGovernanceActionCode>
    for SubmitTransactionFailureUnauthorizedGovernanceActionCode
{
    fn from(value: &SubmitTransactionFailureUnauthorizedGovernanceActionCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnauthorizedGovernanceActionCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3165_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnauthorizedGovernanceActionCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnauthorizedVotesCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3137"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnauthorizedVotesCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnauthorizedVotesCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnauthorizedVotesCode> for i64 {
    fn from(value: SubmitTransactionFailureUnauthorizedVotesCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnauthorizedVotesCode>
    for SubmitTransactionFailureUnauthorizedVotesCode
{
    fn from(value: &SubmitTransactionFailureUnauthorizedVotesCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnauthorizedVotesCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3137_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnauthorizedVotesCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnauthorizedVotesData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unauthorizedVotes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unauthorizedVotes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"proposal\","]
#[doc = "          \"voter\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"proposal\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "          },"]
#[doc = "          \"voter\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnauthorizedVotesData {
    #[serde(rename = "unauthorizedVotes")]
    pub unauthorized_votes:
        ::std::vec::Vec<SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem>,
}
impl ::std::convert::From<&SubmitTransactionFailureUnauthorizedVotesData>
    for SubmitTransactionFailureUnauthorizedVotesData
{
    fn from(value: &SubmitTransactionFailureUnauthorizedVotesData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"proposal\","]
#[doc = "    \"voter\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "    },"]
#[doc = "    \"voter\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem {
    pub proposal: GovernanceProposalReference,
    pub voter: GovernanceVoter,
}
impl ::std::convert::From<&SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem>
    for SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem
{
    fn from(value: &SubmitTransactionFailureUnauthorizedVotesDataUnauthorizedVotesItem) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnexpectedMempoolErrorCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3997"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnexpectedMempoolErrorCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnexpectedMempoolErrorCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnexpectedMempoolErrorCode> for i64 {
    fn from(value: SubmitTransactionFailureUnexpectedMempoolErrorCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnexpectedMempoolErrorCode>
    for SubmitTransactionFailureUnexpectedMempoolErrorCode
{
    fn from(value: &SubmitTransactionFailureUnexpectedMempoolErrorCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnexpectedMempoolErrorCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3997_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnexpectedMempoolErrorCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnforeseeableSlotCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3130"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnforeseeableSlotCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnforeseeableSlotCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnforeseeableSlotCode> for i64 {
    fn from(value: SubmitTransactionFailureUnforeseeableSlotCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnforeseeableSlotCode>
    for SubmitTransactionFailureUnforeseeableSlotCode
{
    fn from(value: &SubmitTransactionFailureUnforeseeableSlotCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnforeseeableSlotCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3130_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnforeseeableSlotCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnforeseeableSlotData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unforeseeableSlot\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unforeseeableSlot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnforeseeableSlotData {
    #[serde(rename = "unforeseeableSlot")]
    pub unforeseeable_slot: Slot,
}
impl ::std::convert::From<&SubmitTransactionFailureUnforeseeableSlotData>
    for SubmitTransactionFailureUnforeseeableSlotData
{
    fn from(value: &SubmitTransactionFailureUnforeseeableSlotData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3154"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode>
    for i64
{
    fn from(value: SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode>
    for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode
{
    fn from(value: &SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64>
    for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode
{
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3154_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de>
    for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberCode
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownConstitutionalCommitteeMember\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownConstitutionalCommitteeMember\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData { # [serde (rename = "unknownConstitutionalCommitteeMember")] pub unknown_constitutional_committee_member : SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember , }
impl ::std::convert::From<&SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData>
    for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData
{
    fn from(value: &SubmitTransactionFailureUnknownConstitutionalCommitteeMemberData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember
{
    pub from: CredentialOrigin,
    pub id: DigestBlake2b224,
}
impl :: std :: convert :: From < & SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember > for SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember { fn from (value : & SubmitTransactionFailureUnknownConstitutionalCommitteeMemberDataUnknownConstitutionalCommitteeMember) -> Self { value . clone () } }
#[doc = "SubmitTransactionFailureUnknownCredentialCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3146"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownCredentialCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownCredentialCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownCredentialCode> for i64 {
    fn from(value: SubmitTransactionFailureUnknownCredentialCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownCredentialCode>
    for SubmitTransactionFailureUnknownCredentialCode
{
    fn from(value: &SubmitTransactionFailureUnknownCredentialCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnknownCredentialCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3146_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnknownCredentialCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownCredentialData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"unknownCredential\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"$ref\": \"#/definitions/CredentialOrigin\""]
#[doc = "    },"]
#[doc = "    \"unknownCredential\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownCredentialData {
    pub from: CredentialOrigin,
    #[serde(rename = "unknownCredential")]
    pub unknown_credential: DigestBlake2b224,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownCredentialData>
    for SubmitTransactionFailureUnknownCredentialData
{
    fn from(value: &SubmitTransactionFailureUnknownCredentialData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownGovernanceProposalsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3138"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownGovernanceProposalsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownGovernanceProposalsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownGovernanceProposalsCode> for i64 {
    fn from(value: SubmitTransactionFailureUnknownGovernanceProposalsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownGovernanceProposalsCode>
    for SubmitTransactionFailureUnknownGovernanceProposalsCode
{
    fn from(value: &SubmitTransactionFailureUnknownGovernanceProposalsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnknownGovernanceProposalsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3138_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnknownGovernanceProposalsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownGovernanceProposalsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownProposals\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownProposals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownGovernanceProposalsData {
    #[serde(rename = "unknownProposals")]
    pub unknown_proposals: ::std::vec::Vec<GovernanceProposalReference>,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownGovernanceProposalsData>
    for SubmitTransactionFailureUnknownGovernanceProposalsData
{
    fn from(value: &SubmitTransactionFailureUnknownGovernanceProposalsData) -> Self {
        value.clone()
    }
}
#[doc = "The transaction contains unknown UTxO references as inputs. This can happen if the inputs you're trying to spend have already been spent, or if you've simply referred to non-existing UTxO altogether. The field 'data.unknownOutputReferences' indicates all unknown inputs."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubmitTransactionFailure<UnknownOutputReferences>\","]
#[doc = "  \"description\": \"The transaction contains unknown UTxO references as inputs. This can happen if the inputs you're trying to spend have already been spent, or if you've simply referred to non-existing UTxO altogether. The field 'data.unknownOutputReferences' indicates all unknown inputs.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"data\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"enum\": ["]
#[doc = "        3117"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"unknownOutputReferences\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"unknownOutputReferences\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownOutputReference {
    pub code: SubmitTransactionFailureUnknownOutputReferenceCode,
    pub data: SubmitTransactionFailureUnknownOutputReferenceData,
    pub message: ::std::string::String,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownOutputReference>
    for SubmitTransactionFailureUnknownOutputReference
{
    fn from(value: &SubmitTransactionFailureUnknownOutputReference) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownOutputReferenceCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3117"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownOutputReferenceCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownOutputReferenceCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownOutputReferenceCode> for i64 {
    fn from(value: SubmitTransactionFailureUnknownOutputReferenceCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownOutputReferenceCode>
    for SubmitTransactionFailureUnknownOutputReferenceCode
{
    fn from(value: &SubmitTransactionFailureUnknownOutputReferenceCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnknownOutputReferenceCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3117_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnknownOutputReferenceCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownOutputReferenceData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownOutputReferences\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownOutputReferences\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownOutputReferenceData {
    #[serde(rename = "unknownOutputReferences")]
    pub unknown_output_references: ::std::vec::Vec<TransactionOutputReference>,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownOutputReferenceData>
    for SubmitTransactionFailureUnknownOutputReferenceData
{
    fn from(value: &SubmitTransactionFailureUnknownOutputReferenceData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownStakePoolCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3140"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownStakePoolCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownStakePoolCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownStakePoolCode> for i64 {
    fn from(value: SubmitTransactionFailureUnknownStakePoolCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownStakePoolCode>
    for SubmitTransactionFailureUnknownStakePoolCode
{
    fn from(value: &SubmitTransactionFailureUnknownStakePoolCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnknownStakePoolCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3140_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnknownStakePoolCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownStakePoolData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownStakePool\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownStakePool\": {"]
#[doc = "      \"$ref\": \"#/definitions/StakePoolId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownStakePoolData {
    #[serde(rename = "unknownStakePool")]
    pub unknown_stake_pool: StakePoolId,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownStakePoolData>
    for SubmitTransactionFailureUnknownStakePoolData
{
    fn from(value: &SubmitTransactionFailureUnknownStakePoolData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnknownVotersCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3167"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnknownVotersCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnknownVotersCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnknownVotersCode> for i64 {
    fn from(value: SubmitTransactionFailureUnknownVotersCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownVotersCode>
    for SubmitTransactionFailureUnknownVotersCode
{
    fn from(value: &SubmitTransactionFailureUnknownVotersCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnknownVotersCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3167_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnknownVotersCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureUnknownVotersData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"unknownVoters\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"unknownVoters\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureUnknownVotersData {
    #[serde(rename = "unknownVoters")]
    pub unknown_voters: ::std::vec::Vec<GovernanceVoter>,
}
impl ::std::convert::From<&SubmitTransactionFailureUnknownVotersData>
    for SubmitTransactionFailureUnknownVotersData
{
    fn from(value: &SubmitTransactionFailureUnknownVotersData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureUnrecognizedCertificateTypeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3998"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureUnrecognizedCertificateTypeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureUnrecognizedCertificateTypeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureUnrecognizedCertificateTypeCode> for i64 {
    fn from(value: SubmitTransactionFailureUnrecognizedCertificateTypeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureUnrecognizedCertificateTypeCode>
    for SubmitTransactionFailureUnrecognizedCertificateTypeCode
{
    fn from(value: &SubmitTransactionFailureUnrecognizedCertificateTypeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureUnrecognizedCertificateTypeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3998_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureUnrecognizedCertificateTypeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureValueNotConservedCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3123"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureValueNotConservedCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureValueNotConservedCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureValueNotConservedCode> for i64 {
    fn from(value: SubmitTransactionFailureValueNotConservedCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureValueNotConservedCode>
    for SubmitTransactionFailureValueNotConservedCode
{
    fn from(value: &SubmitTransactionFailureValueNotConservedCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureValueNotConservedCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3123_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureValueNotConservedCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureValueNotConservedData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"valueConsumed\","]
#[doc = "    \"valueProduced\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"valueConsumed\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value\""]
#[doc = "    },"]
#[doc = "    \"valueProduced\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureValueNotConservedData {
    #[serde(rename = "valueConsumed")]
    pub value_consumed: Value,
    #[serde(rename = "valueProduced")]
    pub value_produced: Value,
}
impl ::std::convert::From<&SubmitTransactionFailureValueNotConservedData>
    for SubmitTransactionFailureValueNotConservedData
{
    fn from(value: &SubmitTransactionFailureValueNotConservedData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureValueTooLargeCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3120"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureValueTooLargeCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureValueTooLargeCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureValueTooLargeCode> for i64 {
    fn from(value: SubmitTransactionFailureValueTooLargeCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureValueTooLargeCode>
    for SubmitTransactionFailureValueTooLargeCode
{
    fn from(value: &SubmitTransactionFailureValueTooLargeCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureValueTooLargeCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3120_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureValueTooLargeCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureValueTooLargeData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"excessivelyLargeOutputs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"excessivelyLargeOutputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureValueTooLargeData {
    #[serde(rename = "excessivelyLargeOutputs")]
    pub excessively_large_outputs: ::std::vec::Vec<TransactionOutput>,
}
impl ::std::convert::From<&SubmitTransactionFailureValueTooLargeData>
    for SubmitTransactionFailureValueTooLargeData
{
    fn from(value: &SubmitTransactionFailureValueTooLargeData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureVotingOnExpiredActionsCode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"enum\": ["]
#[doc = "    3160"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct SubmitTransactionFailureVotingOnExpiredActionsCode(i64);
impl ::std::ops::Deref for SubmitTransactionFailureVotingOnExpiredActionsCode {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionFailureVotingOnExpiredActionsCode> for i64 {
    fn from(value: SubmitTransactionFailureVotingOnExpiredActionsCode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionFailureVotingOnExpiredActionsCode>
    for SubmitTransactionFailureVotingOnExpiredActionsCode
{
    fn from(value: &SubmitTransactionFailureVotingOnExpiredActionsCode) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<i64> for SubmitTransactionFailureVotingOnExpiredActionsCode {
    type Error = self::error::ConversionError;
    fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
        if ![3160_i64].contains(&value) {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionFailureVotingOnExpiredActionsCode {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<i64>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SubmitTransactionFailureVotingOnExpiredActionsData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"invalidVotes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"invalidVotes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"proposal\","]
#[doc = "          \"voter\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"proposal\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "          },"]
#[doc = "          \"voter\": {"]
#[doc = "            \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureVotingOnExpiredActionsData {
    #[serde(rename = "invalidVotes")]
    pub invalid_votes:
        ::std::vec::Vec<SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem>,
}
impl ::std::convert::From<&SubmitTransactionFailureVotingOnExpiredActionsData>
    for SubmitTransactionFailureVotingOnExpiredActionsData
{
    fn from(value: &SubmitTransactionFailureVotingOnExpiredActionsData) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"proposal\","]
#[doc = "    \"voter\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"proposal\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceProposalReference\""]
#[doc = "    },"]
#[doc = "    \"voter\": {"]
#[doc = "      \"$ref\": \"#/definitions/GovernanceVoter\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem {
    pub proposal: GovernanceProposalReference,
    pub voter: GovernanceVoter,
}
impl ::std::convert::From<&SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem>
    for SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem
{
    fn from(value: &SubmitTransactionFailureVotingOnExpiredActionsDataInvalidVotesItem) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SubmitTransactionJsonrpc {
    fn from(value: &SubmitTransactionJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"submitTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionMethod {
    #[serde(rename = "submitTransaction")]
    SubmitTransaction,
}
impl ::std::convert::From<&Self> for SubmitTransactionMethod {
    fn from(value: &SubmitTransactionMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SubmitTransaction => write!(f, "submitTransaction"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "submitTransaction" => Ok(Self::SubmitTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cbor\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cbor\": {"]
#[doc = "          \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "          \"contentEncoding\": \"base16\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionParams {
    pub transaction: SubmitTransactionParamsTransaction,
}
impl ::std::convert::From<&SubmitTransactionParams> for SubmitTransactionParams {
    fn from(value: &SubmitTransactionParams) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionParamsTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cbor\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cbor\": {"]
#[doc = "      \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "      \"contentEncoding\": \"base16\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionParamsTransaction {
    #[doc = "CBOR-serialized signed transaction (base16)"]
    pub cbor: SubmitTransactionParamsTransactionCbor,
}
impl ::std::convert::From<&SubmitTransactionParamsTransaction>
    for SubmitTransactionParamsTransaction
{
    fn from(value: &SubmitTransactionParamsTransaction) -> Self {
        value.clone()
    }
}
#[doc = "CBOR-serialized signed transaction (base16)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"CBOR-serialized signed transaction (base16)\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct SubmitTransactionParamsTransactionCbor(::std::string::String);
impl ::std::ops::Deref for SubmitTransactionParamsTransactionCbor {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<SubmitTransactionParamsTransactionCbor> for ::std::string::String {
    fn from(value: SubmitTransactionParamsTransactionCbor) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SubmitTransactionParamsTransactionCbor>
    for SubmitTransactionParamsTransactionCbor
{
    fn from(value: &SubmitTransactionParamsTransactionCbor) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for SubmitTransactionParamsTransactionCbor {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionParamsTransactionCbor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for SubmitTransactionParamsTransactionCbor {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "SubmitTransactionSuccessJsonrpc"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"2.0\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionSuccessJsonrpc {
    #[serde(rename = "2.0")]
    _20,
}
impl ::std::convert::From<&Self> for SubmitTransactionSuccessJsonrpc {
    fn from(value: &SubmitTransactionSuccessJsonrpc) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionSuccessJsonrpc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::_20 => write!(f, "2.0"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionSuccessJsonrpc {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "2.0" => Ok(Self::_20),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionSuccessJsonrpc {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionSuccessMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"submitTransaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SubmitTransactionSuccessMethod {
    #[serde(rename = "submitTransaction")]
    SubmitTransaction,
}
impl ::std::convert::From<&Self> for SubmitTransactionSuccessMethod {
    fn from(value: &SubmitTransactionSuccessMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SubmitTransactionSuccessMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SubmitTransaction => write!(f, "submitTransaction"),
        }
    }
}
impl ::std::str::FromStr for SubmitTransactionSuccessMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "submitTransaction" => Ok(Self::SubmitTransaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SubmitTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SubmitTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SubmitTransactionSuccessMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SubmitTransactionSuccessResult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionSuccessResult {
    pub transaction: SubmitTransactionSuccessResultTransaction,
}
impl ::std::convert::From<&SubmitTransactionSuccessResult> for SubmitTransactionSuccessResult {
    fn from(value: &SubmitTransactionSuccessResult) -> Self {
        value.clone()
    }
}
#[doc = "SubmitTransactionSuccessResultTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SubmitTransactionSuccessResultTransaction {
    pub id: TransactionId,
}
impl ::std::convert::From<&SubmitTransactionSuccessResultTransaction>
    for SubmitTransactionSuccessResultTransaction
{
    fn from(value: &SubmitTransactionSuccessResultTransaction) -> Self {
        value.clone()
    }
}
#[doc = "Tip"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Tip\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"height\","]
#[doc = "    \"id\","]
#[doc = "    \"slot\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/BlockHeight\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"slot\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Tip {
    pub height: BlockHeight,
    pub id: DigestBlake2b256,
    pub slot: Slot,
}
impl ::std::convert::From<&Tip> for Tip {
    fn from(value: &Tip) -> Self {
        value.clone()
    }
}
#[doc = "TipOrOrigin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Tip\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/Origin\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TipOrOrigin {
    Tip(Tip),
    Origin(Origin),
}
impl ::std::convert::From<&Self> for TipOrOrigin {
    fn from(value: &TipOrOrigin) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Tip> for TipOrOrigin {
    fn from(value: Tip) -> Self {
        Self::Tip(value)
    }
}
impl ::std::convert::From<Origin> for TipOrOrigin {
    fn from(value: Origin) -> Self {
        Self::Origin(value)
    }
}
#[doc = "Transaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Transaction\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"inputs\","]
#[doc = "    \"outputs\","]
#[doc = "    \"signatories\","]
#[doc = "    \"spends\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cbor\": {"]
#[doc = "      \"description\": \"The raw serialized (CBOR) transaction, as found on-chain. Use --include-transaction-cbor to ALWAYS include the 'cbor' field. Omitted otherwise.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"contentEncoding\": \"base16\""]
#[doc = "    },"]
#[doc = "    \"certificates\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Certificate\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"collateralReturn\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "    },"]
#[doc = "    \"collaterals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"datums\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/Datum\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "        \"contentEncoding\": \"base16\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"fee\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"inputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"mint\": {"]
#[doc = "      \"$ref\": \"#/definitions/Assets\""]
#[doc = "    },"]
#[doc = "    \"network\": {"]
#[doc = "      \"$ref\": \"#/definitions/Network\""]
#[doc = "    },"]
#[doc = "    \"outputs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutput\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"proposals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GovernanceProposal\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"redeemers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Redeemer\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"references\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/TransactionOutputReference\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requiredExtraScripts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"requiredExtraSignatories\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 224>\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scriptIntegrityHash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"scripts\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/definitions/Script\""]
#[doc = "      },"]
#[doc = "      \"propertyNames\": {"]
#[doc = "        \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "        \"contentEncoding\": \"base16\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"signatories\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/Signatory\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"spends\": {"]
#[doc = "      \"$ref\": \"#/definitions/InputSource\""]
#[doc = "    },"]
#[doc = "    \"totalCollateral\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"treasury\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"donation\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        },"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"validityInterval\": {"]
#[doc = "      \"$ref\": \"#/definitions/ValidityInterval\""]
#[doc = "    },"]
#[doc = "    \"votes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/GovernanceVote\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"withdrawals\": {"]
#[doc = "      \"$ref\": \"#/definitions/Withdrawals\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Transaction {
    #[doc = "The raw serialized (CBOR) transaction, as found on-chain. Use --include-transaction-cbor to ALWAYS include the 'cbor' field. Omitted otherwise."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cbor: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub certificates: ::std::vec::Vec<Certificate>,
    #[serde(
        rename = "collateralReturn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub collateral_return: ::std::option::Option<TransactionOutput>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub collaterals: ::std::vec::Vec<TransactionOutputReference>,
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub datums: ::std::collections::HashMap<TransactionDatumsKey, Datum>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fee: ::std::option::Option<ValueAdaOnly>,
    pub id: DigestBlake2b256,
    pub inputs: ::std::vec::Vec<TransactionOutputReference>,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mint: ::std::option::Option<Assets>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub network: ::std::option::Option<Network>,
    pub outputs: ::std::vec::Vec<TransactionOutput>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub proposals: ::std::vec::Vec<GovernanceProposal>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub redeemers: ::std::vec::Vec<Redeemer>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub references: ::std::vec::Vec<TransactionOutputReference>,
    #[serde(
        rename = "requiredExtraScripts",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub required_extra_scripts: ::std::vec::Vec<DigestBlake2b224>,
    #[serde(
        rename = "requiredExtraSignatories",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub required_extra_signatories: ::std::vec::Vec<DigestBlake2b224>,
    #[serde(
        rename = "scriptIntegrityHash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub script_integrity_hash: ::std::option::Option<DigestBlake2b256>,
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub scripts: ::std::collections::HashMap<TransactionScriptsKey, Script>,
    pub signatories: ::std::vec::Vec<Signatory>,
    pub spends: InputSource,
    #[serde(
        rename = "totalCollateral",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_collateral: ::std::option::Option<ValueAdaOnly>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub treasury: ::std::option::Option<TransactionTreasury>,
    #[serde(
        rename = "validityInterval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub validity_interval: ::std::option::Option<ValidityInterval>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub votes: ::std::vec::Vec<GovernanceVote>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub withdrawals: ::std::option::Option<Withdrawals>,
}
impl ::std::convert::From<&Transaction> for Transaction {
    fn from(value: &Transaction) -> Self {
        value.clone()
    }
}
#[doc = "TransactionDatumsKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct TransactionDatumsKey(::std::string::String);
impl ::std::ops::Deref for TransactionDatumsKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<TransactionDatumsKey> for ::std::string::String {
    fn from(value: TransactionDatumsKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&TransactionDatumsKey> for TransactionDatumsKey {
    fn from(value: &TransactionDatumsKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TransactionDatumsKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for TransactionDatumsKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TransactionDatumsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TransactionDatumsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for TransactionDatumsKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A Blake2b 32-byte hash digest of a transaction body"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TransactionId\","]
#[doc = "  \"description\": \"A Blake2b 32-byte hash digest of a transaction body\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 64,"]
#[doc = "  \"minLength\": 64,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct TransactionId(::std::string::String);
impl ::std::ops::Deref for TransactionId {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<TransactionId> for ::std::string::String {
    fn from(value: TransactionId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&TransactionId> for TransactionId {
    fn from(value: &TransactionId) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TransactionId {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 64usize {
            return Err("longer than 64 characters".into());
        }
        if value.len() < 64usize {
            return Err("shorter than 64 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for TransactionId {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TransactionId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TransactionId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for TransactionId {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "A transaction output. 'datum' and 'datumHash' are never present together."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TransactionOutput\","]
#[doc = "  \"description\": \"A transaction output. 'datum' and 'datumHash' are never present together.\","]
#[doc = "  \"examples\": ["]
#[doc = "    {"]
#[doc = "      \"address\": \"addr_test1qz66ue36465w2qq40005h2hadad6pnjht8mu6sgplsfj74qdjnshguewlx4ww0eet26y2pal4xpav5prcydf28cvxtjqx46x7f\","]
#[doc = "      \"value\": {"]
#[doc = "        \"3542acb3a64d80c29302260d62c3b87a742ad14abf855ebc6733081e\": 42,"]
#[doc = "        \"ada\": {"]
#[doc = "          \"lovelace\": 2"]
#[doc = "        },"]
#[doc = "        \"b5ae663aaea8e500157bdf4baafd6f5ba0ce5759f7cd4101fc132f54.706174617465\": 1337"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"address\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"address\": {"]
#[doc = "      \"$ref\": \"#/definitions/Address\""]
#[doc = "    },"]
#[doc = "    \"datum\": {"]
#[doc = "      \"$ref\": \"#/definitions/Datum\""]
#[doc = "    },"]
#[doc = "    \"datumHash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"script\": {"]
#[doc = "      \"$ref\": \"#/definitions/Script\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TransactionOutput {
    pub address: Address,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datum: ::std::option::Option<Datum>,
    #[serde(
        rename = "datumHash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub datum_hash: ::std::option::Option<DigestBlake2b256>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub script: ::std::option::Option<Script>,
    pub value: Value,
}
impl ::std::convert::From<&TransactionOutput> for TransactionOutput {
    fn from(value: &TransactionOutput) -> Self {
        value.clone()
    }
}
#[doc = "TransactionOutputReference"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TransactionOutputReference\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"index\","]
#[doc = "    \"transaction\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"index\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt64\""]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TransactionOutputReference {
    pub index: UInt64,
    pub transaction: TransactionOutputReferenceTransaction,
}
impl ::std::convert::From<&TransactionOutputReference> for TransactionOutputReference {
    fn from(value: &TransactionOutputReference) -> Self {
        value.clone()
    }
}
#[doc = "TransactionOutputReferenceTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TransactionOutputReferenceTransaction {
    pub id: TransactionId,
}
impl ::std::convert::From<&TransactionOutputReferenceTransaction>
    for TransactionOutputReferenceTransaction
{
    fn from(value: &TransactionOutputReferenceTransaction) -> Self {
        value.clone()
    }
}
#[doc = "TransactionScriptsKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]+$\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct TransactionScriptsKey(::std::string::String);
impl ::std::ops::Deref for TransactionScriptsKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<TransactionScriptsKey> for ::std::string::String {
    fn from(value: TransactionScriptsKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&TransactionScriptsKey> for TransactionScriptsKey {
    fn from(value: &TransactionScriptsKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TransactionScriptsKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for TransactionScriptsKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TransactionScriptsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TransactionScriptsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for TransactionScriptsKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "TransactionTreasury"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"donation\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TransactionTreasury {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub donation: ::std::option::Option<ValueAdaOnly>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub value: ::std::option::Option<ValueAdaOnly>,
}
impl ::std::convert::From<&TransactionTreasury> for TransactionTreasury {
    fn from(value: &TransactionTreasury) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TransactionTreasury {
    fn default() -> Self {
        Self {
            donation: Default::default(),
            value: Default::default(),
        }
    }
}
#[doc = "UInt16"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UInt16\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 65536.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UInt16(pub i64);
impl ::std::ops::Deref for UInt16 {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}
impl ::std::convert::From<UInt16> for i64 {
    fn from(value: UInt16) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UInt16> for UInt16 {
    fn from(value: &UInt16) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<i64> for UInt16 {
    fn from(value: i64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for UInt16 {
    type Err = <i64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for UInt16 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for UInt16 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for UInt16 {
    type Error = <i64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for UInt16 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "UInt32"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UInt32\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 4294967295.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UInt32(pub u32);
impl ::std::ops::Deref for UInt32 {
    type Target = u32;
    fn deref(&self) -> &u32 {
        &self.0
    }
}
impl ::std::convert::From<UInt32> for u32 {
    fn from(value: UInt32) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UInt32> for UInt32 {
    fn from(value: &UInt32) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u32> for UInt32 {
    fn from(value: u32) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for UInt32 {
    type Err = <u32 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for UInt32 {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for UInt32 {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for UInt32 {
    type Error = <u32 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for UInt32 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "UInt64"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UInt64\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 1.8446744073709552e19,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UInt64(pub u64);
impl ::std::ops::Deref for UInt64 {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<UInt64> for u64 {
    fn from(value: UInt64) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UInt64> for UInt64 {
    fn from(value: &UInt64) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for UInt64 {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for UInt64 {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for UInt64 {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for UInt64 {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for UInt64 {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for UInt64 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "UInt8"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UInt8\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"maximum\": 255.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UInt8(pub u8);
impl ::std::ops::Deref for UInt8 {
    type Target = u8;
    fn deref(&self) -> &u8 {
        &self.0
    }
}
impl ::std::convert::From<UInt8> for u8 {
    fn from(value: UInt8) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UInt8> for UInt8 {
    fn from(value: &UInt8) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u8> for UInt8 {
    fn from(value: u8) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for UInt8 {
    type Err = <u8 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for UInt8 {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for UInt8 {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for UInt8 {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for UInt8 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "UtcTime"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UtcTime\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"format\": \"date-time\","]
#[doc = "  \"pattern\": \"[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.?[0-9]*Z?\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct UtcTime(pub chrono::DateTime<chrono::offset::Utc>);
impl ::std::ops::Deref for UtcTime {
    type Target = chrono::DateTime<chrono::offset::Utc>;
    fn deref(&self) -> &chrono::DateTime<chrono::offset::Utc> {
        &self.0
    }
}
impl ::std::convert::From<UtcTime> for chrono::DateTime<chrono::offset::Utc> {
    fn from(value: UtcTime) -> Self {
        value.0
    }
}
impl ::std::convert::From<&UtcTime> for UtcTime {
    fn from(value: &UtcTime) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<chrono::DateTime<chrono::offset::Utc>> for UtcTime {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for UtcTime {
    type Err = <chrono::DateTime<chrono::offset::Utc> as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for UtcTime {
    type Error = <chrono::DateTime<chrono::offset::Utc> as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for UtcTime {
    type Error = <chrono::DateTime<chrono::offset::Utc> as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for UtcTime {
    type Error = <chrono::DateTime<chrono::offset::Utc> as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for UtcTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Utxo"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Utxo\","]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"address\","]
#[doc = "      \"index\","]
#[doc = "      \"transaction\","]
#[doc = "      \"value\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"address\": {"]
#[doc = "        \"$ref\": \"#/definitions/Address\""]
#[doc = "      },"]
#[doc = "      \"datum\": {"]
#[doc = "        \"$ref\": \"#/definitions/Datum\""]
#[doc = "      },"]
#[doc = "      \"datumHash\": {"]
#[doc = "        \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "      },"]
#[doc = "      \"index\": {"]
#[doc = "        \"$ref\": \"#/definitions/UInt32\""]
#[doc = "      },"]
#[doc = "      \"script\": {"]
#[doc = "        \"$ref\": \"#/definitions/Script\""]
#[doc = "      },"]
#[doc = "      \"transaction\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"id\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"id\": {"]
#[doc = "            \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      },"]
#[doc = "      \"value\": {"]
#[doc = "        \"$ref\": \"#/definitions/Value\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Utxo(pub ::std::vec::Vec<UtxoItem>);
impl ::std::ops::Deref for Utxo {
    type Target = ::std::vec::Vec<UtxoItem>;
    fn deref(&self) -> &::std::vec::Vec<UtxoItem> {
        &self.0
    }
}
impl ::std::convert::From<Utxo> for ::std::vec::Vec<UtxoItem> {
    fn from(value: Utxo) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Utxo> for Utxo {
    fn from(value: &Utxo) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<UtxoItem>> for Utxo {
    fn from(value: ::std::vec::Vec<UtxoItem>) -> Self {
        Self(value)
    }
}
#[doc = "UtxoItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"address\","]
#[doc = "    \"index\","]
#[doc = "    \"transaction\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"address\": {"]
#[doc = "      \"$ref\": \"#/definitions/Address\""]
#[doc = "    },"]
#[doc = "    \"datum\": {"]
#[doc = "      \"$ref\": \"#/definitions/Datum\""]
#[doc = "    },"]
#[doc = "    \"datumHash\": {"]
#[doc = "      \"$ref\": \"#/definitions/Digest<Blake2b, 256>\""]
#[doc = "    },"]
#[doc = "    \"index\": {"]
#[doc = "      \"$ref\": \"#/definitions/UInt32\""]
#[doc = "    },"]
#[doc = "    \"script\": {"]
#[doc = "      \"$ref\": \"#/definitions/Script\""]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"id\": {"]
#[doc = "          \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"$ref\": \"#/definitions/Value\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct UtxoItem {
    pub address: Address,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datum: ::std::option::Option<Datum>,
    #[serde(
        rename = "datumHash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub datum_hash: ::std::option::Option<DigestBlake2b256>,
    pub index: UInt32,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub script: ::std::option::Option<Script>,
    pub transaction: UtxoItemTransaction,
    pub value: Value,
}
impl ::std::convert::From<&UtxoItem> for UtxoItem {
    fn from(value: &UtxoItem) -> Self {
        value.clone()
    }
}
#[doc = "UtxoItemTransaction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/definitions/TransactionId\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct UtxoItemTransaction {
    pub id: TransactionId,
}
impl ::std::convert::From<&UtxoItemTransaction> for UtxoItemTransaction {
    fn from(value: &UtxoItemTransaction) -> Self {
        value.clone()
    }
}
#[doc = "ValidityInterval"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ValidityInterval\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"invalidAfter\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    },"]
#[doc = "    \"invalidBefore\": {"]
#[doc = "      \"$ref\": \"#/definitions/Slot\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValidityInterval {
    #[serde(
        rename = "invalidAfter",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub invalid_after: ::std::option::Option<Slot>,
    #[serde(
        rename = "invalidBefore",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub invalid_before: ::std::option::Option<Slot>,
}
impl ::std::convert::From<&ValidityInterval> for ValidityInterval {
    fn from(value: &ValidityInterval) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ValidityInterval {
    fn default() -> Self {
        Self {
            invalid_after: Default::default(),
            invalid_before: Default::default(),
        }
    }
}
#[doc = "Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Value\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ada\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ada\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"lovelace\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"lovelace\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"additionalProperties\": {"]
#[doc = "      \"$ref\": \"#/definitions/AssetQuantity\""]
#[doc = "    },"]
#[doc = "    \"propertyNames\": {"]
#[doc = "      \"pattern\": \"^[0-9a-f]{0,64}$\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"pattern\": \"^[0-9a-f]{56}$\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Value {
    pub ada: ValueAda,
    #[serde(flatten)]
    pub extra: ::std::collections::HashMap<
        ValueExtraKey,
        ::std::collections::HashMap<ValueExtraValueKey, AssetQuantity>,
    >,
}
impl ::std::convert::From<&Value> for Value {
    fn from(value: &Value) -> Self {
        value.clone()
    }
}
#[doc = "ValueAda"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"lovelace\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"lovelace\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValueAda {
    pub lovelace: i64,
}
impl ::std::convert::From<&ValueAda> for ValueAda {
    fn from(value: &ValueAda) -> Self {
        value.clone()
    }
}
#[doc = "ValueAdaOnly"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Value<AdaOnly>\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ada\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ada\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"lovelace\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"lovelace\": {"]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValueAdaOnly {
    pub ada: ValueAdaOnlyAda,
}
impl ::std::convert::From<&ValueAdaOnly> for ValueAdaOnly {
    fn from(value: &ValueAdaOnly) -> Self {
        value.clone()
    }
}
#[doc = "ValueAdaOnlyAda"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"lovelace\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"lovelace\": {"]
#[doc = "      \"type\": \"integer\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValueAdaOnlyAda {
    pub lovelace: i64,
}
impl ::std::convert::From<&ValueAdaOnlyAda> for ValueAdaOnlyAda {
    fn from(value: &ValueAdaOnlyAda) -> Self {
        value.clone()
    }
}
#[doc = "ValueDelta"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Value<Delta>\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"ada\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"ada\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"lovelace\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"lovelace\": {"]
#[doc = "          \"description\": \"An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).\","]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"maximum\": 9.223372036854776e18,"]
#[doc = "          \"minimum\": -9.223372036854776e18"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValueDelta {
    pub ada: ValueDeltaAda,
}
impl ::std::convert::From<&ValueDelta> for ValueDelta {
    fn from(value: &ValueDelta) -> Self {
        value.clone()
    }
}
#[doc = "ValueDeltaAda"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"lovelace\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"lovelace\": {"]
#[doc = "      \"description\": \"An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada).\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"maximum\": 9.223372036854776e18,"]
#[doc = "      \"minimum\": -9.223372036854776e18"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ValueDeltaAda {
    #[doc = "An amount, possibly negative, in Lovelace (1e6 Lovelace = 1 Ada)."]
    pub lovelace: i64,
}
impl ::std::convert::From<&ValueDeltaAda> for ValueDeltaAda {
    fn from(value: &ValueDeltaAda) -> Self {
        value.clone()
    }
}
#[doc = "ValueExtraKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]{56}$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ValueExtraKey(::std::string::String);
impl ::std::ops::Deref for ValueExtraKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ValueExtraKey> for ::std::string::String {
    fn from(value: ValueExtraKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ValueExtraKey> for ValueExtraKey {
    fn from(value: &ValueExtraKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ValueExtraKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]{56}$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]{56}$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ValueExtraKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ValueExtraKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ValueExtraKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ValueExtraKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "ValueExtraValueKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[0-9a-f]{0,64}$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ValueExtraValueKey(::std::string::String);
impl ::std::ops::Deref for ValueExtraValueKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ValueExtraValueKey> for ::std::string::String {
    fn from(value: ValueExtraValueKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ValueExtraValueKey> for ValueExtraValueKey {
    fn from(value: &ValueExtraValueKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ValueExtraValueKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[0-9a-f]{0,64}$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^[0-9a-f]{0,64}$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ValueExtraValueKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ValueExtraValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ValueExtraValueKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ValueExtraValueKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "An Ed25519 verification key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"VerificationKey\","]
#[doc = "  \"description\": \"An Ed25519 verification key.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"maxLength\": 64,"]
#[doc = "  \"minLength\": 64,"]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct VerificationKey(::std::string::String);
impl ::std::ops::Deref for VerificationKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<VerificationKey> for ::std::string::String {
    fn from(value: VerificationKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&VerificationKey> for VerificationKey {
    fn from(value: &VerificationKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for VerificationKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() > 64usize {
            return Err("longer than 64 characters".into());
        }
        if value.len() < 64usize {
            return Err("shorter than 64 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for VerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VerificationKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for VerificationKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "VotingPeriod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"VotingPeriod\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"voteForThisEpoch\","]
#[doc = "    \"voteForNextEpoch\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VotingPeriod {
    #[serde(rename = "voteForThisEpoch")]
    VoteForThisEpoch,
    #[serde(rename = "voteForNextEpoch")]
    VoteForNextEpoch,
}
impl ::std::convert::From<&Self> for VotingPeriod {
    fn from(value: &VotingPeriod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VotingPeriod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::VoteForThisEpoch => write!(f, "voteForThisEpoch"),
            Self::VoteForNextEpoch => write!(f, "voteForNextEpoch"),
        }
    }
}
impl ::std::str::FromStr for VotingPeriod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "voteForThisEpoch" => Ok(Self::VoteForThisEpoch),
            "voteForNextEpoch" => Ok(Self::VoteForNextEpoch),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VotingPeriod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VotingPeriod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VotingPeriod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "VrfOutput"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"VrfOutput\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct VrfOutput(pub ::std::string::String);
impl ::std::ops::Deref for VrfOutput {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<VrfOutput> for ::std::string::String {
    fn from(value: VrfOutput) -> Self {
        value.0
    }
}
impl ::std::convert::From<&VrfOutput> for VrfOutput {
    fn from(value: &VrfOutput) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for VrfOutput {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for VrfOutput {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for VrfOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "VrfProof"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"VrfProof\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"contentEncoding\": \"base16\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct VrfProof(pub ::std::string::String);
impl ::std::ops::Deref for VrfProof {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<VrfProof> for ::std::string::String {
    fn from(value: VrfProof) -> Self {
        value.0
    }
}
impl ::std::convert::From<&VrfProof> for VrfProof {
    fn from(value: &VrfProof) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for VrfProof {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for VrfProof {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for VrfProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Withdrawals"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Withdrawals\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": {"]
#[doc = "    \"$ref\": \"#/definitions/Value<AdaOnly>\""]
#[doc = "  },"]
#[doc = "  \"propertyNames\": {"]
#[doc = "    \"pattern\": \"^stake(_test)?1[0-9a-z]+$\""]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Withdrawals(pub ::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly>);
impl ::std::ops::Deref for Withdrawals {
    type Target = ::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly>;
    fn deref(&self) -> &::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly> {
        &self.0
    }
}
impl ::std::convert::From<Withdrawals>
    for ::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly>
{
    fn from(value: Withdrawals) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Withdrawals> for Withdrawals {
    fn from(value: &Withdrawals) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly>>
    for Withdrawals
{
    fn from(value: ::std::collections::HashMap<WithdrawalsKey, ValueAdaOnly>) -> Self {
        Self(value)
    }
}
#[doc = "WithdrawalsKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^stake(_test)?1[0-9a-z]+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WithdrawalsKey(::std::string::String);
impl ::std::ops::Deref for WithdrawalsKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WithdrawalsKey> for ::std::string::String {
    fn from(value: WithdrawalsKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WithdrawalsKey> for WithdrawalsKey {
    fn from(value: &WithdrawalsKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WithdrawalsKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^stake(_test)?1[0-9a-z]+$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^stake(_test)?1[0-9a-z]+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WithdrawalsKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WithdrawalsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WithdrawalsKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WithdrawalsKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
