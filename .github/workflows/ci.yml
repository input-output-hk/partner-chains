name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - master
  workflow_dispatch:
    inputs:
      sha:
        description: 'Commit SHA to build'
        required: true
        type: string
      wipe_cache:
        description: 'Wipe /tmp/rust-cache* before build'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: "eu-central-1"
  SSH_AUTH_SOCK: /tmp/ssh_agent.sock

permissions:
  id-token: write
  contents: write
  packages: write

jobs:

### Pre merge workflow ###############################################################################################################

  build-linux-x86_64-pre-merge:
    runs-on: nixos
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    steps:
      - name: Clean runner environment
        run: rm -rf ./*
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Restore Rust cache from host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Restoring Rust cache from host ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          if [ -d "$CACHE" ] && [ -f "$CACHE/.ready" ]; then
            echo "Ready cache found: $CACHE"
            mkdir -p ~/.cargo/git ~/.cargo/registry
            nix shell nixpkgs#rsync -c bash -c "
              rsync -a $CACHE/cargo-git/ ~/.cargo/git/
              rsync -a $CACHE/cargo-registry/ ~/.cargo/registry/
            "
          else
            echo "No matching cache ($CACHE); skipping restore."
          fi

      - name: Validate Rust cache
        run: |
          set -euo pipefail
          CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"

          echo "--- Cache preflight ---"
          # Compute cache key again (same as restore/save)
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            echo "Cargo.lock missing; skipping manifest check."
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"
          [[ -d "$CACHE" ]] || { echo "No shared cache present for key: $CACHE"; exit 0; }

          MAN="$CACHE/.manifest"; READY="$CACHE/.ready"
          WANT="$(printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA")"
          REASONS=()

          echo "[1/2] Checking manifest/ready..."
          if [[ ! -f "$READY" || ! -f "$MAN" ]]; then
            echo "manifest/ready missing"
            REASONS+=("manifest/ready missing")
          else
            HAVE="$(head -n 2 "$MAN" || true)"
            if [[ "$WANT" != "$HAVE" ]]; then
              echo "manifest mismatch"
              REASONS+=("manifest mismatch")
            fi
          fi

          echo "[2/2] cargo fetch --locked..."
          if ! nix develop -c bash -lc "cargo fetch --locked -q" 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2); then
            echo "cargo fetch failed â†’ clearing registry/src + git/checkouts, then re-fetching"
            rm -rf "$CARGO_HOME"/registry/src/* "$CARGO_HOME"/git/checkouts/* || true
            nix develop -c cargo fetch --locked 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2)
            REASONS+=("re-fetched dependencies")
          fi

          echo "--- Preflight summary: ${REASONS[*]:-OK} ---"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Acquire AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ECR_REGISTRY_SECRET }}

      - name: Enable sccache (RUSTC_WRAPPER)
        run: |
          set -e
          if nix develop -c bash -lc 'command -v sccache' >/dev/null 2>&1; then
            echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_DIR=/tmp/sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_CACHE_SIZE=30G" >> "$GITHUB_ENV"
            echo "CARGO_INCREMENTAL=0" >> "$GITHUB_ENV"
            mkdir -p /tmp/sccache
            nix develop -c sccache --stop-server || true
            nix develop -c sccache --start-server || true
            nix develop -c sccache --version || true
          else
            echo "sccache not in devshell; skipping wrapper."
          fi

      - name: Formatting
        run: nix develop -c bash -c "cargo fmt --check"

      - name: Build (Stable)
        run: nix develop -c bash -c "cargo build --locked --release"

      - name: sccache stats
        if: always()
        run: nix develop -c sccache -s || true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Save Rust cache to host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Saving Rust cache to host cache ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          mkdir -p "$CACHE"
          nix shell nixpkgs#rsync -c bash -c "
            rsync -a --delete ~/.cargo/git/      $CACHE/cargo-git/
            rsync -a --delete ~/.cargo/registry/ $CACHE/cargo-registry/
          "
          echo "--- Verifying cache contents ($CACHE) ---"
          ls -la "$CACHE" || true
          ls -la "$CACHE"/cargo-git "$CACHE"/cargo-registry || true

          printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA" > "$CACHE/.manifest"
          touch "$CACHE/.ready"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Build chain specs
        run: |
          nix develop -c bash -c '
            source ./dev/envs/devnet/.envrc
            target/release/partner-chains-demo-node build-spec --chain local --disable-default-bootnode > devnet_chain_spec.json

            source ./dev/envs/ci-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > ci_preview_chain_spec.json

            source ./dev/envs/staging-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > staging_preview_chain_spec.json
          '
          
      - name: Build and push docker image
        run: |
          cp target/release/partner-chains-demo-node .
          nix develop -c bash -c "patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 partner-chains-demo-node"
          docker build -f dev/ci/Dockerfile -t ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ github.sha }} .
          docker push ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ github.sha }}

      - name: Upload partner-chains-node artifact
        uses: actions/upload-artifact@v4
        with:
          name: partner-chains-node-artifact
          path: ./partner-chains-demo-node

      - name: Upload chain spec artifacts
        uses: actions/upload-artifact@v4
        with:
          name: chain-specs
          path: |
            ./devnet_chain_spec.json
            ./ci_preview_chain_spec.json
            ./staging_preview_chain_spec.json

  build-nightly-pre-merge:
    runs-on: nixos
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    steps:
      - name: Clean runner environment
        run: rm -rf ./*
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Restore Rust cache from host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Restoring Rust cache from host ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          if [ -d "$CACHE" ] && [ -f "$CACHE/.ready" ]; then
            echo "Ready cache found: $CACHE"
            mkdir -p ~/.cargo/git ~/.cargo/registry
            nix shell nixpkgs#rsync -c bash -c "
              rsync -a $CACHE/cargo-git/ ~/.cargo/git/
              rsync -a $CACHE/cargo-registry/ ~/.cargo/registry/
            "
          else
            echo "No matching cache ($CACHE); skipping restore."
          fi

      - name: Validate Rust cache
        run: |
          set -euo pipefail
          CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"

          echo "--- Cache preflight ---"
          # Compute cache key again (same as restore/save)
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            echo "Cargo.lock missing; skipping manifest check."
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"
          [[ -d "$CACHE" ]] || { echo "No shared cache present for key: $CACHE"; exit 0; }

          MAN="$CACHE/.manifest"; READY="$CACHE/.ready"
          WANT="$(printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA")"
          REASONS=()

          echo "[1/2] Checking manifest/ready..."
          if [[ ! -f "$READY" || ! -f "$MAN" ]]; then
            echo "manifest/ready missing"
            REASONS+=("manifest/ready missing")
          else
            HAVE="$(head -n 2 "$MAN" || true)"
            if [[ "$WANT" != "$HAVE" ]]; then
              echo "manifest mismatch"
              REASONS+=("manifest mismatch")
            fi
          fi

          echo "[2/2] cargo fetch --locked..."
          if ! nix develop -c bash -lc "cargo fetch --locked -q" 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2); then
            echo "cargo fetch failed â†’ clearing registry/src + git/checkouts, then re-fetching"
            rm -rf "$CARGO_HOME"/registry/src/* "$CARGO_HOME"/git/checkouts/* || true
            nix develop -c cargo fetch --locked 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2)
            REASONS+=("re-fetched dependencies")
          fi

          echo "--- Preflight summary: ${REASONS[*]:-OK} ---"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Enable sccache (RUSTC_WRAPPER)
        run: |
          set -e
          if nix develop -c bash -lc 'command -v sccache' >/dev/null 2>&1; then
            echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_DIR=/tmp/sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_CACHE_SIZE=30G" >> "$GITHUB_ENV"
            echo "CARGO_INCREMENTAL=0" >> "$GITHUB_ENV"
            mkdir -p /tmp/sccache
            nix develop -c sccache --stop-server || true
            nix develop -c sccache --start-server || true
            nix develop -c sccache --version || true
          else
            echo "sccache not in devshell; skipping wrapper."
          fi

      - name: Build (Nightly)
        run: nix develop -c bash -c "RUSTUP_TOOLCHAIN=nightly cargo build --locked"

      - name: Test (Nightly)
        run: nix develop -c bash -c "RUSTUP_TOOLCHAIN=nightly cargo test --locked --all-features"

      - name: Lint (Nightly)
        run: nix develop -c bash -c "RUSTUP_TOOLCHAIN=nightly RUSTFLAGS=-Dwarnings cargo clippy --locked --all-features"

      - name: sccache stats
        if: always()
        run: nix develop -c sccache -s || true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Save Rust cache to host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Saving Rust cache to host cache ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          mkdir -p "$CACHE"
          nix shell nixpkgs#rsync -c bash -c "
            rsync -a --delete ~/.cargo/git/      $CACHE/cargo-git/
            rsync -a --delete ~/.cargo/registry/ $CACHE/cargo-registry/
          "
          echo "--- Verifying cache contents ($CACHE) ---"
          ls -la "$CACHE" || true
          ls -la "$CACHE"/cargo-git "$CACHE"/cargo-registry || true

          printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA" > "$CACHE/.manifest"
          touch "$CACHE/.ready"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

  local-env:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    needs: build-linux-x86_64-pre-merge
    runs-on: ubuntu-latest
    strategy:
      matrix:
        markers: [smoke, rpc, reserve, governed_map, delegator_rewards, ariadne, wizards]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Deploy and test against local environment
        uses: ./.github/actions/tests/local-environment-tests
        with:
          tag: CI
          image: ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ github.sha }}
          sha: ${{ github.sha }}
          markers: ${{ matrix.markers }}
        env:
          SUBSTRATE_REPO_SSH_KEY: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          TEST_ENVIRONMENT: local

  documentation-tests:
    needs: build-linux-x86_64-pre-merge
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Run Documentation Tests
        uses: ./.github/actions/tests/doc-tests

  deploy-rustdoc-pre-merge:
    needs: build-nightly-pre-merge
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Deploy Rust Docs
        uses: ./.github/actions/deploy/deploy-rustdoc
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  upload-chain-specs-pre-merge:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == false
    needs: build-linux-x86_64-pre-merge
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Upload chain spec artifacts to Kubernetes
        uses: ./.github/actions/deploy/upload-chain-specs
        with:
          sha: ${{ github.sha }}
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  pre-merge-checks-complete:
    if: ${{ always() && github.event_name == 'pull_request' && github.event.pull_request.merged == false }}
    needs: [
      build-linux-x86_64-pre-merge,
      build-nightly-pre-merge,
      local-env,
      upload-chain-specs-pre-merge,
      documentation-tests,
      deploy-rustdoc-pre-merge
    ]
    runs-on: ubuntu-latest
    steps:
      - name: Check if any needed job failed
        run: |
          if [[ "${{ needs.build-linux-x86_64-pre-merge.result }}" != "success" ||
                "${{ needs.build-nightly-pre-merge.result }}" != "success" ||
                "${{ needs.local-env.result }}" != "success" ||
                "${{ needs.upload-chain-specs-pre-merge.result }}" != "success" ||
                "${{ needs.documentation-tests.result }}" != "success" ||
                "${{ needs.deploy-rustdoc-pre-merge.result }}" != "success" ]]; then
            echo "One or more needed jobs failed."
            exit 1
          else
            echo "All needed jobs passed."
          fi

### Post merge workflow ###############################################################################################################

  build-linux-x86_64-post-merge:
    runs-on: nixos
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    outputs:
      sha: ${{ steps.get_sha.outputs.sha }}
    steps:
      - name: Clean runner environment
        run: rm -rf ./*
      - name: Checkout master branch code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master
          clean: true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Restore Rust cache from host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Restoring Rust cache from host ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          if [ -d "$CACHE" ] && [ -f "$CACHE/.ready" ]; then
            echo "Ready cache found: $CACHE"
            mkdir -p ~/.cargo/git ~/.cargo/registry
            nix shell nixpkgs#rsync -c bash -c "
              rsync -a $CACHE/cargo-git/ ~/.cargo/git/
              rsync -a $CACHE/cargo-registry/ ~/.cargo/registry/
            "
          else
            echo "No matching cache ($CACHE); skipping restore."
          fi

      - name: Validate Rust cache
        run: |
          set -euo pipefail
          CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"

          echo "--- Cache preflight ---"
          # Compute cache key again
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            echo "Cargo.lock missing; skipping manifest check."
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"
          [[ -d "$CACHE" ]] || { echo "No shared cache present for key: $CACHE"; exit 0; }

          MAN="$CACHE/.manifest"; READY="$CACHE/.ready"
          WANT="$(printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA")"
          REASONS=()

          echo "[1/2] Checking manifest/ready..."
          if [[ ! -f "$READY" || ! -f "$MAN" ]]; then
            echo "manifest/ready missing"
            REASONS+=("manifest/ready missing")
          else
            HAVE="$(head -n 2 "$MAN" || true)"
            if [[ "$WANT" != "$HAVE" ]]; then
              echo "manifest mismatch"
              REASONS+=("manifest mismatch")
            fi
          fi

          echo "[2/2] cargo fetch --locked..."
          if ! nix develop -c bash -lc "cargo fetch --locked -q" 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2); then
            echo "cargo fetch failed â†’ clearing registry/src + git/checkouts, then re-fetching"
            rm -rf "$CARGO_HOME"/registry/src/* "$CARGO_HOME"/git/checkouts/* || true
            nix develop -c cargo fetch --locked 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2)
            REASONS+=("re-fetched dependencies")
          fi

          echo "--- Preflight summary: ${REASONS[*]:-OK} ---"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Get current commit SHA
        id: get_sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Acquire AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ECR_REGISTRY_SECRET }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable sccache (RUSTC_WRAPPER)
        run: |
          set -e
          if nix develop -c bash -lc 'command -v sccache' >/dev/null 2>&1; then
            echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_DIR=/tmp/sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_CACHE_SIZE=30G" >> "$GITHUB_ENV"
            echo "CARGO_INCREMENTAL=0" >> "$GITHUB_ENV"
            mkdir -p /tmp/sccache
            nix develop -c sccache --stop-server || true
            nix develop -c sccache --start-server || true
            nix develop -c sccache --version || true
          else
            echo "sccache not in devshell; skipping wrapper."
          fi

      - name: Build
        run: nix develop -c bash -c "cargo build --locked --profile=release"

      - name: sccache stats
        if: always()
        run: nix develop -c sccache -s || true

      - name: Build chain specs
        run: |
          nix develop -c bash -c '
            source ./dev/envs/devnet/.envrc
            target/release/partner-chains-demo-node build-spec --chain local --disable-default-bootnode > devnet_chain_spec.json

            source ./dev/envs/ci-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > ci_preview_chain_spec.json

            source ./dev/envs/staging-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > staging_preview_chain_spec.json
          '

      - name: Build and push docker image
        run: |
          cp target/release/partner-chains-demo-node .
          nix develop -c bash -c "patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 partner-chains-demo-node"
          docker build -f dev/ci/Dockerfile -t ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ steps.get_sha.outputs.sha }} .
          docker tag ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ steps.get_sha.outputs.sha }} ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:latest
          docker tag ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ steps.get_sha.outputs.sha }} ghcr.io/${{ github.repository }}/partner-chains-node-unstable:latest
          docker push ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ steps.get_sha.outputs.sha }}
          docker push ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:latest
          docker push ghcr.io/${{ github.repository }}/partner-chains-node-unstable:latest

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Save Rust cache to host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Saving Rust cache to host cache ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          mkdir -p "$CACHE"
          nix shell nixpkgs#rsync -c bash -c "
            rsync -a --delete ~/.cargo/git/      $CACHE/cargo-git/
            rsync -a --delete ~/.cargo/registry/ $CACHE/cargo-registry/
          "
          echo "--- Verifying cache contents ($CACHE) ---"
          ls -la "$CACHE" || true
          ls -la "$CACHE"/cargo-git "$CACHE"/cargo-registry || true

          printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA" > "$CACHE/.manifest"
          touch "$CACHE/.ready"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Rename artifact
        run: |
          cp ./partner-chains-demo-node partner-chains-node-${{ steps.get_sha.outputs.sha }}-x86_64-linux
          chmod +x ./partner-chains-node-${{ steps.get_sha.outputs.sha }}-x86_64-linux
          cp ./partner-chains-node-${{ steps.get_sha.outputs.sha }}-x86_64-linux partner-chains-node-binary

      #- name: Copy to binary-host
      #  uses: ./.github/actions/artifacts/copy-to-binary-host
      #  with:
      #    sha: ${{ steps.get_sha.outputs.sha }}
      #    env: "ci-preview"
      #  env:
      #    AWS_REGION: "eu-central-1"
      #    AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
      #    kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
      #    K8S_SERVER: ${{ secrets.K8S_SERVER }}
      #    K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

      - name: Upload partner-chains-node artifact
        uses: actions/upload-artifact@v4
        with:
          name: partner-chains-node-linux-artifact
          path: partner-chains-node-${{ steps.get_sha.outputs.sha }}-x86_64-linux

      - name: Upload chain spec artifacts
        uses: actions/upload-artifact@v4
        with:
          name: chain-specs
          path: |
            devnet_chain_spec.json
            ci_preview_chain_spec.json
            staging_preview_chain_spec.json

  upload-to-s3:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs:
      - build-linux-x86_64-post-merge
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Checkout master
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master
      - name: Get current commit SHA
        id: get_sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
      - name: Upload Artifacts to S3
        uses: ./.github/actions/artifacts/upload-to-s3
        with:
          sha: ${{ steps.get_sha.outputs.sha }}
          bucket-name: ${{ secrets.AWS_CD_ARTIFACT_S3_BUCKET }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_S3_ROLE_ARN_SECRET }}

  upload-chain-specs:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: build-linux-x86_64-post-merge
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master
      - name: Upload chain spec artifacts to Kubernetes
        uses: ./.github/actions/deploy/upload-chain-specs
        with:
          sha: ${{ needs.build-linux-x86_64-post-merge.outputs.sha }}
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  deploy-ci-preview:
    needs:
      - build-linux-x86_64-post-merge
    permissions:
      id-token: write
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master
      - name: Deploy ci-preview
        uses: ./.github/actions/deploy/deploy-ci-preview
        with:
          image:  ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ needs.build-linux-x86_64-post-merge.outputs.sha }}
          sha: ${{ needs.build-linux-x86_64-post-merge.outputs.sha }}
          no-wipe: true
        env:
          AWS_REGION: "eu-central-1"
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  ci-preview-tests-post-merge:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: deploy-ci-preview
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master
      - name: Setup tests
        uses: ./.github/actions/tests/setup-python
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Test against ci-preview
        uses: ./.github/actions/tests/run-e2e-tests
        with:
          env: ci
          decrypt: true
          blockchain: substrate

  post-merge-actions-complete:
    if: ${{ always() && (github.event_name == 'pull_request' && github.event.pull_request.merged == true) }}
    needs:
      [
        build-linux-x86_64-post-merge,
        upload-chain-specs,
        ci-preview-tests-post-merge,
        deploy-ci-preview,
        upload-to-s3,
      ]
    runs-on: ubuntu-latest
    steps:
      - name: Check if any needed job failed
        run: |
          if [[ "${{ needs.build-linux-x86_64-post-merge.result }}" != "success" ||
                "${{ needs.upload-chain-specs.result }}" != "success" ||
                "${{ needs.ci-preview-tests-post-merge.result }}" != "success" ||
                "${{ needs.deploy-ci-preview.result }}" != "success" ||
                "${{ needs.upload-to-s3.result }}" != "success" ]]; then
            echo "One or more needed jobs failed."
            exit 1
          else
            echo "All needed jobs passed."
          fi

### Workflow dispatch flow ###############################################################################################################

  build-linux-x86_64-workflow-dispatch:
    runs-on: nixos
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Clean runner environment
        run: rm -rf ./*
      - name: Checkout target code to build
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.sha }}
          clean: true

      - name: (Optional) Wipe shared Rust caches
        if: github.event_name == 'workflow_dispatch' && inputs.wipe_cache == true
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do sleep 2; done
          rm -rf /tmp/rust-cache*  # wipe all keyed caches
          rmdir /tmp/rust-cache.lock || true || true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Restore Rust cache from host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Restoring Rust cache from host ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          if [ -d "$CACHE" ] && [ -f "$CACHE/.ready" ]; then
            echo "Ready cache found: $CACHE"
            mkdir -p ~/.cargo/git ~/.cargo/registry
            nix shell nixpkgs#rsync -c bash -c "
              rsync -a $CACHE/cargo-git/ ~/.cargo/git/
              rsync -a $CACHE/cargo-registry/ ~/.cargo/registry/
            "
          else
            echo "No matching cache ($CACHE); skipping restore."
          fi

      - name: Validate Rust cache
        run: |
          set -euo pipefail
          CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"

          echo "--- Cache preflight ---"
          # Compute cache key again
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            echo "Cargo.lock missing; skipping manifest check."
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"
          [[ -d "$CACHE" ]] || { echo "No shared cache present for key: $CACHE"; exit 0; }

          MAN="$CACHE/.manifest"; READY="$CACHE/.ready"
          WANT="$(printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA")"
          REASONS=()

          echo "[1/2] Checking manifest/ready..."
          if [[ ! -f "$READY" || ! -f "$MAN" ]]; then
            echo "manifest/ready missing"
            REASONS+=("manifest/ready missing")
          else
            HAVE="$(head -n 2 "$MAN" || true)"
            if [[ "$WANT" != "$HAVE" ]]; then
              echo "manifest mismatch"
              REASONS+=("manifest mismatch")
            fi
          fi

          echo "[2/2] cargo fetch --locked..."
          if ! nix develop -c bash -lc "cargo fetch --locked -q" 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2); then
            echo "cargo fetch failed â†’ clearing registry/src + git/checkouts, then re-fetching"
            rm -rf "$CARGO_HOME"/registry/src/* "$CARGO_HOME"/git/checkouts/* || true
            nix develop -c cargo fetch --locked 2> >(grep -v -E 'untrusted substituter|trusted-public-keys' >&2)
            REASONS+=("re-fetched dependencies")
          fi

          echo "--- Preflight summary: ${REASONS[*]:-OK} ---"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      - name: Acquire AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ECR_REGISTRY_SECRET }}

      - name: Enable sccache (RUSTC_WRAPPER)
        run: |
          set -e
          if nix develop -c bash -lc 'command -v sccache' >/dev/null 2>&1; then
            echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_DIR=/tmp/sccache" >> "$GITHUB_ENV"
            echo "SCCACHE_CACHE_SIZE=30G" >> "$GITHUB_ENV"
            echo "CARGO_INCREMENTAL=0" >> "$GITHUB_ENV"
            mkdir -p /tmp/sccache
            nix develop -c sccache --stop-server || true
            nix develop -c sccache --start-server || true
            nix develop -c sccache --version || true
          else
            echo "sccache not in devshell; skipping wrapper."
          fi

      - name: Formatting
        run: nix develop -c bash -c "cargo fmt --check"

      - name: Build
        run: nix develop -c bash -c "cargo build --locked --release"

      - name: Test
        run: nix develop -c bash -c "cargo test --locked --release --all-features"

      - name: Lint
        run: nix develop -c bash -c "RUSTFLAGS=-Dwarnings cargo clippy --locked --release --all-features"

      - name: sccache stats
        if: always()
        run: nix develop -c sccache -s || true

      - name: Acquire cache lock
        run: |
          until mkdir /tmp/rust-cache.lock 2>/dev/null; do
            sleep 5
          done

      - name: Save Rust cache to host (keyed by toolchain+lock)
        run: |
          set -e
          echo "--- Saving Rust cache to host cache ---"
          # Compute cache key
          RUSTC_FULL="$({ nix develop -c rustc -V; } 2>/dev/null || { rustc -V; } 2>/dev/null || true)"
          if [[ -n "${RUSTC_FULL:-}" ]]; then
            RUSTC_VER="${RUSTC_FULL#rustc }"; RUSTC_VER="${RUSTC_VER%% *}"
          else
            RUSTC_VER="unknown"
          fi
          if [[ -f Cargo.lock ]]; then
            LOCK_LINE="$(sha256sum Cargo.lock)"
            LOCK_SHA="${LOCK_LINE%% *}"
          else
            LOCK_SHA="nolock"
          fi
          CACHE="/tmp/rust-cache-${RUSTC_VER}-${LOCK_SHA}"

          mkdir -p "$CACHE"
          nix shell nixpkgs#rsync -c bash -c "
            rsync -a --delete ~/.cargo/git/      $CACHE/cargo-git/
            rsync -a --delete ~/.cargo/registry/ $CACHE/cargo-registry/
          "
          echo "--- Verifying cache contents ($CACHE) ---"
          ls -la "$CACHE" || true
          ls -la "$CACHE"/cargo-git "$CACHE"/cargo-registry || true

          printf '%s\n%s\n' "$RUSTC_VER" "$LOCK_SHA" > "$CACHE/.manifest"
          touch "$CACHE/.ready"

      - name: Release cache lock
        if: always()
        run: rmdir /tmp/rust-cache.lock || true

      #- name: Run cargo-deny to check licenses
      #  uses: EmbarkStudios/cargo-deny-action@v1
      #  with:
      #    command: check licenses

      - name: Build chain specs
        run: |
          nix develop -c bash -c '
            source ./dev/envs/devnet/.envrc
            target/release/partner-chains-demo-node build-spec --chain local --disable-default-bootnode > devnet_chain_spec.json

            source ./dev/envs/ci-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > ci_preview_chain_spec.json

            source ./dev/envs/staging-preview/.envrc
            target/release/partner-chains-demo-node build-spec --chain staging --disable-default-bootnode > staging_preview_chain_spec.json
          '

      - name: Build and push docker image
        run: |
          cp target/release/partner-chains-demo-node .
          nix develop -c bash -c "patchelf --set-interpreter /lib64/ld-linux-x86-64.so.2 partner-chains-demo-node"
          docker build -f dev/ci/Dockerfile -t ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ inputs.sha }} .
          docker push ${{ secrets.ECR_REGISTRY_SECRET }}/partner-chains-node:${{ inputs.sha }}

      - name: Rename and prepare artifact for workflow dispatch
        run: |
          ARTIFACT_NAME="partner-chains-node-${{ inputs.sha }}-x86_64-linux"
          cp ./partner-chains-demo-node "$ARTIFACT_NAME"
          chmod +x "$ARTIFACT_NAME"
        shell: bash

      - name: Upload partner-chains-node artifact
        uses: actions/upload-artifact@v4
        with:
          name: partner-chains-node-linux-artifact
          path: partner-chains-node-${{ inputs.sha }}-x86_64-linux

      - name: Upload chain spec artifacts
        uses: actions/upload-artifact@v4
        with:
          name: chain-specs
          path: |
            devnet_chain_spec.json
            ci_preview_chain_spec.json
            staging_preview_chain_spec.json

  upload-to-s3-workflow-dispatch:
    if: github.event_name == 'workflow_dispatch'
    needs:
      - build-linux-x86_64-workflow-dispatch
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
    steps:
      - name: Checkout specific SHA
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.sha }}
      - name: Upload Artifacts to S3
        uses: ./.github/actions/artifacts/upload-to-s3
        with:
          sha: ${{ inputs.sha }}
          bucket-name: ${{ secrets.AWS_CD_ARTIFACT_S3_BUCKET }}
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_S3_ROLE_ARN_SECRET }}

  upload-chain-specs-workflow-dispatch:
    if: github.event_name == 'workflow_dispatch'
    needs: build-linux-x86_64-workflow-dispatch
    runs-on: ubuntu-latest
    steps:
      - name: Checkout specific SHA
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.sha }}
      - name: Upload chain spec artifacts to Kubernetes
        uses: ./.github/actions/deploy/upload-chain-specs
        with:
          sha: ${{ inputs.sha }}
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  workflow-dispatch-flow-complete:
    if: ${{ always() && github.event_name == 'workflow_dispatch' }}
    needs: [build-linux-x86_64-workflow-dispatch, upload-to-s3-workflow-dispatch, upload-chain-specs-workflow-dispatch]
    runs-on: ubuntu-latest
    steps:
      - name: Check if any needed job failed
        run: |
          if [[ "${{ needs.build-linux-x86_64-workflow-dispatch.result }}" != "success" ||
                "${{ needs.upload-to-s3-workflow-dispatch.result }}" != "success" ||
                "${{ needs.upload-chain-specs-workflow-dispatch.result }}" != "success" ]]; then
            echo "One or more needed jobs failed."
            exit 1
          else
            echo "All needed jobs passed."
          fi
