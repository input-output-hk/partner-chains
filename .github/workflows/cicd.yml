name: CICD

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - master
  workflow_dispatch:
    inputs:
      run_mode:
        description: "Select run mode: 'ci', 'cd', or 'both'"
        required: true
        type: choice
        options:
          - ci
          - cd
          - both
        default: ci
      sha:
        description: "CD: commit SHA"
        required: false
        type: string
      tag:
        description: "CD: version tag"
        required: false
        type: string
      no-release:
        description: "CD: Deploy only (No Release) "
        required: false
        type: boolean
        default: true

env:
  AWS_REGION: "eu-central-1"
  SSH_AUTH_SOCK: /tmp/ssh_agent.sock
  STAGING_PREVIEW_SERVICES_HOST: staging-preview-services-service.staging-preview.svc.cluster.local
  STAGING_PREVIEW_VALIDATOR_1_HOST: staging-preview-validator-1-service.staging-preview.svc.cluster.local
  STAGING_PREVIEW_VALIDATOR_1_PORT: 9933

permissions:
  id-token: write
  contents: write
  packages: write

jobs:
  validate-inputs:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.set-mode.outputs.mode }}
    steps:
      - name: Validate Inputs
        id: set-mode
        run: |
          run_mode="${{ github.event.inputs.run_mode }}"
          if [[ "$run_mode" != "ci" && "$run_mode" != "cd" && "$run_mode" != "both" ]]; then
            echo "::error::Invalid 'run_mode' value: $run_mode. Must be 'ci', 'cd', or 'both'."
            exit 1
          fi
          if [[ "$run_mode" == "cd" || "$run_mode" == "both" ]]; then
            if [ -z "${{ github.event.inputs.sha }}" ] || [ -z "${{ github.event.inputs.tag }}" ]; then
              echo "::error::'sha' and 'tag' inputs are required when 'run_mode' is 'cd' or 'both'."
              exit 1
            fi
          fi
          echo "mode=$run_mode" >> $GITHUB_OUTPUT

  build:
    runs-on: ubuntu-latest
    needs: validate-inputs
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged != true && github.event.action != 'closed'))
    outputs:
      sha: ${{ steps.get_sha.outputs.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Get current commit SHA
        id: get_sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
      - name: Setup Earthly
        uses: ./.github/earthly-setup
        with:
          ssh_key: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}
          config_tar: ${{ secrets.EARTHLY_TAR }}
      - name: Acquire AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ECR_REGISTRY_SECRET }}
      - name: Build and Artifacts and Push Image
        env:
          EARTHLY_CI: true
          EARTHLY_OUTPUT: true
          EARTHLY_PUSH: true
        run: |
          earthly -P +ci --image=${{ secrets.ECR_REGISTRY_SECRET }}/substrate-node
      - name: Upload partner-chains-cli artifact
        uses: actions/upload-artifact@v4
        with:
          name: partner-chains-cli-artifact
          path: partner-chains-cli-artifact
      - name: Upload partner-chains-node artifact
        uses: actions/upload-artifact@v4
        with:
          name: partner-chains-node-artifact
          path: partner-chains-node-artifact
      - name: Upload chain spec artifacts
        uses: actions/upload-artifact@v4
        with:
          name: chain-specs
          path: |
            ./devnet_chain_spec.json
            ./staging_preview_chain_spec.json
            ./staging_preprod_chain_spec.json

  local-environment-tests:
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == false))
    needs: [validate-inputs, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Deploy and test against local environment
        uses: ./.github/actions/tests/local-environment-tests
        with:
          tag: CI
          image: ${{ secrets.ECR_REGISTRY_SECRET }}/substrate-node:${{ needs.build.outputs.sha }}
          sha: ${{ needs.build.outputs.sha }}
          tests: premerge
        env:
          SUBSTRATE_REPO_SSH_KEY: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}
          EARTHLY_TAR: ${{ secrets.EARTHLY_TAR }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          TEST_ENVIRONMENT: local

  deploy-argocd:
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == false))
    needs: [validate-inputs, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Deploy ArgoCD Node
        uses: ./.github/actions/deploy/argocd/deploy-argocd
        with:
          sha: ${{ needs.build.outputs.sha }}
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  argocd-tests:
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == false))
    needs: [validate-inputs, build, deploy-argocd]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Run Tests
        uses: ./.github/actions/tests/argocd-tests
        with:
          sha: ${{ needs.build.outputs.sha }}
          node-host: sha-${{ needs.build.outputs.sha }}-service.integration-testing.svc.cluster.local
          node-port: 9933
          ssh_key_binary_host: ${{ secrets.SSH_KEY_BINARY_HOST }}
        env:
          AWS_ROLE_ARN_: ${{ secrets.AWS_ROLE_ARN_ }}
          SSH_KEY_BINARY_HOST: ${{ secrets.SSH_KEY_BINARY_HOST }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          JIRA_URL: ${{ secrets.JIRA_URL }}
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  teardown-argocd:
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == false))
    needs: [validate-inputs, build, argocd-tests]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Teardown ArgoCD Environment
        uses: ./.github/actions/deploy/argocd/teardown-argocd
        with:
          sha: ${{ needs.build.outputs.sha }}
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  devshell-tests:
    if: |
      (needs.validate-inputs.outputs.mode == 'ci' || needs.validate-inputs.outputs.mode == 'both') &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged != true && github.event.action != 'closed'))
    needs: [validate-inputs, build]
    strategy:
      matrix:
        os: [nixos, macos]
    runs-on:
      - self-hosted
      - ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Acquire AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_ }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Add signing key for nix
        run: echo "${{ secrets.NIX_SIGNING_KEY }}" > "${{ runner.temp }}/nix-key"
      - name: Run nixci to build/test all outputs
        run: |
          nix run github:srid/nixci -- -v build -- --fallback > /tmp/outputs
      - name: Copy nix scopes to nix cache
        run: |
          nix-store --stdin -q --deriver < /tmp/outputs | nix-store --stdin -qR --include-outputs \
          | nix copy --stdin --to \
          "s3://cache.sc.iog.io?secret-key=${{ runner.temp }}/nix-key&region=$AWS_DEFAULT_REGION" \
          && rm /tmp/outputs

  pre-merge-checks-complete:
    if: |
      needs.validate-inputs.outputs.mode != 'cd' &&
      (github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.pull_request.merged == false))
    needs: [validate-inputs, build, local-environment-tests, deploy-argocd, teardown-argocd, devshell-tests]
    runs-on: ubuntu-latest
    steps:
      - name: Pre Merge Checks Complete
        run: echo "All pre-merge checks have passed. PR is ready to merge."

  upload-chain-specs:
    if: needs.validate-inputs.outputs.mode != 'cd' && github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: [validate-inputs, build]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Upload chain spec artifacts to Kubernetes
        uses: ./.github/actions/deploy/upload-chain-specs
        with:
          sha: ${{ needs.build.outputs.sha }}
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  deploy-rustdoc:
    if: needs.validate-inputs.outputs.mode != 'cd' && github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: [validate-inputs, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      - name: Deploy Rust Docs
        uses: ./.github/actions/deploy/deploy-rustdoc
        with:
          ssh_key: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock

  local-environment-tests-post-merge:
    if: needs.validate-inputs.outputs.mode != 'cd' && github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: [validate-inputs, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.merge_commit_sha || github.sha }}
      - name: Deploy and test against local environment
        uses: ./.github/actions/tests/local-environment-tests
        with:
          tag: CI
          image: ${{ secrets.ECR_REGISTRY_SECRET }}/substrate-node:${{ needs.build.outputs.sha }}
          sha: ${{ needs.build.outputs.sha }}
          tests: postmerge
        env:
          SUBSTRATE_REPO_SSH_KEY: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}
          EARTHLY_TAR: ${{ secrets.EARTHLY_TAR }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          TEST_ENVIRONMENT: local

  post-merge-actions-complete:
    if: needs.validate-inputs.outputs.mode != 'cd' && github.event_name == 'pull_request' && github.event.pull_request.merged == true
    needs: [validate-inputs, deploy-rustdoc, upload-chain-specs, local-environment-tests-post-merge]
    runs-on: ubuntu-latest
    steps:
      - name: Post Merge Actions Complete
        run: echo "All post-merge actions have been successfully completed."

  build-linux:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: validate-inputs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.sha }}
      - name: Build and Upload for Linux
        uses: ./.github/actions/artifacts/build-pc-artifacts
        with:
          tag: ${{ github.event.inputs.tag }}
          os: linux

  build-macos-x86_64:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: validate-inputs
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.sha }}
      - name: Build and Upload for macOS x86_64
        uses: ./.github/actions/artifacts/build-pc-artifacts
        with:
          tag: ${{ github.event.inputs.tag }}
          os: macos-x86_64

  build-macos-arm64:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: validate-inputs
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.sha }}
      - name: Build and Upload for macOS arm64
        uses: ./.github/actions/artifacts/build-pc-artifacts
        with:
          tag: ${{ github.event.inputs.tag }}
          os: macos-arm64

  build-and-publish-ecr:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: [validate-inputs, build-linux]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Build and Publish to ECR
        uses: ./.github/actions/images/build-and-publish-ecr
        with:
          sha: ${{ github.event.inputs.sha }}
          tag: ${{ github.event.inputs.tag }}
        env:
          AWS_REGION: "eu-central-1"
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          SSH_KEY: ${{ secrets.SUBSTRATE_REPO_SSH_KEY }}

  create-draft-release:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch' && github.event.inputs.no-release != 'true'
    permissions:
      id-token: write
      contents: write
    needs: [validate-inputs, build-linux, build-macos-x86_64, build-macos-arm64]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Create Draft Release
        uses: ./.github/actions/release/create-draft-release
        with:
          tag: ${{ github.event.inputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-chain-specs:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: [validate-inputs, build-linux]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Generate Chain Specs
        uses: ./.github/actions/artifacts/generate-chain-specs
        with:
          tag: ${{ github.event.inputs.tag }}

  upload-chain-specs-cd:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: [validate-inputs, generate-chain-specs]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Upload chain spec artifacts to Kubernetes
        uses: ./.github/actions/deploy/upload-chain-specs
        with:
          sha: ${{ github.sha }}
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  deploy-staging-preview:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: write
    needs: [validate-inputs, build-and-publish-ecr, upload-chain-specs-cd]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Deploy staging-preview
        uses: ./.github/actions/deploy/deploy-staging-preview
        with:
          image: ${{ secrets.ECR_REGISTRY_SECRET }}/substrate-node:${{ github.event.inputs.sha }}
          sha: ${{ github.sha }}
        env:
          AWS_REGION: "eu-central-1"
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}

  partner-chain-ready:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    runs-on: eks
    needs: [validate-inputs, deploy-staging-preview]
    outputs:
      deployment_mc_epoch: ${{ steps.mc-epoch.outputs.deployment_mc_epoch }}
    steps:
      - name: Set deployment main chain epoch
        id: mc-epoch
        run: echo "deployment_mc_epoch=$(curl -s http://$STAGING_PREVIEW_SERVICES_HOST:1337/health | jq .currentEpoch)" >> $GITHUB_OUTPUT
        shell: bash
      - name: Check Finalization Status
        run: |
          FINALIZED_NUMBER=$(
              curl -s -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"chain_getFinalizedHead","params":[],"id":"1"}' http://$STAGING_PREVIEW_VALIDATOR_1_HOST:$STAGING_PREVIEW_VALIDATOR_1_PORT |
              jq -r ".result" |
              xargs -I {} curl -s -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","method":"chain_getHeader","params":["{}"],"id":"1"}' http://$STAGING_PREVIEW_VALIDATOR_1_HOST:$STAGING_PREVIEW_VALIDATOR_1_PORT |
              jq -r ".result.number" | xargs printf "%d"
          )
          if [ "$FINALIZED_NUMBER" -gt 0 ]; then
            echo "Blocks are being finalized. Finalized Block Number: $FINALIZED_NUMBER"
          else
            echo "No blocks are being finalized. Finalized Block Number: $FINALIZED_NUMBER"
            exit 1
          fi
        shell: bash

  run-smoke-tests:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, partner-chain-ready]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup tests
        uses: ./.github/actions/tests/setup-python
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Run smoke tests
        uses: ./.github/actions/tests/run-e2e-tests
        with:
          blockchain: substrate
          env: staging
          decrypt: true
          markers: "not active_flow and not passive_flow and (CD or rpc)"

  run-all-tests:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, run-smoke-tests]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup tests
        uses: ./.github/actions/tests/setup-python
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Run all tests (some skipped due to new deployment)
        uses: ./.github/actions/tests/run-e2e-tests
        env:
          DEPLOYMENT_MC_EPOCH: ${{ needs.partner-chain-ready.outputs.deployment_mc_epoch }}
        with:
          blockchain: substrate
          env: staging
          decrypt: true
          markers: "not active_flow and not passive_flow"
          deployment_mc_epoch: $DEPLOYMENT_MC_EPOCH

  wait-for-n1-epoch:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, partner-chain-ready]
    runs-on: eks
    timeout-minutes: 1440
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure kubectl
        uses: ./.github/actions/tests/configure-kubectl
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Set MC epoch to wait for
        id: increment-epoch
        env:
          DEPLOYMENT_MC_EPOCH: ${{ needs.partner-chain-ready.outputs.deployment_mc_epoch }}
        run: |
          echo "Current epoch: $DEPLOYMENT_MC_EPOCH"
          incremented_epoch=$((DEPLOYMENT_MC_EPOCH + 1))
          echo "Incremented epoch: $incremented_epoch"
          echo "mc_epoch_to_wait_for=$incremented_epoch" >> $GITHUB_OUTPUT
      - name: Wait for next MC epoch
        uses: ./.github/actions/tests/wait-for-epoch
        with:
          epoch: ${{ steps.increment-epoch.outputs.mc_epoch_to_wait_for }}
          deployment: kubernetes
          node: staging-preview-validator-1
          environment: staging-preview

  run-all-tests-on-n1-epoch:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, wait-for-n1-epoch]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup tests
        uses: ./.github/actions/tests/setup-python
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Run all tests (some skipped due to new deployment)
        uses: ./.github/actions/tests/run-e2e-tests
        env:
          DEPLOYMENT_MC_EPOCH: ${{ needs.partner-chain-ready.outputs.deployment_mc_epoch }}
        with:
          blockchain: substrate
          env: staging
          decrypt: true
          latest_mc_epoch: true
          markers: "not active_flow and not passive_flow"
          deployment_mc_epoch: $DEPLOYMENT_MC_EPOCH

  wait-for-n2-epoch:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, partner-chain-ready, wait-for-n1-epoch]
    runs-on: eks
    timeout-minutes: 1440
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure kubectl
        uses: ./.github/actions/tests/configure-kubectl
        env:
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Set MC epoch to wait for
        id: increment-epoch
        env:
          DEPLOYMENT_MC_EPOCH: ${{ needs.partner-chain-ready.outputs.deployment_mc_epoch }}
        run: |
          echo "Current epoch: $DEPLOYMENT_MC_EPOCH"
          incremented_epoch=$((DEPLOYMENT_MC_EPOCH + 2))
          echo "Incremented epoch: $incremented_epoch"
          echo "mc_epoch_to_wait_for=$incremented_epoch" >> $GITHUB_OUTPUT
      - name: Wait for next MC epoch
        uses: ./.github/actions/tests/wait-for-epoch
        with:
          epoch: ${{ steps.increment-epoch.outputs.mc_epoch_to_wait_for }}
          deployment: kubernetes
          node: staging-preview-validator-1
          environment: staging-preview

  run-all-tests-on-n2-epoch:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch'
    permissions:
      id-token: write
      contents: read
    needs: [validate-inputs, wait-for-n2-epoch]
    runs-on: eks
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup tests
        uses: ./.github/actions/tests/setup-python
        env:
          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
          K8S_SERVER: ${{ secrets.K8S_SERVER }}
          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
      - name: Run all tests (no skipped tests)
        uses: ./.github/actions/tests/run-e2e-tests
        env:
          DEPLOYMENT_MC_EPOCH: ${{ needs.partner-chain-ready.outputs.deployment_mc_epoch }}
        with:
          blockchain: substrate
          env: staging
          decrypt: true
          latest_mc_epoch: true
          markers: "not active_flow and not passive_flow"
          deployment_mc_epoch: $DEPLOYMENT_MC_EPOCH

  publish:
    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch' && github.event.inputs.no-release != 'true'
    permissions:
      id-token: write
      contents: write
      packages: write
    needs: [validate-inputs, run-all-tests-on-n2-epoch]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Publish Workflow
        run: |
          curl -X POST \
            -H "Authorization: token ${{ secrets.ACTIONS_PAT }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/publish.yml/dispatches \
            -d '{"ref": "main", "inputs": {"sha": "${{ github.sha }}", "tag": "${{ github.ref }}"}}'

#  deploy-staging-preprod:
#    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch' && github.event.inputs.no-release != 'true'
#    permissions:
#      id-token: write
#      contents: write
#    needs: [validate-inputs, run-all-tests-on-n2-epoch]
#    runs-on: eks
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#      - name: Deploy staging-preprod
#        uses: ./.github/actions/deploy/deploy-staging-preprod
#        with:
#          image: ${{ secrets.ECR_REGISTRY_SECRET }}/substrate-node:${{ github.event.inputs.sha }}
#          chain-spec-secret: ${{ github.event.inputs.chain-spec-secret }}
#        env:
#          AWS_REGION: "eu-central-1"
#          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
#          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
#          AWS_ROLE_ARN_SECRET: ${{ secrets.AWS_ROLE_ARN_SECRET }}
#          ECR_REGISTRY_SECRET: ${{ secrets.ECR_REGISTRY_SECRET }}
#          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
#          K8S_SERVER: ${{ secrets.K8S_SERVER }}
#          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
#
#  staging-preprod-tests:
#    if: needs.validate-inputs.outputs.mode != 'ci' && github.event_name == 'workflow_dispatch' && github.event.inputs.no-release != 'true'
#    permissions:
#      id-token: write
#      contents: write
#    needs: [validate-inputs, deploy-staging-preprod]
#    runs-on: eks
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#      - name: Run Tests
#        uses: ./.github/actions/tests/staging-preprod-tests
#        with:
#          node-host: staging-preprod-validator-1.staging-preprod.svc.cluster.local
#          node-port: 9933
#        env:
#          SSH_AUTH_SOCK: /tmp/ssh_agent.sock
#          AWS_ROLE_ARN_: ${{ secrets.AWS_ROLE_ARN_ }}
#          SSH_KEY_BINARY_HOST: ${{ secrets.SSH_KEY_BINARY_HOST }}
#          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
#          JIRA_URL: ${{ secrets.JIRA_URL }}
#          ACTIONS_PAT: ${{ secrets.ACTIONS_PAT }}
#          kubeconfig_base64: ${{ secrets.kubeconfig_base64 }}
#          K8S_SERVER: ${{ secrets.K8S_SERVER }}
#          K8S_SA_TOKEN: ${{ secrets.K8S_SA_TOKEN }}
#